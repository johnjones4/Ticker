// Package coingecko provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package coingecko

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes       = "apiKeyAuth.Scopes"
	ApiKeyQueryParamScopes = "apiKeyQueryParam.Scopes"
)

// Defines values for AssetPlatformsListParamsFilter.
const (
	Nft AssetPlatformsListParamsFilter = "nft"
)

// Defines values for CoinsCategoriesParamsOrder.
const (
	CoinsCategoriesParamsOrderMarketCapAsc           CoinsCategoriesParamsOrder = "market_cap_asc"
	CoinsCategoriesParamsOrderMarketCapChange24hAsc  CoinsCategoriesParamsOrder = "market_cap_change_24h_asc"
	CoinsCategoriesParamsOrderMarketCapChange24hDesc CoinsCategoriesParamsOrder = "market_cap_change_24h_desc"
	CoinsCategoriesParamsOrderMarketCapDesc          CoinsCategoriesParamsOrder = "market_cap_desc"
	CoinsCategoriesParamsOrderNameAsc                CoinsCategoriesParamsOrder = "name_asc"
	CoinsCategoriesParamsOrderNameDesc               CoinsCategoriesParamsOrder = "name_desc"
)

// Defines values for CoinsMarketsParamsIncludeTokens.
const (
	CoinsMarketsParamsIncludeTokensAll CoinsMarketsParamsIncludeTokens = "all"
	CoinsMarketsParamsIncludeTokensTop CoinsMarketsParamsIncludeTokens = "top"
)

// Defines values for CoinsMarketsParamsOrder.
const (
	CoinsMarketsParamsOrderIdAsc         CoinsMarketsParamsOrder = "id_asc"
	CoinsMarketsParamsOrderIdDesc        CoinsMarketsParamsOrder = "id_desc"
	CoinsMarketsParamsOrderMarketCapAsc  CoinsMarketsParamsOrder = "market_cap_asc"
	CoinsMarketsParamsOrderMarketCapDesc CoinsMarketsParamsOrder = "market_cap_desc"
	CoinsMarketsParamsOrderVolumeAsc     CoinsMarketsParamsOrder = "volume_asc"
	CoinsMarketsParamsOrderVolumeDesc    CoinsMarketsParamsOrder = "volume_desc"
)

// Defines values for CoinsMarketsParamsLocale.
const (
	Ar   CoinsMarketsParamsLocale = "ar"
	Bg   CoinsMarketsParamsLocale = "bg"
	Cs   CoinsMarketsParamsLocale = "cs"
	Da   CoinsMarketsParamsLocale = "da"
	De   CoinsMarketsParamsLocale = "de"
	El   CoinsMarketsParamsLocale = "el"
	En   CoinsMarketsParamsLocale = "en"
	Es   CoinsMarketsParamsLocale = "es"
	Fi   CoinsMarketsParamsLocale = "fi"
	Fr   CoinsMarketsParamsLocale = "fr"
	He   CoinsMarketsParamsLocale = "he"
	Hi   CoinsMarketsParamsLocale = "hi"
	Hr   CoinsMarketsParamsLocale = "hr"
	Hu   CoinsMarketsParamsLocale = "hu"
	Id   CoinsMarketsParamsLocale = "id"
	It   CoinsMarketsParamsLocale = "it"
	Ja   CoinsMarketsParamsLocale = "ja"
	Ko   CoinsMarketsParamsLocale = "ko"
	Lt   CoinsMarketsParamsLocale = "lt"
	Nl   CoinsMarketsParamsLocale = "nl"
	No   CoinsMarketsParamsLocale = "no"
	Pl   CoinsMarketsParamsLocale = "pl"
	Pt   CoinsMarketsParamsLocale = "pt"
	Ro   CoinsMarketsParamsLocale = "ro"
	Ru   CoinsMarketsParamsLocale = "ru"
	Sk   CoinsMarketsParamsLocale = "sk"
	Sl   CoinsMarketsParamsLocale = "sl"
	Sv   CoinsMarketsParamsLocale = "sv"
	Th   CoinsMarketsParamsLocale = "th"
	Tr   CoinsMarketsParamsLocale = "tr"
	Uk   CoinsMarketsParamsLocale = "uk"
	Vi   CoinsMarketsParamsLocale = "vi"
	Zh   CoinsMarketsParamsLocale = "zh"
	ZhTw CoinsMarketsParamsLocale = "zh-tw"
)

// Defines values for CoinsMarketsParamsPrecision.
const (
	CoinsMarketsParamsPrecisionFull CoinsMarketsParamsPrecision = "full"
	CoinsMarketsParamsPrecisionN0   CoinsMarketsParamsPrecision = "0"
	CoinsMarketsParamsPrecisionN1   CoinsMarketsParamsPrecision = "1"
	CoinsMarketsParamsPrecisionN10  CoinsMarketsParamsPrecision = "10"
	CoinsMarketsParamsPrecisionN11  CoinsMarketsParamsPrecision = "11"
	CoinsMarketsParamsPrecisionN12  CoinsMarketsParamsPrecision = "12"
	CoinsMarketsParamsPrecisionN13  CoinsMarketsParamsPrecision = "13"
	CoinsMarketsParamsPrecisionN14  CoinsMarketsParamsPrecision = "14"
	CoinsMarketsParamsPrecisionN15  CoinsMarketsParamsPrecision = "15"
	CoinsMarketsParamsPrecisionN16  CoinsMarketsParamsPrecision = "16"
	CoinsMarketsParamsPrecisionN17  CoinsMarketsParamsPrecision = "17"
	CoinsMarketsParamsPrecisionN18  CoinsMarketsParamsPrecision = "18"
	CoinsMarketsParamsPrecisionN2   CoinsMarketsParamsPrecision = "2"
	CoinsMarketsParamsPrecisionN3   CoinsMarketsParamsPrecision = "3"
	CoinsMarketsParamsPrecisionN4   CoinsMarketsParamsPrecision = "4"
	CoinsMarketsParamsPrecisionN5   CoinsMarketsParamsPrecision = "5"
	CoinsMarketsParamsPrecisionN6   CoinsMarketsParamsPrecision = "6"
	CoinsMarketsParamsPrecisionN7   CoinsMarketsParamsPrecision = "7"
	CoinsMarketsParamsPrecisionN8   CoinsMarketsParamsPrecision = "8"
	CoinsMarketsParamsPrecisionN9   CoinsMarketsParamsPrecision = "9"
)

// Defines values for CoinsIdParamsDexPairFormat.
const (
	CoinsIdParamsDexPairFormatContractAddress CoinsIdParamsDexPairFormat = "contract_address"
	CoinsIdParamsDexPairFormatSymbol          CoinsIdParamsDexPairFormat = "symbol"
)

// Defines values for ContractAddressMarketChartParamsInterval.
const (
	ContractAddressMarketChartParamsIntervalDaily ContractAddressMarketChartParamsInterval = "daily"
)

// Defines values for ContractAddressMarketChartParamsPrecision.
const (
	ContractAddressMarketChartParamsPrecisionFull ContractAddressMarketChartParamsPrecision = "full"
	ContractAddressMarketChartParamsPrecisionN0   ContractAddressMarketChartParamsPrecision = "0"
	ContractAddressMarketChartParamsPrecisionN1   ContractAddressMarketChartParamsPrecision = "1"
	ContractAddressMarketChartParamsPrecisionN10  ContractAddressMarketChartParamsPrecision = "10"
	ContractAddressMarketChartParamsPrecisionN11  ContractAddressMarketChartParamsPrecision = "11"
	ContractAddressMarketChartParamsPrecisionN12  ContractAddressMarketChartParamsPrecision = "12"
	ContractAddressMarketChartParamsPrecisionN13  ContractAddressMarketChartParamsPrecision = "13"
	ContractAddressMarketChartParamsPrecisionN14  ContractAddressMarketChartParamsPrecision = "14"
	ContractAddressMarketChartParamsPrecisionN15  ContractAddressMarketChartParamsPrecision = "15"
	ContractAddressMarketChartParamsPrecisionN16  ContractAddressMarketChartParamsPrecision = "16"
	ContractAddressMarketChartParamsPrecisionN17  ContractAddressMarketChartParamsPrecision = "17"
	ContractAddressMarketChartParamsPrecisionN18  ContractAddressMarketChartParamsPrecision = "18"
	ContractAddressMarketChartParamsPrecisionN2   ContractAddressMarketChartParamsPrecision = "2"
	ContractAddressMarketChartParamsPrecisionN3   ContractAddressMarketChartParamsPrecision = "3"
	ContractAddressMarketChartParamsPrecisionN4   ContractAddressMarketChartParamsPrecision = "4"
	ContractAddressMarketChartParamsPrecisionN5   ContractAddressMarketChartParamsPrecision = "5"
	ContractAddressMarketChartParamsPrecisionN6   ContractAddressMarketChartParamsPrecision = "6"
	ContractAddressMarketChartParamsPrecisionN7   ContractAddressMarketChartParamsPrecision = "7"
	ContractAddressMarketChartParamsPrecisionN8   ContractAddressMarketChartParamsPrecision = "8"
	ContractAddressMarketChartParamsPrecisionN9   ContractAddressMarketChartParamsPrecision = "9"
)

// Defines values for ContractAddressMarketChartRangeParamsPrecision.
const (
	ContractAddressMarketChartRangeParamsPrecisionFull ContractAddressMarketChartRangeParamsPrecision = "full"
	ContractAddressMarketChartRangeParamsPrecisionN0   ContractAddressMarketChartRangeParamsPrecision = "0"
	ContractAddressMarketChartRangeParamsPrecisionN1   ContractAddressMarketChartRangeParamsPrecision = "1"
	ContractAddressMarketChartRangeParamsPrecisionN10  ContractAddressMarketChartRangeParamsPrecision = "10"
	ContractAddressMarketChartRangeParamsPrecisionN11  ContractAddressMarketChartRangeParamsPrecision = "11"
	ContractAddressMarketChartRangeParamsPrecisionN12  ContractAddressMarketChartRangeParamsPrecision = "12"
	ContractAddressMarketChartRangeParamsPrecisionN13  ContractAddressMarketChartRangeParamsPrecision = "13"
	ContractAddressMarketChartRangeParamsPrecisionN14  ContractAddressMarketChartRangeParamsPrecision = "14"
	ContractAddressMarketChartRangeParamsPrecisionN15  ContractAddressMarketChartRangeParamsPrecision = "15"
	ContractAddressMarketChartRangeParamsPrecisionN16  ContractAddressMarketChartRangeParamsPrecision = "16"
	ContractAddressMarketChartRangeParamsPrecisionN17  ContractAddressMarketChartRangeParamsPrecision = "17"
	ContractAddressMarketChartRangeParamsPrecisionN18  ContractAddressMarketChartRangeParamsPrecision = "18"
	ContractAddressMarketChartRangeParamsPrecisionN2   ContractAddressMarketChartRangeParamsPrecision = "2"
	ContractAddressMarketChartRangeParamsPrecisionN3   ContractAddressMarketChartRangeParamsPrecision = "3"
	ContractAddressMarketChartRangeParamsPrecisionN4   ContractAddressMarketChartRangeParamsPrecision = "4"
	ContractAddressMarketChartRangeParamsPrecisionN5   ContractAddressMarketChartRangeParamsPrecision = "5"
	ContractAddressMarketChartRangeParamsPrecisionN6   ContractAddressMarketChartRangeParamsPrecision = "6"
	ContractAddressMarketChartRangeParamsPrecisionN7   ContractAddressMarketChartRangeParamsPrecision = "7"
	ContractAddressMarketChartRangeParamsPrecisionN8   ContractAddressMarketChartRangeParamsPrecision = "8"
	ContractAddressMarketChartRangeParamsPrecisionN9   ContractAddressMarketChartRangeParamsPrecision = "9"
)

// Defines values for CoinsIdMarketChartParamsInterval.
const (
	CoinsIdMarketChartParamsIntervalDaily CoinsIdMarketChartParamsInterval = "daily"
)

// Defines values for CoinsIdMarketChartParamsPrecision.
const (
	CoinsIdMarketChartParamsPrecisionFull CoinsIdMarketChartParamsPrecision = "full"
	CoinsIdMarketChartParamsPrecisionN0   CoinsIdMarketChartParamsPrecision = "0"
	CoinsIdMarketChartParamsPrecisionN1   CoinsIdMarketChartParamsPrecision = "1"
	CoinsIdMarketChartParamsPrecisionN10  CoinsIdMarketChartParamsPrecision = "10"
	CoinsIdMarketChartParamsPrecisionN11  CoinsIdMarketChartParamsPrecision = "11"
	CoinsIdMarketChartParamsPrecisionN12  CoinsIdMarketChartParamsPrecision = "12"
	CoinsIdMarketChartParamsPrecisionN13  CoinsIdMarketChartParamsPrecision = "13"
	CoinsIdMarketChartParamsPrecisionN14  CoinsIdMarketChartParamsPrecision = "14"
	CoinsIdMarketChartParamsPrecisionN15  CoinsIdMarketChartParamsPrecision = "15"
	CoinsIdMarketChartParamsPrecisionN16  CoinsIdMarketChartParamsPrecision = "16"
	CoinsIdMarketChartParamsPrecisionN17  CoinsIdMarketChartParamsPrecision = "17"
	CoinsIdMarketChartParamsPrecisionN18  CoinsIdMarketChartParamsPrecision = "18"
	CoinsIdMarketChartParamsPrecisionN2   CoinsIdMarketChartParamsPrecision = "2"
	CoinsIdMarketChartParamsPrecisionN3   CoinsIdMarketChartParamsPrecision = "3"
	CoinsIdMarketChartParamsPrecisionN4   CoinsIdMarketChartParamsPrecision = "4"
	CoinsIdMarketChartParamsPrecisionN5   CoinsIdMarketChartParamsPrecision = "5"
	CoinsIdMarketChartParamsPrecisionN6   CoinsIdMarketChartParamsPrecision = "6"
	CoinsIdMarketChartParamsPrecisionN7   CoinsIdMarketChartParamsPrecision = "7"
	CoinsIdMarketChartParamsPrecisionN8   CoinsIdMarketChartParamsPrecision = "8"
	CoinsIdMarketChartParamsPrecisionN9   CoinsIdMarketChartParamsPrecision = "9"
)

// Defines values for CoinsIdMarketChartRangeParamsPrecision.
const (
	CoinsIdMarketChartRangeParamsPrecisionFull CoinsIdMarketChartRangeParamsPrecision = "full"
	CoinsIdMarketChartRangeParamsPrecisionN0   CoinsIdMarketChartRangeParamsPrecision = "0"
	CoinsIdMarketChartRangeParamsPrecisionN1   CoinsIdMarketChartRangeParamsPrecision = "1"
	CoinsIdMarketChartRangeParamsPrecisionN10  CoinsIdMarketChartRangeParamsPrecision = "10"
	CoinsIdMarketChartRangeParamsPrecisionN11  CoinsIdMarketChartRangeParamsPrecision = "11"
	CoinsIdMarketChartRangeParamsPrecisionN12  CoinsIdMarketChartRangeParamsPrecision = "12"
	CoinsIdMarketChartRangeParamsPrecisionN13  CoinsIdMarketChartRangeParamsPrecision = "13"
	CoinsIdMarketChartRangeParamsPrecisionN14  CoinsIdMarketChartRangeParamsPrecision = "14"
	CoinsIdMarketChartRangeParamsPrecisionN15  CoinsIdMarketChartRangeParamsPrecision = "15"
	CoinsIdMarketChartRangeParamsPrecisionN16  CoinsIdMarketChartRangeParamsPrecision = "16"
	CoinsIdMarketChartRangeParamsPrecisionN17  CoinsIdMarketChartRangeParamsPrecision = "17"
	CoinsIdMarketChartRangeParamsPrecisionN18  CoinsIdMarketChartRangeParamsPrecision = "18"
	CoinsIdMarketChartRangeParamsPrecisionN2   CoinsIdMarketChartRangeParamsPrecision = "2"
	CoinsIdMarketChartRangeParamsPrecisionN3   CoinsIdMarketChartRangeParamsPrecision = "3"
	CoinsIdMarketChartRangeParamsPrecisionN4   CoinsIdMarketChartRangeParamsPrecision = "4"
	CoinsIdMarketChartRangeParamsPrecisionN5   CoinsIdMarketChartRangeParamsPrecision = "5"
	CoinsIdMarketChartRangeParamsPrecisionN6   CoinsIdMarketChartRangeParamsPrecision = "6"
	CoinsIdMarketChartRangeParamsPrecisionN7   CoinsIdMarketChartRangeParamsPrecision = "7"
	CoinsIdMarketChartRangeParamsPrecisionN8   CoinsIdMarketChartRangeParamsPrecision = "8"
	CoinsIdMarketChartRangeParamsPrecisionN9   CoinsIdMarketChartRangeParamsPrecision = "9"
)

// Defines values for CoinsIdOhlcParamsDays.
const (
	CoinsIdOhlcParamsDaysN1   CoinsIdOhlcParamsDays = "1"
	CoinsIdOhlcParamsDaysN14  CoinsIdOhlcParamsDays = "14"
	CoinsIdOhlcParamsDaysN180 CoinsIdOhlcParamsDays = "180"
	CoinsIdOhlcParamsDaysN30  CoinsIdOhlcParamsDays = "30"
	CoinsIdOhlcParamsDaysN365 CoinsIdOhlcParamsDays = "365"
	CoinsIdOhlcParamsDaysN7   CoinsIdOhlcParamsDays = "7"
	CoinsIdOhlcParamsDaysN90  CoinsIdOhlcParamsDays = "90"
)

// Defines values for CoinsIdOhlcParamsPrecision.
const (
	CoinsIdOhlcParamsPrecisionFull CoinsIdOhlcParamsPrecision = "full"
	CoinsIdOhlcParamsPrecisionN0   CoinsIdOhlcParamsPrecision = "0"
	CoinsIdOhlcParamsPrecisionN1   CoinsIdOhlcParamsPrecision = "1"
	CoinsIdOhlcParamsPrecisionN10  CoinsIdOhlcParamsPrecision = "10"
	CoinsIdOhlcParamsPrecisionN11  CoinsIdOhlcParamsPrecision = "11"
	CoinsIdOhlcParamsPrecisionN12  CoinsIdOhlcParamsPrecision = "12"
	CoinsIdOhlcParamsPrecisionN13  CoinsIdOhlcParamsPrecision = "13"
	CoinsIdOhlcParamsPrecisionN14  CoinsIdOhlcParamsPrecision = "14"
	CoinsIdOhlcParamsPrecisionN15  CoinsIdOhlcParamsPrecision = "15"
	CoinsIdOhlcParamsPrecisionN16  CoinsIdOhlcParamsPrecision = "16"
	CoinsIdOhlcParamsPrecisionN17  CoinsIdOhlcParamsPrecision = "17"
	CoinsIdOhlcParamsPrecisionN18  CoinsIdOhlcParamsPrecision = "18"
	CoinsIdOhlcParamsPrecisionN2   CoinsIdOhlcParamsPrecision = "2"
	CoinsIdOhlcParamsPrecisionN3   CoinsIdOhlcParamsPrecision = "3"
	CoinsIdOhlcParamsPrecisionN4   CoinsIdOhlcParamsPrecision = "4"
	CoinsIdOhlcParamsPrecisionN5   CoinsIdOhlcParamsPrecision = "5"
	CoinsIdOhlcParamsPrecisionN6   CoinsIdOhlcParamsPrecision = "6"
	CoinsIdOhlcParamsPrecisionN7   CoinsIdOhlcParamsPrecision = "7"
	CoinsIdOhlcParamsPrecisionN8   CoinsIdOhlcParamsPrecision = "8"
	CoinsIdOhlcParamsPrecisionN9   CoinsIdOhlcParamsPrecision = "9"
)

// Defines values for CoinsIdTickersParamsOrder.
const (
	CoinsIdTickersParamsOrderTrustScoreAsc  CoinsIdTickersParamsOrder = "trust_score_asc"
	CoinsIdTickersParamsOrderTrustScoreDesc CoinsIdTickersParamsOrder = "trust_score_desc"
	CoinsIdTickersParamsOrderVolumeAsc      CoinsIdTickersParamsOrder = "volume_asc"
	CoinsIdTickersParamsOrderVolumeDesc     CoinsIdTickersParamsOrder = "volume_desc"
)

// Defines values for CoinsIdTickersParamsDexPairFormat.
const (
	CoinsIdTickersParamsDexPairFormatContractAddress CoinsIdTickersParamsDexPairFormat = "contract_address"
	CoinsIdTickersParamsDexPairFormatSymbol          CoinsIdTickersParamsDexPairFormat = "symbol"
)

// Defines values for CompaniesPublicTreasuryParamsCoinId.
const (
	Bitcoin  CompaniesPublicTreasuryParamsCoinId = "bitcoin"
	Ethereum CompaniesPublicTreasuryParamsCoinId = "ethereum"
)

// Defines values for DerivativesExchangesParamsOrder.
const (
	NameAsc               DerivativesExchangesParamsOrder = "name_asc"
	NameDesc              DerivativesExchangesParamsOrder = "name_desc"
	OpenInterestBtcAsc    DerivativesExchangesParamsOrder = "open_interest_btc_asc"
	OpenInterestBtcDesc   DerivativesExchangesParamsOrder = "open_interest_btc_desc"
	TradeVolume24hBtcAsc  DerivativesExchangesParamsOrder = "trade_volume_24h_btc_asc"
	TradeVolume24hBtcDesc DerivativesExchangesParamsOrder = "trade_volume_24h_btc_desc"
)

// Defines values for DerivativesExchangesIdParamsIncludeTickers.
const (
	DerivativesExchangesIdParamsIncludeTickersAll       DerivativesExchangesIdParamsIncludeTickers = "all"
	DerivativesExchangesIdParamsIncludeTickersUnexpired DerivativesExchangesIdParamsIncludeTickers = "unexpired"
)

// Defines values for ExchangesListParamsStatus.
const (
	Active   ExchangesListParamsStatus = "active"
	Inactive ExchangesListParamsStatus = "inactive"
)

// Defines values for ExchangesIdParamsDexPairFormat.
const (
	ExchangesIdParamsDexPairFormatContractAddress ExchangesIdParamsDexPairFormat = "contract_address"
	ExchangesIdParamsDexPairFormatSymbol          ExchangesIdParamsDexPairFormat = "symbol"
)

// Defines values for ExchangesIdTickersParamsOrder.
const (
	ExchangesIdTickersParamsOrderBaseTarget     ExchangesIdTickersParamsOrder = "base_target"
	ExchangesIdTickersParamsOrderTrustScoreAsc  ExchangesIdTickersParamsOrder = "trust_score_asc"
	ExchangesIdTickersParamsOrderTrustScoreDesc ExchangesIdTickersParamsOrder = "trust_score_desc"
	ExchangesIdTickersParamsOrderVolumeAsc      ExchangesIdTickersParamsOrder = "volume_asc"
	ExchangesIdTickersParamsOrderVolumeDesc     ExchangesIdTickersParamsOrder = "volume_desc"
)

// Defines values for ExchangesIdTickersParamsDexPairFormat.
const (
	ExchangesIdTickersParamsDexPairFormatContractAddress ExchangesIdTickersParamsDexPairFormat = "contract_address"
	ExchangesIdTickersParamsDexPairFormatSymbol          ExchangesIdTickersParamsDexPairFormat = "symbol"
)

// Defines values for ExchangesIdVolumeChartParamsDays.
const (
	ExchangesIdVolumeChartParamsDaysN1   ExchangesIdVolumeChartParamsDays = "1"
	ExchangesIdVolumeChartParamsDaysN14  ExchangesIdVolumeChartParamsDays = "14"
	ExchangesIdVolumeChartParamsDaysN180 ExchangesIdVolumeChartParamsDays = "180"
	ExchangesIdVolumeChartParamsDaysN30  ExchangesIdVolumeChartParamsDays = "30"
	ExchangesIdVolumeChartParamsDaysN365 ExchangesIdVolumeChartParamsDays = "365"
	ExchangesIdVolumeChartParamsDaysN7   ExchangesIdVolumeChartParamsDays = "7"
	ExchangesIdVolumeChartParamsDaysN90  ExchangesIdVolumeChartParamsDays = "90"
)

// Defines values for NftsListParamsOrder.
const (
	FloorPriceNativeAsc  NftsListParamsOrder = "floor_price_native_asc"
	FloorPriceNativeDesc NftsListParamsOrder = "floor_price_native_desc"
	H24VolumeNativeAsc   NftsListParamsOrder = "h24_volume_native_asc"
	H24VolumeNativeDesc  NftsListParamsOrder = "h24_volume_native_desc"
	H24VolumeUsdAsc      NftsListParamsOrder = "h24_volume_usd_asc"
	H24VolumeUsdDesc     NftsListParamsOrder = "h24_volume_usd_desc"
	MarketCapNativeAsc   NftsListParamsOrder = "market_cap_native_asc"
	MarketCapNativeDesc  NftsListParamsOrder = "market_cap_native_desc"
	MarketCapUsdAsc      NftsListParamsOrder = "market_cap_usd_asc"
	MarketCapUsdDesc     NftsListParamsOrder = "market_cap_usd_desc"
)

// Defines values for SimplePriceParamsIncludeTokens.
const (
	All SimplePriceParamsIncludeTokens = "all"
	Top SimplePriceParamsIncludeTokens = "top"
)

// Defines values for SimplePriceParamsPrecision.
const (
	SimplePriceParamsPrecisionFull SimplePriceParamsPrecision = "full"
	SimplePriceParamsPrecisionN0   SimplePriceParamsPrecision = "0"
	SimplePriceParamsPrecisionN1   SimplePriceParamsPrecision = "1"
	SimplePriceParamsPrecisionN10  SimplePriceParamsPrecision = "10"
	SimplePriceParamsPrecisionN11  SimplePriceParamsPrecision = "11"
	SimplePriceParamsPrecisionN12  SimplePriceParamsPrecision = "12"
	SimplePriceParamsPrecisionN13  SimplePriceParamsPrecision = "13"
	SimplePriceParamsPrecisionN14  SimplePriceParamsPrecision = "14"
	SimplePriceParamsPrecisionN15  SimplePriceParamsPrecision = "15"
	SimplePriceParamsPrecisionN16  SimplePriceParamsPrecision = "16"
	SimplePriceParamsPrecisionN17  SimplePriceParamsPrecision = "17"
	SimplePriceParamsPrecisionN18  SimplePriceParamsPrecision = "18"
	SimplePriceParamsPrecisionN2   SimplePriceParamsPrecision = "2"
	SimplePriceParamsPrecisionN3   SimplePriceParamsPrecision = "3"
	SimplePriceParamsPrecisionN4   SimplePriceParamsPrecision = "4"
	SimplePriceParamsPrecisionN5   SimplePriceParamsPrecision = "5"
	SimplePriceParamsPrecisionN6   SimplePriceParamsPrecision = "6"
	SimplePriceParamsPrecisionN7   SimplePriceParamsPrecision = "7"
	SimplePriceParamsPrecisionN8   SimplePriceParamsPrecision = "8"
	SimplePriceParamsPrecisionN9   SimplePriceParamsPrecision = "9"
)

// Defines values for SimpleTokenPriceParamsPrecision.
const (
	SimpleTokenPriceParamsPrecisionFull SimpleTokenPriceParamsPrecision = "full"
	SimpleTokenPriceParamsPrecisionN0   SimpleTokenPriceParamsPrecision = "0"
	SimpleTokenPriceParamsPrecisionN1   SimpleTokenPriceParamsPrecision = "1"
	SimpleTokenPriceParamsPrecisionN10  SimpleTokenPriceParamsPrecision = "10"
	SimpleTokenPriceParamsPrecisionN11  SimpleTokenPriceParamsPrecision = "11"
	SimpleTokenPriceParamsPrecisionN12  SimpleTokenPriceParamsPrecision = "12"
	SimpleTokenPriceParamsPrecisionN13  SimpleTokenPriceParamsPrecision = "13"
	SimpleTokenPriceParamsPrecisionN14  SimpleTokenPriceParamsPrecision = "14"
	SimpleTokenPriceParamsPrecisionN15  SimpleTokenPriceParamsPrecision = "15"
	SimpleTokenPriceParamsPrecisionN16  SimpleTokenPriceParamsPrecision = "16"
	SimpleTokenPriceParamsPrecisionN17  SimpleTokenPriceParamsPrecision = "17"
	SimpleTokenPriceParamsPrecisionN18  SimpleTokenPriceParamsPrecision = "18"
	SimpleTokenPriceParamsPrecisionN2   SimpleTokenPriceParamsPrecision = "2"
	SimpleTokenPriceParamsPrecisionN3   SimpleTokenPriceParamsPrecision = "3"
	SimpleTokenPriceParamsPrecisionN4   SimpleTokenPriceParamsPrecision = "4"
	SimpleTokenPriceParamsPrecisionN5   SimpleTokenPriceParamsPrecision = "5"
	SimpleTokenPriceParamsPrecisionN6   SimpleTokenPriceParamsPrecision = "6"
	SimpleTokenPriceParamsPrecisionN7   SimpleTokenPriceParamsPrecision = "7"
	SimpleTokenPriceParamsPrecisionN8   SimpleTokenPriceParamsPrecision = "8"
	SimpleTokenPriceParamsPrecisionN9   SimpleTokenPriceParamsPrecision = "9"
)

// AssetPlatforms defines model for AssetPlatforms.
type AssetPlatforms = []struct {
	// ChainIdentifier chainlist's chain ID
	ChainIdentifier *float32 `json:"chain_identifier"`

	// Id asset platform ID
	Id *string `json:"id,omitempty"`

	// Image image of the asset platform
	Image *struct {
		Large *string `json:"large,omitempty"`
		Small *string `json:"small,omitempty"`
		Thumb *string `json:"thumb,omitempty"`
	} `json:"image,omitempty"`

	// Name chain name
	Name *string `json:"name,omitempty"`

	// NativeCoinId chain native coin ID
	NativeCoinId *string `json:"native_coin_id,omitempty"`

	// Shortname chain shortname
	Shortname *string `json:"shortname,omitempty"`
}

// Categories defines model for Categories.
type Categories struct {
	// Content category description
	Content *string `json:"content,omitempty"`

	// Id category ID
	Id *string `json:"id,omitempty"`

	// MarketCap category market cap
	MarketCap *float32 `json:"market_cap,omitempty"`

	// MarketCapChange24h category market cap change in 24 hours
	MarketCapChange24h *float32 `json:"market_cap_change_24h,omitempty"`

	// Name category name
	Name *string `json:"name,omitempty"`

	// Top3Coins images of top 3 coins in the category
	Top3Coins *[]string `json:"top_3_coins,omitempty"`

	// Top3CoinsId IDs of top 3 coins in the category
	Top3CoinsId *[]string `json:"top_3_coins_id,omitempty"`

	// UpdatedAt category last updated time
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Volume24h category volume in 24 hours
	Volume24h *float32 `json:"volume_24h,omitempty"`
}

// CategoriesList defines model for CategoriesList.
type CategoriesList struct {
	// CategoryId category ID
	CategoryId *string `json:"category_id,omitempty"`

	// Name category name
	Name *string `json:"name,omitempty"`
}

// CoinsContractAddress defines model for CoinsContractAddress.
type CoinsContractAddress = CoinsDataBase

// CoinsDataBase defines model for CoinsDataBase.
type CoinsDataBase struct {
	// AdditionalNotices additional notices
	AdditionalNotices *[]string `json:"additional_notices,omitempty"`

	// AssetPlatformId coin asset platform ID
	AssetPlatformId *string `json:"asset_platform_id,omitempty"`

	// BlockTimeInMinutes blockchain block time in minutes
	BlockTimeInMinutes *float32 `json:"block_time_in_minutes,omitempty"`

	// Categories coin categories
	Categories *[]string `json:"categories,omitempty"`

	// CommunityData coin community data
	CommunityData *struct {
		// FacebookLikes coin facebook likes
		FacebookLikes *float32 `json:"facebook_likes,omitempty"`

		// RedditAccountsActive48h coin reddit active accounts in 48 hours
		RedditAccountsActive48h *float32 `json:"reddit_accounts_active_48h,omitempty"`

		// RedditAverageComments48h coin reddit average comments in 48 hours
		RedditAverageComments48h *float32 `json:"reddit_average_comments_48h,omitempty"`

		// RedditAveragePosts48h coin reddit average posts in 48 hours
		RedditAveragePosts48h *float32 `json:"reddit_average_posts_48h,omitempty"`

		// RedditSubscribers coin reddit subscribers
		RedditSubscribers *float32 `json:"reddit_subscribers,omitempty"`

		// TelegramChannelUserCount coin telegram channel user count
		TelegramChannelUserCount *float32 `json:"telegram_channel_user_count,omitempty"`

		// TwitterFollowers coin twitter followers
		TwitterFollowers *float32 `json:"twitter_followers,omitempty"`
	} `json:"community_data,omitempty"`

	// CountryOrigin coin country of origin
	CountryOrigin *string `json:"country_origin,omitempty"`

	// Description coin description
	Description *map[string]string `json:"description,omitempty"`

	// DetailPlatforms detailed coin asset platform and contract address
	DetailPlatforms *map[string]string `json:"detail_platforms,omitempty"`

	// DeveloperData coin developer data
	DeveloperData *struct {
		// ClosedIssues coin repository closed issues
		ClosedIssues *float32 `json:"closed_issues,omitempty"`

		// CodeAdditionsDeletions4Weeks coin code additions and deletions in 4 weeks
		CodeAdditionsDeletions4Weeks *struct {
			Additions *float32 `json:"additions,omitempty"`
			Deletions *float32 `json:"deletions,omitempty"`
		} `json:"code_additions_deletions_4_weeks,omitempty"`

		// CommitCount4Weeks coin repository commit count in 4 weeks
		CommitCount4Weeks *float32 `json:"commit_count_4_weeks,omitempty"`

		// Forks coin repository forks
		Forks *float32 `json:"forks,omitempty"`

		// Last4WeeksCommitActivitySeries coin repository last 4 weeks commit activity series
		Last4WeeksCommitActivitySeries *[]float32 `json:"last_4_weeks_commit_activity_series,omitempty"`

		// PullRequestContributors coin repository pull request contributors
		PullRequestContributors *float32 `json:"pull_request_contributors,omitempty"`

		// PullRequestsMerged coin repository pull requests merged
		PullRequestsMerged *float32 `json:"pull_requests_merged,omitempty"`

		// Stars coin repository stars
		Stars *float32 `json:"stars,omitempty"`

		// Subscribers coin repository subscribers
		Subscribers *float32 `json:"subscribers,omitempty"`

		// TotalIssues coin repository total issues
		TotalIssues *float32 `json:"total_issues,omitempty"`
	} `json:"developer_data,omitempty"`

	// GenesisDate coin genesis date
	GenesisDate *time.Time `json:"genesis_date,omitempty"`

	// HashingAlgorithm blockchain hashing algorithm
	HashingAlgorithm *string `json:"hashing_algorithm,omitempty"`

	// Id coin ID
	Id *string `json:"id,omitempty"`

	// Image coin image url
	Image *struct {
		Large *string `json:"large,omitempty"`
		Small *string `json:"small,omitempty"`
		Thumb *string `json:"thumb,omitempty"`
	} `json:"image,omitempty"`

	// LastUpdated coin last updated timestamp
	LastUpdated *time.Time `json:"last_updated,omitempty"`

	// Links links
	Links *struct {
		// AnnouncementUrl coin announcement url
		AnnouncementUrl *[]string `json:"announcement_url,omitempty"`

		// BitcointalkThreadIdentifier coin bitcointalk thread identifier
		BitcointalkThreadIdentifier *string `json:"bitcointalk_thread_identifier,omitempty"`

		// BlockchainSite coin block explorer url
		BlockchainSite *[]string `json:"blockchain_site,omitempty"`

		// ChatUrl coin chat url
		ChatUrl *[]string `json:"chat_url,omitempty"`

		// FacebookUsername coin facebook username
		FacebookUsername *string `json:"facebook_username,omitempty"`

		// Homepage coin website url
		Homepage *[]string `json:"homepage,omitempty"`

		// OfficialForumUrl coin official forum url
		OfficialForumUrl *[]string `json:"official_forum_url,omitempty"`

		// ReposUrl coin repository url
		ReposUrl *struct {
			// Bitbucket coin bitbucket repository url
			Bitbucket *[]string `json:"bitbucket,omitempty"`

			// Github coin github repository url
			Github *[]string `json:"github,omitempty"`
		} `json:"repos_url,omitempty"`

		// SnapshotUrl coin snapshot url
		SnapshotUrl *string `json:"snapshot_url,omitempty"`

		// SubredditUrl coin subreddit url
		SubredditUrl *string `json:"subreddit_url,omitempty"`

		// TelegramChannelIdentifier coin telegram channel identifier
		TelegramChannelIdentifier *string `json:"telegram_channel_identifier,omitempty"`

		// TwitterScreenName coin twitter handle
		TwitterScreenName *string `json:"twitter_screen_name,omitempty"`

		// Whitepaper coin whitepaper url
		Whitepaper *[]string `json:"whitepaper,omitempty"`
	} `json:"links,omitempty"`

	// Localization coin name localization
	Localization *map[string]string `json:"localization,omitempty"`

	// MarketCapRank coin rank by market cap
	MarketCapRank *float32 `json:"market_cap_rank,omitempty"`

	// MarketData coin market data
	MarketData *struct {
		// Ath coin all time high (ATH) in currency
		Ath *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"ath,omitempty"`

		// AthChangePercentage coin all time high (ATH) change in percentage
		AthChangePercentage *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"ath_change_percentage,omitempty"`

		// AthDate coin all time high (ATH) date
		AthDate *struct {
			Btc *string `json:"btc,omitempty"`
			Eur *string `json:"eur,omitempty"`
			Usd *string `json:"usd,omitempty"`
		} `json:"ath_date,omitempty"`

		// Atl coin all time low (atl) in currency
		Atl *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"atl,omitempty"`

		// AtlChangePercentage coin all time low (atl) change in percentage
		AtlChangePercentage *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"atl_change_percentage,omitempty"`

		// AtlDate coin all time low (atl) date
		AtlDate *struct {
			Btc *string `json:"btc,omitempty"`
			Eur *string `json:"eur,omitempty"`
			Usd *string `json:"usd,omitempty"`
		} `json:"atl_date,omitempty"`

		// CirculatingSupply coin circulating supply
		CirculatingSupply *float32 `json:"circulating_supply,omitempty"`

		// CurrentPrice coin current price in currency
		CurrentPrice *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"current_price,omitempty"`

		// FdvToTvlRatio fully diluted valuation to total value locked ratio
		FdvToTvlRatio *float32 `json:"fdv_to_tvl_ratio,omitempty"`

		// FullyDilutedValuation coin fully diluted valuation (fdv) in currency
		FullyDilutedValuation *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"fully_diluted_valuation,omitempty"`

		// High24h coin 24hr price high in currency
		High24h *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"high_24h,omitempty"`

		// LastUpdated coin market data last updated timestamp
		LastUpdated *time.Time `json:"last_updated,omitempty"`

		// Low24h coin 24hr price low in currency
		Low24h *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"low_24h,omitempty"`

		// MarketCap coin market cap in currency
		MarketCap *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"market_cap,omitempty"`

		// MarketCapChange24h coin 24hr market cap change in currency
		MarketCapChange24h *float32 `json:"market_cap_change_24h,omitempty"`

		// MarketCapChange24hInCurrency coin 24hr market cap change in currency
		MarketCapChange24hInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"market_cap_change_24h_in_currency,omitempty"`

		// MarketCapChangePercentage24h coin 24hr market cap change in percentage
		MarketCapChangePercentage24h *float32 `json:"market_cap_change_percentage_24h,omitempty"`

		// MarketCapChangePercentage24hInCurrency coin 24hr market cap change in percentage
		MarketCapChangePercentage24hInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"market_cap_change_percentage_24h_in_currency,omitempty"`

		// MarketCapFdvRatio market cap to fully diluted valuation ratio
		MarketCapFdvRatio *float32 `json:"market_cap_fdv_ratio,omitempty"`

		// MarketCapRank coin rank by market cap
		MarketCapRank *float32 `json:"market_cap_rank,omitempty"`

		// MaxSupply coin max supply
		MaxSupply *float32 `json:"max_supply,omitempty"`

		// McapToTvlRatio market cap to total value locked ratio
		McapToTvlRatio *float32 `json:"mcap_to_tvl_ratio,omitempty"`

		// PriceChange24h coin 24hr price change in currency
		PriceChange24h *float32 `json:"price_change_24h,omitempty"`

		// PriceChangePercentage14d coin 14d price change in percentage
		PriceChangePercentage14d *float32 `json:"price_change_percentage_14d,omitempty"`

		// PriceChangePercentage14dInCurrency coin 14d price change in currency
		PriceChangePercentage14dInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_14d_in_currency,omitempty"`

		// PriceChangePercentage1hInCurrency coin 1h price change in currency
		PriceChangePercentage1hInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_1h_in_currency,omitempty"`

		// PriceChangePercentage1y coin 1y price change in percentage
		PriceChangePercentage1y *float32 `json:"price_change_percentage_1y,omitempty"`

		// PriceChangePercentage1yInCurrency coin 1y price change in currency
		PriceChangePercentage1yInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_1y_in_currency,omitempty"`

		// PriceChangePercentage200d coin 200d price change in percentage
		PriceChangePercentage200d *float32 `json:"price_change_percentage_200d,omitempty"`

		// PriceChangePercentage200dInCurrency coin 200d price change in currency
		PriceChangePercentage200dInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_200d_in_currency,omitempty"`

		// PriceChangePercentage24h coin 24hr price change in percentage
		PriceChangePercentage24h *float32 `json:"price_change_percentage_24h,omitempty"`

		// PriceChangePercentage24hInCurrency coin 24hr price change in currency
		PriceChangePercentage24hInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_24h_in_currency,omitempty"`

		// PriceChangePercentage30d coin 30d price change in percentage
		PriceChangePercentage30d *float32 `json:"price_change_percentage_30d,omitempty"`

		// PriceChangePercentage30dInCurrency coin 30d price change in currency
		PriceChangePercentage30dInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_30d_in_currency,omitempty"`

		// PriceChangePercentage60d coin 60d price change in percentage
		PriceChangePercentage60d *float32 `json:"price_change_percentage_60d,omitempty"`

		// PriceChangePercentage60dInCurrency coin 60d price change in currency
		PriceChangePercentage60dInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_60d_in_currency,omitempty"`

		// PriceChangePercentage7d coin 7d price change in percentage
		PriceChangePercentage7d *float32 `json:"price_change_percentage_7d,omitempty"`

		// PriceChangePercentage7dInCurrency coin 7d price change in currency
		PriceChangePercentage7dInCurrency *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"price_change_percentage_7d_in_currency,omitempty"`

		// Roi coin return on investment
		Roi *float32 `json:"roi,omitempty"`

		// TotalSupply coin total supply
		TotalSupply *float32 `json:"total_supply,omitempty"`

		// TotalValueLocked total value locked
		TotalValueLocked *float32 `json:"total_value_locked,omitempty"`

		// TotalVolume coin total trading volume in currency
		TotalVolume *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"total_volume,omitempty"`
	} `json:"market_data,omitempty"`

	// Name coin name
	Name *string `json:"name,omitempty"`

	// Platforms coin asset platform and contract address
	Platforms *map[string]string `json:"platforms,omitempty"`

	// PreviewListing preview listing coin
	PreviewListing *bool `json:"preview_listing,omitempty"`

	// PublicNotice public notice
	PublicNotice *string `json:"public_notice,omitempty"`

	// SentimentVotesDownPercentage coin sentiment votes down percentage
	SentimentVotesDownPercentage *float32 `json:"sentiment_votes_down_percentage,omitempty"`

	// SentimentVotesUpPercentage coin sentiment votes up percentage
	SentimentVotesUpPercentage *float32 `json:"sentiment_votes_up_percentage,omitempty"`

	// StatusUpdates coin status updates
	StatusUpdates *[]string `json:"status_updates,omitempty"`

	// Symbol coin symbol
	Symbol *string `json:"symbol,omitempty"`

	// Tickers coin tickers
	Tickers *[]struct {
		// Base coin ticker base currency
		Base *string `json:"base,omitempty"`

		// BidAskSpreadPercentage coin ticker bid ask spread percentage
		BidAskSpreadPercentage *float32 `json:"bid_ask_spread_percentage,omitempty"`

		// CoinId coin ticker base currency coin ID
		CoinId *string `json:"coin_id,omitempty"`

		// ConvertedLast coin ticker converted last price
		ConvertedLast *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"converted_last,omitempty"`

		// ConvertedVolume coin ticker converted volume
		ConvertedVolume *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"converted_volume,omitempty"`

		// IsAnomaly coin ticker anomaly
		IsAnomaly *bool `json:"is_anomaly,omitempty"`

		// IsStale coin ticker stale
		IsStale *bool `json:"is_stale,omitempty"`

		// Last coin ticker last price
		Last *float32 `json:"last,omitempty"`

		// LastFetchAt coin ticker last fetch timestamp
		LastFetchAt *time.Time `json:"last_fetch_at,omitempty"`

		// LastTradedAt coin ticker last traded timestamp
		LastTradedAt *time.Time `json:"last_traded_at,omitempty"`

		// Market coin ticker exchange
		Market *struct {
			// HasTradingIncentive coin ticker exchange trading incentive
			HasTradingIncentive *bool `json:"has_trading_incentive,omitempty"`

			// Identifier coin ticker exchange identifier
			Identifier *string `json:"identifier,omitempty"`

			// Name coin ticker exchange name
			Name *string `json:"name,omitempty"`
		} `json:"market,omitempty"`

		// Target coin ticker target currency
		Target *string `json:"target,omitempty"`

		// TargetCoinId coin ticker target currency coin ID
		TargetCoinId *string `json:"target_coin_id,omitempty"`

		// Timestamp coin ticker timestamp
		Timestamp *time.Time `json:"timestamp,omitempty"`

		// TokenInfoUrl coin ticker token info url
		TokenInfoUrl *string `json:"token_info_url,omitempty"`

		// TradeUrl coin ticker trade url
		TradeUrl *string `json:"trade_url,omitempty"`

		// TrustScore coin ticker trust score
		TrustScore *string `json:"trust_score,omitempty"`

		// Volume coin ticker volume
		Volume *float32 `json:"volume,omitempty"`
	} `json:"tickers,omitempty"`

	// WebSlug coin web slug
	WebSlug *string `json:"web_slug,omitempty"`
}

// CoinsHistoricalData defines model for CoinsHistoricalData.
type CoinsHistoricalData struct {
	// CommunityData coin community data
	CommunityData *struct {
		// FacebookLikes coin facebook likes
		FacebookLikes *float32 `json:"facebook_likes,omitempty"`

		// RedditAccountsActive48h coin reddit accounts active 48h
		RedditAccountsActive48h *float32 `json:"reddit_accounts_active_48h,omitempty"`

		// RedditAverageComments48h coin reddit average comments 48h
		RedditAverageComments48h *float32 `json:"reddit_average_comments_48h,omitempty"`

		// RedditAveragePosts48h coin reddit average posts 48h
		RedditAveragePosts48h *float32 `json:"reddit_average_posts_48h,omitempty"`

		// RedditSubscribers coin reddit subscribers
		RedditSubscribers *float32 `json:"reddit_subscribers,omitempty"`

		// TwitterFollowers coin twitter followers
		TwitterFollowers *float32 `json:"twitter_followers,omitempty"`
	} `json:"community_data,omitempty"`

	// DeveloperData coin developer data
	DeveloperData *struct {
		// ClosedIssues coin repository closed issues
		ClosedIssues *float32 `json:"closed_issues,omitempty"`

		// CodeAdditionsDeletions4Weeks coin code additions deletions 4 weeks
		CodeAdditionsDeletions4Weeks *struct {
			Additions *float32 `json:"additions,omitempty"`
			Deletions *float32 `json:"deletions,omitempty"`
		} `json:"code_additions_deletions_4_weeks,omitempty"`

		// CommitCount4Weeks coin commit count 4 weeks
		CommitCount4Weeks *float32 `json:"commit_count_4_weeks,omitempty"`

		// Forks coin repository forks
		Forks *float32 `json:"forks,omitempty"`

		// PullRequestContributors coin repository pull request contributors
		PullRequestContributors *float32 `json:"pull_request_contributors,omitempty"`

		// PullRequestsMerged coin repository pull requests merged
		PullRequestsMerged *float32 `json:"pull_requests_merged,omitempty"`

		// Stars coin repository stars
		Stars *float32 `json:"stars,omitempty"`

		// Subscribers coin repository subscribers
		Subscribers *float32 `json:"subscribers,omitempty"`

		// TotalIssues coin repository total issues
		TotalIssues *float32 `json:"total_issues,omitempty"`
	} `json:"developer_data,omitempty"`

	// Id coin ID
	Id *string `json:"id,omitempty"`

	// Image coin image url
	Image *struct {
		Small *string `json:"small,omitempty"`
		Thumb *string `json:"thumb,omitempty"`
	} `json:"image,omitempty"`

	// Localization coin localization
	Localization *map[string]string `json:"localization,omitempty"`

	// MarketData coin market data
	MarketData *struct {
		// CurrentPrice coin current price
		CurrentPrice *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"current_price,omitempty"`

		// MarketCap coin market cap
		MarketCap *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"market_cap,omitempty"`

		// TotalVolume coin total volume
		TotalVolume *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eur *float32 `json:"eur,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"total_volume,omitempty"`
	} `json:"market_data,omitempty"`

	// Name coin name
	Name *string `json:"name,omitempty"`

	// PublicInterestStats coin public interest stats
	PublicInterestStats *struct {
		// AlexaRank coin alexa rank
		AlexaRank *float32 `json:"alexa_rank,omitempty"`

		// BingMatches coin bing matches
		BingMatches *float32 `json:"bing_matches,omitempty"`
	} `json:"public_interest_stats,omitempty"`

	// Symbol coin symbol
	Symbol *string `json:"symbol,omitempty"`
}

// CoinsID defines model for CoinsID.
type CoinsID = CoinsDataBase

// CoinsList defines model for CoinsList.
type CoinsList = []struct {
	// Id coin ID
	Id *string `json:"id,omitempty"`

	// Name coin name
	Name *string `json:"name,omitempty"`

	// Platforms coin asset platform and contract address
	Platforms *map[string]string `json:"platforms,omitempty"`

	// Symbol coin symbol
	Symbol *string `json:"symbol,omitempty"`
}

// CoinsMarketChart defines model for CoinsMarketChart.
type CoinsMarketChart struct {
	MarketCaps   *[][]float32 `json:"market_caps,omitempty"`
	Prices       *[][]float32 `json:"prices,omitempty"`
	TotalVolumes *[][]float32 `json:"total_volumes,omitempty"`
}

// CoinsMarketChartRange defines model for CoinsMarketChartRange.
type CoinsMarketChartRange struct {
	MarketCaps   *[][]float32 `json:"market_caps,omitempty"`
	Prices       *[][]float32 `json:"prices,omitempty"`
	TotalVolumes *[][]float32 `json:"total_volumes,omitempty"`
}

// CoinsMarkets defines model for CoinsMarkets.
type CoinsMarkets struct {
	// Ath coin all time high (ATH) in currency
	Ath *float32 `json:"ath,omitempty"`

	// AthChangePercentage coin all time high (ATH) change in percentage
	AthChangePercentage *float32 `json:"ath_change_percentage,omitempty"`

	// AthDate coin all time high (ATH) date
	AthDate *time.Time `json:"ath_date,omitempty"`

	// Atl coin all time low (atl) in currency
	Atl *float32 `json:"atl,omitempty"`

	// AtlChangePercentage coin all time low (atl) change in percentage
	AtlChangePercentage *float32 `json:"atl_change_percentage,omitempty"`

	// AtlDate coin all time low (atl) date
	AtlDate *time.Time `json:"atl_date,omitempty"`

	// CirculatingSupply coin circulating supply
	CirculatingSupply *float32 `json:"circulating_supply,omitempty"`

	// CurrentPrice coin current price in currency
	CurrentPrice *float32 `json:"current_price,omitempty"`

	// FullyDilutedValuation coin fully diluted valuation (fdv) in currency
	FullyDilutedValuation *float32 `json:"fully_diluted_valuation,omitempty"`

	// High24h coin 24hr price high in currency
	High24h *float32 `json:"high_24h,omitempty"`

	// Id coin ID
	Id *string `json:"id,omitempty"`

	// Image coin image url
	Image *string `json:"image,omitempty"`

	// LastUpdated coin last updated timestamp
	LastUpdated *time.Time `json:"last_updated,omitempty"`

	// Low24h coin 24hr price low in currency
	Low24h *float32 `json:"low_24h,omitempty"`

	// MarketCap coin market cap in currency
	MarketCap *float32 `json:"market_cap,omitempty"`

	// MarketCapChange24h coin 24hr market cap change in currency
	MarketCapChange24h *float32 `json:"market_cap_change_24h,omitempty"`

	// MarketCapChangePercentage24h coin 24hr market cap change in percentage
	MarketCapChangePercentage24h *float32 `json:"market_cap_change_percentage_24h,omitempty"`

	// MarketCapRank coin rank by market cap
	MarketCapRank *float32 `json:"market_cap_rank,omitempty"`

	// MaxSupply coin max supply
	MaxSupply *float32 `json:"max_supply,omitempty"`

	// Name coin name
	Name *string `json:"name,omitempty"`

	// PriceChange24h coin 24hr price change in currency
	PriceChange24h *float32 `json:"price_change_24h,omitempty"`

	// PriceChangePercentage24h coin 24hr price change in percentage
	PriceChangePercentage24h *float32 `json:"price_change_percentage_24h,omitempty"`
	Roi                      *string  `json:"roi,omitempty"`

	// Symbol coin symbol
	Symbol *string `json:"symbol,omitempty"`

	// TotalSupply coin total supply
	TotalSupply *float32 `json:"total_supply,omitempty"`

	// TotalVolume coin total trading volume in currency
	TotalVolume *float32 `json:"total_volume,omitempty"`
}

// CoinsOHLC defines model for CoinsOHLC.
type CoinsOHLC = [][]float32

// CoinsTickers defines model for CoinsTickers.
type CoinsTickers struct {
	// Name coin name
	Name *string `json:"name,omitempty"`

	// Tickers list of tickers
	Tickers *[]struct {
		// Base coin ticker base currency
		Base *string `json:"base,omitempty"`

		// BidAskSpreadPercentage coin ticker bid ask spread percentage
		BidAskSpreadPercentage *float32 `json:"bid_ask_spread_percentage,omitempty"`

		// CoinId coin ticker base currency coin ID
		CoinId *string `json:"coin_id,omitempty"`

		// ConvertedLast coin ticker converted last price
		ConvertedLast *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"converted_last,omitempty"`

		// ConvertedVolume coin ticker converted volume
		ConvertedVolume *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
			Usd *float32 `json:"usd,omitempty"`
		} `json:"converted_volume,omitempty"`

		// CostToMoveDownUsd coin ticker cost to move down in usd
		CostToMoveDownUsd *float32 `json:"cost_to_move_down_usd,omitempty"`

		// CostToMoveUpUsd coin ticker cost to move up in usd
		CostToMoveUpUsd *float32 `json:"cost_to_move_up_usd,omitempty"`

		// IsAnomaly coin ticker anomaly
		IsAnomaly *bool `json:"is_anomaly,omitempty"`

		// IsStale coin ticker stale
		IsStale *bool `json:"is_stale,omitempty"`

		// Last coin ticker last price
		Last *float32 `json:"last,omitempty"`

		// LastFetchAt coin ticker last fetch timestamp
		LastFetchAt *string `json:"last_fetch_at,omitempty"`

		// LastTradedAt coin ticker last traded timestamp
		LastTradedAt *string `json:"last_traded_at,omitempty"`

		// Market coin ticker exchange
		Market *struct {
			// HasTradingIncentive exchange trading incentive
			HasTradingIncentive bool `json:"has_trading_incentive"`

			// Identifier exchange identifier
			Identifier string `json:"identifier"`

			// Logo exchange image url
			Logo *string `json:"logo,omitempty"`

			// Name exchange name
			Name string `json:"name"`
		} `json:"market,omitempty"`

		// Target coin ticker target currency
		Target *string `json:"target,omitempty"`

		// TargetCoinId coin ticker target currency coin ID
		TargetCoinId *string `json:"target_coin_id,omitempty"`

		// Timestamp coin ticker timestamp
		Timestamp *string `json:"timestamp,omitempty"`

		// TokenInfoUrl coin ticker token info url
		TokenInfoUrl *string `json:"token_info_url"`

		// TradeUrl coin ticker trade url
		TradeUrl *string `json:"trade_url,omitempty"`

		// TrustScore coin ticker trust score
		TrustScore *string `json:"trust_score,omitempty"`

		// Volume coin ticker volume
		Volume *float32 `json:"volume,omitempty"`
	} `json:"tickers,omitempty"`
}

// CompaniesTreasury defines model for CompaniesTreasury.
type CompaniesTreasury struct {
	Companies *[]struct {
		// Country company incorporated country
		Country *string `json:"country,omitempty"`

		// Name company name
		Name *string `json:"name,omitempty"`

		// PercentageOfTotalSupply percentage of total btc/eth supply
		PercentageOfTotalSupply *float32 `json:"percentage_of_total_supply,omitempty"`

		// Symbol company symbol
		Symbol *string `json:"symbol,omitempty"`

		// TotalCurrentValueUsd total current value of btc/eth holdings in usd
		TotalCurrentValueUsd *float32 `json:"total_current_value_usd,omitempty"`

		// TotalEntryValueUsd total entry value in usd
		TotalEntryValueUsd *float32 `json:"total_entry_value_usd,omitempty"`

		// TotalHoldings total btc/eth holdings of company
		TotalHoldings *float32 `json:"total_holdings,omitempty"`
	} `json:"companies,omitempty"`

	// MarketCapDominance market cap dominance
	MarketCapDominance *float32 `json:"market_cap_dominance,omitempty"`

	// TotalHoldings total btc/eth holdings of companies
	TotalHoldings *float32 `json:"total_holdings,omitempty"`

	// TotalValueUsd total btc/eth holdings value in usd
	TotalValueUsd *float32 `json:"total_value_usd,omitempty"`
}

// CurrencyList defines model for CurrencyList.
type CurrencyList = []string

// DerivativesExchanges defines model for DerivativesExchanges.
type DerivativesExchanges struct {
	// Country derivatives exchange incorporated country
	Country *string `json:"country"`

	// Description derivatives exchange description
	Description *string `json:"description,omitempty"`

	// Id derivatives exchange ID
	Id *string `json:"id,omitempty"`

	// Image derivatives exchange image url
	Image *string `json:"image,omitempty"`

	// Name derivatives exchange name
	Name *string `json:"name,omitempty"`

	// NumberOfFuturesPairs number of futures pairs in the derivatives exchange
	NumberOfFuturesPairs *float32 `json:"number_of_futures_pairs,omitempty"`

	// NumberOfPerpetualPairs number of perpetual pairs in the derivatives exchange
	NumberOfPerpetualPairs *float32 `json:"number_of_perpetual_pairs,omitempty"`

	// OpenInterestBtc derivatives exchange open interest in BTC
	OpenInterestBtc *float32 `json:"open_interest_btc,omitempty"`

	// TradeVolume24hBtc derivatives exchange trade volume in BTC in 24 hours
	TradeVolume24hBtc *string `json:"trade_volume_24h_btc,omitempty"`

	// Url derivatives exchange website url
	Url *string `json:"url,omitempty"`

	// YearEstablished derivatives exchange established year
	YearEstablished *float32 `json:"year_established"`
}

// DerivativesExchangesID defines model for DerivativesExchangesID.
type DerivativesExchangesID struct {
	// Country derivatives exchange incorporated country
	Country *string `json:"country"`

	// Description derivatives exchange description
	Description *string `json:"description,omitempty"`

	// Image derivatives exchange image url
	Image *string `json:"image,omitempty"`

	// Name derivatives exchange name
	Name *string `json:"name,omitempty"`

	// NumberOfFuturesPairs number of futures pairs in the derivatives exchange
	NumberOfFuturesPairs *float32 `json:"number_of_futures_pairs,omitempty"`

	// NumberOfPerpetualPairs number of perpetual pairs in the derivatives exchange
	NumberOfPerpetualPairs *float32 `json:"number_of_perpetual_pairs,omitempty"`

	// OpenInterestBtc derivatives exchange open interest in BTC
	OpenInterestBtc *float32                  `json:"open_interest_btc,omitempty"`
	Tickers         *[]DerivativesTickersList `json:"tickers,omitempty"`

	// TradeVolume24hBtc derivatives exchange trade volume in BTC in 24 hours
	TradeVolume24hBtc *string `json:"trade_volume_24h_btc,omitempty"`

	// Url derivatives exchange website url
	Url *string `json:"url,omitempty"`

	// YearEstablished derivatives exchange established year
	YearEstablished *float32 `json:"year_established"`
}

// DerivativesExchangesList defines model for DerivativesExchangesList.
type DerivativesExchangesList struct {
	// Id derivatives exchange ID
	Id *string `json:"id,omitempty"`

	// Name derivatives exchange name
	Name *string `json:"name,omitempty"`
}

// DerivativesTickersList defines model for DerivativesTickersList.
type DerivativesTickersList struct {
	// Basis difference of derivative price and index price
	Basis *float32 `json:"basis,omitempty"`

	// ContractType derivative contract type
	ContractType *string `json:"contract_type,omitempty"`
	ExpiredAt    *string `json:"expired_at"`

	// FundingRate derivative funding rate
	FundingRate *float32 `json:"funding_rate,omitempty"`

	// Index derivative underlying asset price
	Index *float32 `json:"index,omitempty"`

	// IndexId derivative underlying asset
	IndexId *string `json:"index_id,omitempty"`

	// LastTradedAt derivative last updated time
	LastTradedAt *float32 `json:"last_traded_at,omitempty"`

	// Market derivative market name
	Market *string `json:"market,omitempty"`

	// OpenInterest derivative open interest
	OpenInterest *float32 `json:"open_interest,omitempty"`

	// Price derivative ticker price
	Price *string `json:"price,omitempty"`

	// PricePercentageChange24h derivative ticker price percentage change in 24 hours
	PricePercentageChange24h *float32 `json:"price_percentage_change_24h,omitempty"`

	// Spread derivative bid ask spread
	Spread *float32 `json:"spread,omitempty"`

	// Symbol derivative ticker symbol
	Symbol *string `json:"symbol,omitempty"`

	// Volume24h derivative volume in 24 hours
	Volume24h *float32 `json:"volume_24h,omitempty"`
}

// ExchangeData defines model for ExchangeData.
type ExchangeData struct {
	// AlertNotice alert notice for exchange
	AlertNotice *string `json:"alert_notice,omitempty"`

	// Centralized exchange type (true for centralized, false for decentralized)
	Centralized *bool `json:"centralized,omitempty"`

	// Coins number of coins listed on the exchange
	Coins *float32 `json:"coins,omitempty"`

	// Country exchange incorporated country
	Country *string `json:"country,omitempty"`

	// Description exchange description
	Description *string `json:"description,omitempty"`

	// FacebookUrl exchange facebook url
	FacebookUrl *string `json:"facebook_url,omitempty"`

	// HasTradingIncentive exchange trading incentive
	HasTradingIncentive *bool `json:"has_trading_incentive,omitempty"`

	// Image exchange image url
	Image *string `json:"image,omitempty"`

	// Name exchange name
	Name      *string `json:"name,omitempty"`
	OtherUrl1 *string `json:"other_url_1,omitempty"`
	OtherUrl2 *string `json:"other_url_2,omitempty"`

	// Pairs number of trading pairs on the exchange
	Pairs *float32 `json:"pairs,omitempty"`

	// PublicNotice public notice for exchange
	PublicNotice *string `json:"public_notice,omitempty"`

	// RedditUrl exchange reddit url
	RedditUrl *string `json:"reddit_url,omitempty"`

	// SlackUrl exchange slack url
	SlackUrl *string `json:"slack_url,omitempty"`

	// TelegramUrl exchange telegram url
	TelegramUrl       *string                   `json:"telegram_url,omitempty"`
	Tickers           *[]map[string]interface{} `json:"tickers,omitempty"`
	TradeVolume24hBtc *float32                  `json:"trade_volume_24h_btc,omitempty"`

	// TradeVolume24hBtcNormalized normalized trading volume by traffic in BTC in 24 hours <br> *refers to [`this blog`](https://blog.coingecko.com/trust-score/).
	TradeVolume24hBtcNormalized *float32 `json:"trade_volume_24h_btc_normalized,omitempty"`

	// TrustScore exchange trust score
	TrustScore *float32 `json:"trust_score,omitempty"`

	// TrustScoreRank exchange trust score rank
	TrustScoreRank *float32 `json:"trust_score_rank,omitempty"`

	// TwitterHandle exchange twitter handle
	TwitterHandle *string `json:"twitter_handle,omitempty"`

	// Url exchange website url
	Url *string `json:"url,omitempty"`

	// YearEstablished exchange established year
	YearEstablished *float32 `json:"year_established,omitempty"`
}

// ExchangeRates defines model for ExchangeRates.
type ExchangeRates struct {
	Rates *map[string]struct {
		// Name name of the currency
		Name *string `json:"name,omitempty"`

		// Type type of the currency
		Type *string `json:"type,omitempty"`

		// Unit unit of the currency
		Unit *string `json:"unit,omitempty"`

		// Value value of the currency
		Value *float32 `json:"value,omitempty"`
	} `json:"rates,omitempty"`
}

// ExchangeTickers defines model for ExchangeTickers.
type ExchangeTickers = CoinsTickers

// ExchangeVolumeChart defines model for ExchangeVolumeChart.
type ExchangeVolumeChart = [][]float32

// Exchanges defines model for Exchanges.
type Exchanges struct {
	// Country exchange country
	Country *string `json:"country,omitempty"`

	// Description exchange description
	Description *string `json:"description,omitempty"`

	// HasTradingIncentive exchange trading incentive
	HasTradingIncentive *bool `json:"has_trading_incentive,omitempty"`

	// Id exchange ID
	Id *string `json:"id,omitempty"`

	// Image exchange image url
	Image *string `json:"image,omitempty"`

	// Name exchange name
	Name *string `json:"name,omitempty"`

	// TradeVolume24hBtc exchange trade volume in BTC in 24 hours
	TradeVolume24hBtc *float32 `json:"trade_volume_24h_btc,omitempty"`

	// TradeVolume24hBtcNormalized normalized trading volume by traffic in BTC in 24 hours <br> *refers to [`this blog`](https://blog.coingecko.com/trust-score/).
	TradeVolume24hBtcNormalized *float32 `json:"trade_volume_24h_btc_normalized,omitempty"`

	// TrustScore exchange trust score
	TrustScore *float32 `json:"trust_score,omitempty"`

	// TrustScoreRank exchange trust score rank
	TrustScoreRank *float32 `json:"trust_score_rank,omitempty"`

	// Url exchange website url
	Url *string `json:"url,omitempty"`

	// YearEstablished exchange established year
	YearEstablished *float32 `json:"year_established,omitempty"`
}

// ExchangesList defines model for ExchangesList.
type ExchangesList struct {
	// Id exchange ID
	Id *string `json:"id,omitempty"`

	// Name exchange name
	Name *string `json:"name,omitempty"`
}

// Global defines model for Global.
type Global struct {
	Data *struct {
		// ActiveCryptocurrencies number of active cryptocurrencies
		ActiveCryptocurrencies *float32 `json:"active_cryptocurrencies,omitempty"`

		// EndedIcos number of ended icos
		EndedIcos *float32 `json:"ended_icos,omitempty"`

		// MarketCapChangePercentage24hUsd cryptocurrencies market cap change percentage in 24 hours in usd
		MarketCapChangePercentage24hUsd *float32 `json:"market_cap_change_percentage_24h_usd,omitempty"`

		// MarketCapPercentage cryptocurrencies market cap percentage
		MarketCapPercentage *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
		} `json:"market_cap_percentage,omitempty"`

		// Markets number of exchanges
		Markets *float32 `json:"markets,omitempty"`

		// OngoingIcos number of ongoing icos
		OngoingIcos *float32 `json:"ongoing_icos,omitempty"`

		// TotalMarketCap cryptocurrencies total market cap
		TotalMarketCap *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
		} `json:"total_market_cap,omitempty"`

		// TotalVolume cryptocurrencies total volume
		TotalVolume *struct {
			Btc *float32 `json:"btc,omitempty"`
			Eth *float32 `json:"eth,omitempty"`
		} `json:"total_volume,omitempty"`

		// UpcomingIcos number of upcoming icos
		UpcomingIcos *float32 `json:"upcoming_icos,omitempty"`
		UpdatedAt    *float32 `json:"updated_at,omitempty"`
	} `json:"data,omitempty"`
}

// GlobalDeFi defines model for GlobalDeFi.
type GlobalDeFi struct {
	Data *struct {
		// DefiDominance defi dominance
		DefiDominance *string `json:"defi_dominance,omitempty"`

		// DefiMarketCap defi market cap
		DefiMarketCap *string `json:"defi_market_cap,omitempty"`

		// DefiToEthRatio defi to eth ratio
		DefiToEthRatio *string `json:"defi_to_eth_ratio,omitempty"`

		// EthMarketCap eth market cap
		EthMarketCap *string `json:"eth_market_cap,omitempty"`

		// TopCoinDefiDominance defi top coin dominance
		TopCoinDefiDominance *float32 `json:"top_coin_defi_dominance,omitempty"`

		// TopCoinName defi top coin name
		TopCoinName *string `json:"top_coin_name,omitempty"`

		// TradingVolume24h defi trading volume in 24 hours
		TradingVolume24h *string `json:"trading_volume_24h,omitempty"`
	} `json:"data,omitempty"`
}

// NFTData defines model for NFTData.
type NFTData struct {
	// AssetPlatformId NFT collection asset platform ID
	AssetPlatformId *string `json:"asset_platform_id,omitempty"`

	// Ath NFT collection all time highs
	Ath *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"ath,omitempty"`

	// AthChangePercentage NFT collection all time highs change percentage
	AthChangePercentage *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"ath_change_percentage,omitempty"`

	// AthDate NFT collection all time highs date
	AthDate *struct {
		NativeCurrency *time.Time `json:"native_currency,omitempty"`
		Usd            *time.Time `json:"usd,omitempty"`
	} `json:"ath_date,omitempty"`

	// BannerImage NFT collection banner image url
	BannerImage *struct {
		Small *string `json:"small,omitempty"`
	} `json:"banner_image,omitempty"`

	// ContractAddress NFT collection contract address
	ContractAddress *string `json:"contract_address,omitempty"`

	// Description NFT collection description
	Description *string `json:"description,omitempty"`

	// Explorers NFT collection block explorers links
	Explorers *[]struct {
		Link *string `json:"link,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"explorers,omitempty"`

	// FloorPrice NFT collection floor price
	FloorPrice *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price,omitempty"`

	// FloorPrice14dPercentageChange NFT collection floor price 14 days percentage change
	FloorPrice14dPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price_14d_percentage_change,omitempty"`

	// FloorPrice1yPercentageChange NFT collection floor price 1 year percentage change
	FloorPrice1yPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price_1y_percentage_change,omitempty"`
	FloorPrice24hPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price_24h_percentage_change,omitempty"`

	// FloorPrice30dPercentageChange NFT collection floor price 30 days percentage change
	FloorPrice30dPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price_30d_percentage_change,omitempty"`

	// FloorPrice60dPercentageChange NFT collection floor price 60 days percentage change
	FloorPrice60dPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price_60d_percentage_change,omitempty"`

	// FloorPrice7dPercentageChange NFT collection floor price 7 days percentage change
	FloorPrice7dPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"floor_price_7d_percentage_change,omitempty"`

	// FloorPriceInUsd24hPercentageChange NFT collection floor price in usd 24 hours percentage change
	FloorPriceInUsd24hPercentageChange *float32 `json:"floor_price_in_usd_24h_percentage_change,omitempty"`

	// Id NFT collection ID
	Id *string `json:"id,omitempty"`

	// Image NFT collection image url
	Image *struct {
		Small   *string `json:"small,omitempty"`
		Small2x *string `json:"small_2x,omitempty"`
	} `json:"image,omitempty"`

	// Links NFT collection links
	Links *struct {
		Discord  *string `json:"discord,omitempty"`
		Homepage *string `json:"homepage,omitempty"`
		Twitter  *string `json:"twitter,omitempty"`
	} `json:"links,omitempty"`

	// MarketCap NFT collection market cap
	MarketCap *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"market_cap,omitempty"`

	// MarketCap24hPercentageChange NFT collection market cap 24 hours percentage change
	MarketCap24hPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"market_cap_24h_percentage_change,omitempty"`

	// MarketCapRank coin market cap rank
	MarketCapRank *float32 `json:"market_cap_rank,omitempty"`

	// Name NFT collection name
	Name *string `json:"name,omitempty"`

	// NativeCurrency NFT collection native currency
	NativeCurrency *string `json:"native_currency,omitempty"`

	// NativeCurrencySymbol NFT collection native currency symbol
	NativeCurrencySymbol *string `json:"native_currency_symbol,omitempty"`

	// NumberOfUniqueAddresses number of unique address owning the NFTs
	NumberOfUniqueAddresses *float32 `json:"number_of_unique_addresses,omitempty"`

	// NumberOfUniqueAddresses24hPercentageChange number of unique address owning the NFTs 24 hours percentage change
	NumberOfUniqueAddresses24hPercentageChange *float32 `json:"number_of_unique_addresses_24h_percentage_change,omitempty"`

	// OneDayAverageSalePrice NFT collection one day average sale price
	OneDayAverageSalePrice *float32 `json:"one_day_average_sale_price,omitempty"`

	// OneDayAverageSalePrice24hPercentageChange NFT collection one day average sale price 24 hours percentage change
	OneDayAverageSalePrice24hPercentageChange *float32 `json:"one_day_average_sale_price_24h_percentage_change,omitempty"`

	// OneDaySales NFT collection one day sales
	OneDaySales *float32 `json:"one_day_sales,omitempty"`

	// OneDaySales24hPercentageChange NFT collection one day sales 24 hours percentage change
	OneDaySales24hPercentageChange *float32 `json:"one_day_sales_24h_percentage_change,omitempty"`

	// Symbol NFT collection symbol
	Symbol *string `json:"symbol,omitempty"`

	// TotalSupply NFT collection total supply
	TotalSupply *float32 `json:"total_supply,omitempty"`

	// UserFavoritesCount NFT collection user favorites count
	UserFavoritesCount *float32 `json:"user_favorites_count,omitempty"`

	// Volume24h NFT collection volume in 24 hours
	Volume24h *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"volume_24h,omitempty"`

	// Volume24hPercentageChange NFT collection volume in 24 hours percentage change
	Volume24hPercentageChange *struct {
		NativeCurrency *float32 `json:"native_currency,omitempty"`
		Usd            *float32 `json:"usd,omitempty"`
	} `json:"volume_24h_percentage_change,omitempty"`

	// VolumeInUsd24hPercentageChange NFT collection volume in usd 24 hours percentage change
	VolumeInUsd24hPercentageChange *float32 `json:"volume_in_usd_24h_percentage_change,omitempty"`
}

// NFTList defines model for NFTList.
type NFTList struct {
	// AssetPlatformId NFT collection asset platform ID
	AssetPlatformId *string `json:"asset_platform_id,omitempty"`

	// ContractAddress NFT collection contract address
	ContractAddress *string `json:"contract_address,omitempty"`

	// Id NFT collection ID
	Id *string `json:"id,omitempty"`

	// Name NFT collection name
	Name *string `json:"name,omitempty"`

	// Symbol NFT collection symbol
	Symbol *string `json:"symbol,omitempty"`
}

// Ping defines model for Ping.
type Ping struct {
	GeckoSays *string `json:"gecko_says,omitempty"`
}

// Search defines model for Search.
type Search struct {
	Categories *[]struct {
		// Id category ID
		Id *string `json:"id,omitempty"`

		// Name category name
		Name *string `json:"name,omitempty"`
	} `json:"categories,omitempty"`
	Coins *[]struct {
		// ApiSymbol coin api symbol
		ApiSymbol *string `json:"api_symbol,omitempty"`

		// Id coin ID
		Id *string `json:"id,omitempty"`

		// Large coin large image url
		Large *string `json:"large,omitempty"`

		// MarketCapRank coin market cap rank
		MarketCapRank *float32 `json:"market_cap_rank,omitempty"`

		// Name coin name
		Name *string `json:"name,omitempty"`

		// Symbol coin symbol
		Symbol *string `json:"symbol,omitempty"`

		// Thumb coin thumb image url
		Thumb *string `json:"thumb,omitempty"`
	} `json:"coins,omitempty"`
	Exchanges *[]struct {
		// Id exchange ID
		Id *string `json:"id,omitempty"`

		// Large exchange large image url
		Large *string `json:"large,omitempty"`

		// MarketType exchange market type
		MarketType *string `json:"market_type,omitempty"`

		// Name exchange name
		Name *string `json:"name,omitempty"`

		// Thumb exchange thumb image url
		Thumb *string `json:"thumb,omitempty"`
	} `json:"exchanges,omitempty"`
	Icos *[]string `json:"icos,omitempty"`
	Nfts *[]struct {
		// Id NFT collection ID
		Id *string `json:"id,omitempty"`

		// Name NFT name
		Name *string `json:"name,omitempty"`

		// Symbol NFT collection symbol
		Symbol *string `json:"symbol,omitempty"`

		// Thumb NFT collection thumb image url
		Thumb *string `json:"thumb,omitempty"`
	} `json:"nfts,omitempty"`
}

// SimplePrice defines model for SimplePrice.
type SimplePrice map[string]struct {
	// LastUpdatedAt last updated timestamp
	LastUpdatedAt *float32 `json:"last_updated_at,omitempty"`

	// Usd price in USD
	Usd *float32 `json:"usd,omitempty"`

	// Usd24hChange 24hr change in USD
	Usd24hChange *float32 `json:"usd_24h_change,omitempty"`

	// Usd24hVol 24hr volume in USD
	Usd24hVol *float32 `json:"usd_24h_vol,omitempty"`

	// UsdMarketCap market cap in USD
	UsdMarketCap *float32 `json:"usd_market_cap,omitempty"`
}

// SimpleTokenPrice defines model for SimpleTokenPrice.
type SimpleTokenPrice struct {
	// LastUpdatedAt last updated timestamp
	LastUpdatedAt *float32 `json:"last_updated_at,omitempty"`

	// Usd price in USD
	Usd *float32 `json:"usd,omitempty"`

	// Usd24hChange 24hr change in USD
	Usd24hChange *float32 `json:"usd_24h_change,omitempty"`

	// Usd24hVol 24hr volume in USD
	Usd24hVol *float32 `json:"usd_24h_vol,omitempty"`

	// UsdMarketCap market cap in USD
	UsdMarketCap *float32 `json:"usd_market_cap,omitempty"`
}

// TrendingSearch defines model for TrendingSearch.
type TrendingSearch struct {
	Categories *[]struct {
		// CoinsCount category number of coins
		CoinsCount *float32 `json:"coins_count,omitempty"`
		Data       *struct {
			// MarketCap category market cap
			MarketCap *float32 `json:"market_cap,omitempty"`

			// MarketCapBtc category market cap in btc
			MarketCapBtc *float32 `json:"market_cap_btc,omitempty"`

			// MarketCapChangePercentage24h category market cap change percentage in 24 hours
			MarketCapChangePercentage24h *struct {
				Btc *float32 `json:"btc,omitempty"`
				Usd *float32 `json:"usd,omitempty"`
			} `json:"market_cap_change_percentage_24h,omitempty"`

			// Sparkline category sparkline image url
			Sparkline *string `json:"sparkline,omitempty"`

			// TotalVolume category total volume
			TotalVolume *float32 `json:"total_volume,omitempty"`

			// TotalVolumeBtc category total volume in btc
			TotalVolumeBtc *float32 `json:"total_volume_btc,omitempty"`
		} `json:"data,omitempty"`
		Id *float32 `json:"id,omitempty"`

		// MarketCap1hChange category market cap 1 hour change
		MarketCap1hChange *float32 `json:"market_cap_1h_change,omitempty"`

		// Name category name
		Name *string `json:"name,omitempty"`

		// Slug category web slug
		Slug *string `json:"slug,omitempty"`
	} `json:"categories,omitempty"`
	Coins *[]struct {
		CoinId *float32 `json:"coin_id,omitempty"`
		Data   *struct {
			Content *string `json:"content,omitempty"`

			// MarketCap coin market cap in usd
			MarketCap *string `json:"market_cap,omitempty"`

			// MarketCapBtc coin market cap in btc
			MarketCapBtc *string `json:"market_cap_btc,omitempty"`

			// Price coin price in usd
			Price *float32 `json:"price,omitempty"`

			// PriceBtc coin price in btc
			PriceBtc *string `json:"price_btc,omitempty"`

			// PriceChangePercentage24h coin price change percentage in 24 hours
			PriceChangePercentage24h *struct {
				Btc *float32 `json:"btc,omitempty"`
				Usd *float32 `json:"usd,omitempty"`
			} `json:"price_change_percentage_24h,omitempty"`

			// Sparkline coin sparkline image url
			Sparkline *string `json:"sparkline,omitempty"`

			// TotalVolume coin total volume in usd
			TotalVolume *string `json:"total_volume,omitempty"`

			// TotalVolumeBtc coin total volume in btc
			TotalVolumeBtc *string `json:"total_volume_btc,omitempty"`
		} `json:"data,omitempty"`

		// Id coin ID
		Id *string `json:"id,omitempty"`

		// Large coin large image url
		Large *string `json:"large,omitempty"`

		// MarketCapRank coin market cap rank
		MarketCapRank *float32 `json:"market_cap_rank,omitempty"`

		// Name coin name
		Name *string `json:"name,omitempty"`

		// PriceBtc coin price in btc
		PriceBtc *float32 `json:"price_btc,omitempty"`

		// Score coin sequence in the list
		Score *float32 `json:"score,omitempty"`

		// Slug coin web slug
		Slug *string `json:"slug,omitempty"`

		// Small coin small image url
		Small *string `json:"small,omitempty"`

		// Symbol coin symbol
		Symbol *string `json:"symbol,omitempty"`

		// Thumb coin thumb image url
		Thumb *string `json:"thumb,omitempty"`
	} `json:"coins,omitempty"`
	Nfts *[]struct {
		Data *struct {
			Content *string `json:"content,omitempty"`

			// FloorPrice NFT collection floor price
			FloorPrice *string `json:"floor_price,omitempty"`

			// FloorPriceInUsd24hPercentageChange NFT collection floor price in usd 24 hours percentage change
			FloorPriceInUsd24hPercentageChange *string `json:"floor_price_in_usd_24h_percentage_change,omitempty"`

			// H24AverageSalePrice NFT collection 24 hours average sale price
			H24AverageSalePrice *string `json:"h24_average_sale_price,omitempty"`

			// H24Volume NFT collection volume in 24 hours
			H24Volume *string `json:"h24_volume,omitempty"`

			// Sparkline NFT collection sparkline image url
			Sparkline *string `json:"sparkline,omitempty"`
		} `json:"data,omitempty"`

		// FloorPrice24hPercentageChange NFT collection floor price 24 hours percentage change
		FloorPrice24hPercentageChange *float32 `json:"floor_price_24h_percentage_change,omitempty"`

		// FloorPriceInNativeCurrency NFT collection floor price in native currency
		FloorPriceInNativeCurrency *float32 `json:"floor_price_in_native_currency,omitempty"`

		// Id NFT collection ID
		Id *string `json:"id,omitempty"`

		// Name NFT collection name
		Name *string `json:"name,omitempty"`

		// NativeCurrencySymbol NFT collection native currency symbol
		NativeCurrencySymbol *string  `json:"native_currency_symbol,omitempty"`
		NftContractId        *float32 `json:"nft_contract_id,omitempty"`

		// Symbol NFT collection symbol
		Symbol *string `json:"symbol,omitempty"`

		// Thumb NFT collection thumb image url
		Thumb *string `json:"thumb,omitempty"`
	} `json:"nfts,omitempty"`
}

// AssetPlatformsListParams defines parameters for AssetPlatformsList.
type AssetPlatformsListParams struct {
	// Filter apply relevant filters to results
	Filter *AssetPlatformsListParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// AssetPlatformsListParamsFilter defines parameters for AssetPlatformsList.
type AssetPlatformsListParamsFilter string

// CoinsCategoriesParams defines parameters for CoinsCategories.
type CoinsCategoriesParams struct {
	// Order sort results by field, default: market_cap_desc
	Order *CoinsCategoriesParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// CoinsCategoriesParamsOrder defines parameters for CoinsCategories.
type CoinsCategoriesParamsOrder string

// CoinsListParams defines parameters for CoinsList.
type CoinsListParams struct {
	// IncludePlatform include platform and token's contract addresses, default: false
	IncludePlatform *bool `form:"include_platform,omitempty" json:"include_platform,omitempty"`
}

// CoinsMarketsParams defines parameters for CoinsMarkets.
type CoinsMarketsParams struct {
	// VsCurrency target currency of coins and market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// Ids coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Names coins' names, comma-separated if querying more than 1 coin.
	Names *string `form:"names,omitempty" json:"names,omitempty"`

	// Symbols coins' symbols, comma-separated if querying more than 1 coin.
	Symbols *string `form:"symbols,omitempty" json:"symbols,omitempty"`

	// IncludeTokens for `symbols` lookups, specify `all` to include all matching tokens <br> Default `top` returns top-ranked tokens (by market cap or volume)
	IncludeTokens *CoinsMarketsParamsIncludeTokens `form:"include_tokens,omitempty" json:"include_tokens,omitempty"`

	// Category filter based on coins' category <br> *refers to [`/coins/categories/list`](/reference/coins-categories-list).
	Category *string `form:"category,omitempty" json:"category,omitempty"`

	// Order sort result by field, default: market_cap_desc
	Order *CoinsMarketsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// PerPage total results per page, default: 100 <br> Valid values: 1...250
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page page through results, default: 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Sparkline include sparkline 7 days data, default: false
	Sparkline *bool `form:"sparkline,omitempty" json:"sparkline,omitempty"`

	// PriceChangePercentage include price change percentage timeframe, comma-separated if query more than 1 price change percentage timeframe <br> Valid values: 1h, 24h, 7d, 14d, 30d, 200d, 1y
	PriceChangePercentage *string `form:"price_change_percentage,omitempty" json:"price_change_percentage,omitempty"`

	// Locale language background, default: en
	Locale *CoinsMarketsParamsLocale `form:"locale,omitempty" json:"locale,omitempty"`

	// Precision decimal place for currency price value
	Precision *CoinsMarketsParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// CoinsMarketsParamsIncludeTokens defines parameters for CoinsMarkets.
type CoinsMarketsParamsIncludeTokens string

// CoinsMarketsParamsOrder defines parameters for CoinsMarkets.
type CoinsMarketsParamsOrder string

// CoinsMarketsParamsLocale defines parameters for CoinsMarkets.
type CoinsMarketsParamsLocale string

// CoinsMarketsParamsPrecision defines parameters for CoinsMarkets.
type CoinsMarketsParamsPrecision string

// CoinsIdParams defines parameters for CoinsId.
type CoinsIdParams struct {
	// Localization include all the localized languages in the response, default: true
	Localization *bool `form:"localization,omitempty" json:"localization,omitempty"`

	// Tickers include tickers data, default: true
	Tickers *bool `form:"tickers,omitempty" json:"tickers,omitempty"`

	// MarketData include market data, default: true
	MarketData *bool `form:"market_data,omitempty" json:"market_data,omitempty"`

	// CommunityData include community data, default: true
	CommunityData *bool `form:"community_data,omitempty" json:"community_data,omitempty"`

	// DeveloperData include developer data, default: true
	DeveloperData *bool `form:"developer_data,omitempty" json:"developer_data,omitempty"`

	// Sparkline include sparkline 7 days data, default: false
	Sparkline *bool `form:"sparkline,omitempty" json:"sparkline,omitempty"`

	// DexPairFormat set to `symbol` to display DEX pair base and target as symbols, default: `contract_address`
	DexPairFormat *CoinsIdParamsDexPairFormat `form:"dex_pair_format,omitempty" json:"dex_pair_format,omitempty"`
}

// CoinsIdParamsDexPairFormat defines parameters for CoinsId.
type CoinsIdParamsDexPairFormat string

// ContractAddressMarketChartParams defines parameters for ContractAddressMarketChart.
type ContractAddressMarketChartParams struct {
	// VsCurrency target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// Days data up to number of days ago <br> You may use any integer for number of days
	Days string `form:"days" json:"days"`

	// Interval data interval, leave empty for auto granularity Possible value: daily
	Interval *ContractAddressMarketChartParamsInterval `form:"interval,omitempty" json:"interval,omitempty"`

	// Precision decimal place for currency price value
	Precision *ContractAddressMarketChartParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// ContractAddressMarketChartParamsInterval defines parameters for ContractAddressMarketChart.
type ContractAddressMarketChartParamsInterval string

// ContractAddressMarketChartParamsPrecision defines parameters for ContractAddressMarketChart.
type ContractAddressMarketChartParamsPrecision string

// ContractAddressMarketChartRangeParams defines parameters for ContractAddressMarketChartRange.
type ContractAddressMarketChartRangeParams struct {
	// VsCurrency target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// From starting date in UNIX timestamp
	From int `form:"from" json:"from"`

	// To ending date in UNIX timestamp
	To int `form:"to" json:"to"`

	// Precision decimal place for currency price value
	Precision *ContractAddressMarketChartRangeParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// ContractAddressMarketChartRangeParamsPrecision defines parameters for ContractAddressMarketChartRange.
type ContractAddressMarketChartRangeParamsPrecision string

// CoinsIdHistoryParams defines parameters for CoinsIdHistory.
type CoinsIdHistoryParams struct {
	// Date the date of data snapshot <br> Format: `dd-mm-yyyy`
	Date string `form:"date" json:"date"`

	// Localization include all the localized languages in response, default: true
	Localization *bool `form:"localization,omitempty" json:"localization,omitempty"`
}

// CoinsIdMarketChartParams defines parameters for CoinsIdMarketChart.
type CoinsIdMarketChartParams struct {
	// VsCurrency target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// Days data up to number of days ago <br> You may use any integer for number of days
	Days string `form:"days" json:"days"`

	// Interval data interval, leave empty for auto granularity Possible value: daily
	Interval *CoinsIdMarketChartParamsInterval `form:"interval,omitempty" json:"interval,omitempty"`

	// Precision decimal place for currency price value
	Precision *CoinsIdMarketChartParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// CoinsIdMarketChartParamsInterval defines parameters for CoinsIdMarketChart.
type CoinsIdMarketChartParamsInterval string

// CoinsIdMarketChartParamsPrecision defines parameters for CoinsIdMarketChart.
type CoinsIdMarketChartParamsPrecision string

// CoinsIdMarketChartRangeParams defines parameters for CoinsIdMarketChartRange.
type CoinsIdMarketChartRangeParams struct {
	// VsCurrency target currency of market data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// From starting date in UNIX timestamp
	From int `form:"from" json:"from"`

	// To ending date in UNIX timestamp
	To int `form:"to" json:"to"`

	// Precision decimal place for currency price value
	Precision *CoinsIdMarketChartRangeParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// CoinsIdMarketChartRangeParamsPrecision defines parameters for CoinsIdMarketChartRange.
type CoinsIdMarketChartRangeParamsPrecision string

// CoinsIdOhlcParams defines parameters for CoinsIdOhlc.
type CoinsIdOhlcParams struct {
	// VsCurrency target currency of price data <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrency string `form:"vs_currency" json:"vs_currency"`

	// Days data up to number of days ago
	Days CoinsIdOhlcParamsDays `form:"days" json:"days"`

	// Precision decimal place for currency price value
	Precision *CoinsIdOhlcParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// CoinsIdOhlcParamsDays defines parameters for CoinsIdOhlc.
type CoinsIdOhlcParamsDays string

// CoinsIdOhlcParamsPrecision defines parameters for CoinsIdOhlc.
type CoinsIdOhlcParamsPrecision string

// CoinsIdTickersParams defines parameters for CoinsIdTickers.
type CoinsIdTickersParams struct {
	// ExchangeIds exchange ID <br> *refers to [`/exchanges/list`](/reference/exchanges-list).
	ExchangeIds *string `form:"exchange_ids,omitempty" json:"exchange_ids,omitempty"`

	// IncludeExchangeLogo include exchange logo, default: false
	IncludeExchangeLogo *bool `form:"include_exchange_logo,omitempty" json:"include_exchange_logo,omitempty"`

	// Page page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Order use this to sort the order of responses, default: trust_score_desc
	Order *CoinsIdTickersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Depth include 2% orderbook depth, ie. `cost_to_move_up_usd` and `cost_to_move_down_usd` <br> Default: false
	Depth *bool `form:"depth,omitempty" json:"depth,omitempty"`

	// DexPairFormat set to `symbol` to display DEX pair base and target as symbols, default: `contract_address`
	DexPairFormat *CoinsIdTickersParamsDexPairFormat `form:"dex_pair_format,omitempty" json:"dex_pair_format,omitempty"`
}

// CoinsIdTickersParamsOrder defines parameters for CoinsIdTickers.
type CoinsIdTickersParamsOrder string

// CoinsIdTickersParamsDexPairFormat defines parameters for CoinsIdTickers.
type CoinsIdTickersParamsDexPairFormat string

// CompaniesPublicTreasuryParamsCoinId defines parameters for CompaniesPublicTreasury.
type CompaniesPublicTreasuryParamsCoinId string

// DerivativesExchangesParams defines parameters for DerivativesExchanges.
type DerivativesExchangesParams struct {
	// Order use this to sort the order of responses, default: open_interest_btc_desc
	Order *DerivativesExchangesParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// PerPage total results per page
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page page through results, default: 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// DerivativesExchangesParamsOrder defines parameters for DerivativesExchanges.
type DerivativesExchangesParamsOrder string

// DerivativesExchangesIdParams defines parameters for DerivativesExchangesId.
type DerivativesExchangesIdParams struct {
	// IncludeTickers include tickers data
	IncludeTickers *DerivativesExchangesIdParamsIncludeTickers `form:"include_tickers,omitempty" json:"include_tickers,omitempty"`
}

// DerivativesExchangesIdParamsIncludeTickers defines parameters for DerivativesExchangesId.
type DerivativesExchangesIdParamsIncludeTickers string

// ExchangesParams defines parameters for Exchanges.
type ExchangesParams struct {
	// PerPage total results per page, default: 100 <br> Valid values: 1...250
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page page through results, default: 1
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// ExchangesListParams defines parameters for ExchangesList.
type ExchangesListParams struct {
	// Status filter by status of exchanges, default: active
	Status *ExchangesListParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// ExchangesListParamsStatus defines parameters for ExchangesList.
type ExchangesListParamsStatus string

// ExchangesIdParams defines parameters for ExchangesId.
type ExchangesIdParams struct {
	// DexPairFormat set to `symbol` to display DEX pair base and target as symbols, default: `contract_address`
	DexPairFormat *ExchangesIdParamsDexPairFormat `form:"dex_pair_format,omitempty" json:"dex_pair_format,omitempty"`
}

// ExchangesIdParamsDexPairFormat defines parameters for ExchangesId.
type ExchangesIdParamsDexPairFormat string

// ExchangesIdTickersParams defines parameters for ExchangesIdTickers.
type ExchangesIdTickersParams struct {
	// CoinIds filter tickers by coin IDs, comma-separated if querying more than 1 coin <br> *refers to [`/coins/list`](/reference/coins-list).
	CoinIds *string `form:"coin_ids,omitempty" json:"coin_ids,omitempty"`

	// IncludeExchangeLogo include exchange logo, default: false
	IncludeExchangeLogo *bool `form:"include_exchange_logo,omitempty" json:"include_exchange_logo,omitempty"`

	// Page page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Depth include 2% orderbook depth (Example: cost_to_move_up_usd & cost_to_move_down_usd),default: false
	Depth *bool `form:"depth,omitempty" json:"depth,omitempty"`

	// Order use this to sort the order of responses, default: trust_score_desc
	Order *ExchangesIdTickersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// DexPairFormat set to `symbol` to display DEX pair base and target as symbols, default: `contract_address`
	DexPairFormat *ExchangesIdTickersParamsDexPairFormat `form:"dex_pair_format,omitempty" json:"dex_pair_format,omitempty"`
}

// ExchangesIdTickersParamsOrder defines parameters for ExchangesIdTickers.
type ExchangesIdTickersParamsOrder string

// ExchangesIdTickersParamsDexPairFormat defines parameters for ExchangesIdTickers.
type ExchangesIdTickersParamsDexPairFormat string

// ExchangesIdVolumeChartParams defines parameters for ExchangesIdVolumeChart.
type ExchangesIdVolumeChartParams struct {
	// Days data up to number of days ago
	Days ExchangesIdVolumeChartParamsDays `form:"days" json:"days"`
}

// ExchangesIdVolumeChartParamsDays defines parameters for ExchangesIdVolumeChart.
type ExchangesIdVolumeChartParamsDays string

// NftsListParams defines parameters for NftsList.
type NftsListParams struct {
	// Order use this to sort the order of responses
	Order *NftsListParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// PerPage total results per page <br> Valid values: 1...250
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Page page through results
	Page *int `form:"page,omitempty" json:"page,omitempty"`
}

// NftsListParamsOrder defines parameters for NftsList.
type NftsListParamsOrder string

// SearchDataParams defines parameters for SearchData.
type SearchDataParams struct {
	// Query search query
	Query string `form:"query" json:"query"`
}

// SimplePriceParams defines parameters for SimplePrice.
type SimplePriceParams struct {
	// VsCurrencies target currency of coins, comma-separated if querying more than 1 currency. <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrencies string `form:"vs_currencies" json:"vs_currencies"`

	// Ids coins' IDs, comma-separated if querying more than 1 coin. <br> *refers to [`/coins/list`](/reference/coins-list).
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Names coins' names, comma-separated if querying more than 1 coin.
	Names *string `form:"names,omitempty" json:"names,omitempty"`

	// Symbols coins' symbols, comma-separated if querying more than 1 coin.
	Symbols *string `form:"symbols,omitempty" json:"symbols,omitempty"`

	// IncludeTokens for `symbols` lookups, specify `all` to include all matching tokens <br> Default `top` returns top-ranked tokens (by market cap or volume)
	IncludeTokens *SimplePriceParamsIncludeTokens `form:"include_tokens,omitempty" json:"include_tokens,omitempty"`

	// IncludeMarketCap include market capitalization, default: false
	IncludeMarketCap *bool `form:"include_market_cap,omitempty" json:"include_market_cap,omitempty"`

	// Include24hrVol include 24hr volume, default: false
	Include24hrVol *bool `form:"include_24hr_vol,omitempty" json:"include_24hr_vol,omitempty"`

	// Include24hrChange include 24hr change, default: false
	Include24hrChange *bool `form:"include_24hr_change,omitempty" json:"include_24hr_change,omitempty"`

	// IncludeLastUpdatedAt include last updated price time in UNIX, default: false
	IncludeLastUpdatedAt *bool `form:"include_last_updated_at,omitempty" json:"include_last_updated_at,omitempty"`

	// Precision decimal place for currency price value
	Precision *SimplePriceParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// SimplePriceParamsIncludeTokens defines parameters for SimplePrice.
type SimplePriceParamsIncludeTokens string

// SimplePriceParamsPrecision defines parameters for SimplePrice.
type SimplePriceParamsPrecision string

// SimpleTokenPriceParams defines parameters for SimpleTokenPrice.
type SimpleTokenPriceParams struct {
	// ContractAddresses the contract address of a token
	ContractAddresses string `form:"contract_addresses" json:"contract_addresses"`

	// VsCurrencies target currency of coins, comma-separated if querying more than 1 currency. <br> *refers to [`/simple/supported_vs_currencies`](/reference/simple-supported-currencies).
	VsCurrencies string `form:"vs_currencies" json:"vs_currencies"`

	// IncludeMarketCap include market capitalization, default: false
	IncludeMarketCap *bool `form:"include_market_cap,omitempty" json:"include_market_cap,omitempty"`

	// Include24hrVol include 24hr volume, default: false
	Include24hrVol *bool `form:"include_24hr_vol,omitempty" json:"include_24hr_vol,omitempty"`

	// Include24hrChange include 24hr change <br> default: false
	Include24hrChange *bool `form:"include_24hr_change,omitempty" json:"include_24hr_change,omitempty"`

	// IncludeLastUpdatedAt include last updated price time in UNIX , default: false
	IncludeLastUpdatedAt *bool `form:"include_last_updated_at,omitempty" json:"include_last_updated_at,omitempty"`

	// Precision decimal place for currency price value
	Precision *SimpleTokenPriceParamsPrecision `form:"precision,omitempty" json:"precision,omitempty"`
}

// SimpleTokenPriceParamsPrecision defines parameters for SimpleTokenPrice.
type SimpleTokenPriceParamsPrecision string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AssetPlatformsList request
	AssetPlatformsList(ctx context.Context, params *AssetPlatformsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsCategories request
	CoinsCategories(ctx context.Context, params *CoinsCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsCategoriesList request
	CoinsCategoriesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsList request
	CoinsList(ctx context.Context, params *CoinsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsMarkets request
	CoinsMarkets(ctx context.Context, params *CoinsMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsId request
	CoinsId(ctx context.Context, id string, params *CoinsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsContractAddress request
	CoinsContractAddress(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContractAddressMarketChart request
	ContractAddressMarketChart(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ContractAddressMarketChartRange request
	ContractAddressMarketChartRange(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsIdHistory request
	CoinsIdHistory(ctx context.Context, id string, params *CoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsIdMarketChart request
	CoinsIdMarketChart(ctx context.Context, id string, params *CoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsIdMarketChartRange request
	CoinsIdMarketChartRange(ctx context.Context, id string, params *CoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsIdOhlc request
	CoinsIdOhlc(ctx context.Context, id string, params *CoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CoinsIdTickers request
	CoinsIdTickers(ctx context.Context, id string, params *CoinsIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompaniesPublicTreasury request
	CompaniesPublicTreasury(ctx context.Context, coinId CompaniesPublicTreasuryParamsCoinId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DerivativesTickers request
	DerivativesTickers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DerivativesExchanges request
	DerivativesExchanges(ctx context.Context, params *DerivativesExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DerivativesExchangesList request
	DerivativesExchangesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DerivativesExchangesId request
	DerivativesExchangesId(ctx context.Context, id string, params *DerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeRates request
	ExchangeRates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Exchanges request
	Exchanges(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangesList request
	ExchangesList(ctx context.Context, params *ExchangesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangesId request
	ExchangesId(ctx context.Context, id string, params *ExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangesIdTickers request
	ExchangesIdTickers(ctx context.Context, id string, params *ExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangesIdVolumeChart request
	ExchangesIdVolumeChart(ctx context.Context, id string, params *ExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CryptoGlobal request
	CryptoGlobal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GlobalDeFi request
	GlobalDeFi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NftsList request
	NftsList(ctx context.Context, params *NftsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NftsContractAddress request
	NftsContractAddress(ctx context.Context, assetPlatformId string, contractAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NftsId request
	NftsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PingServer request
	PingServer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchData request
	SearchData(ctx context.Context, params *SearchDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrendingSearch request
	TrendingSearch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimplePrice request
	SimplePrice(ctx context.Context, params *SimplePriceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimpleSupportedCurrencies request
	SimpleSupportedCurrencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SimpleTokenPrice request
	SimpleTokenPrice(ctx context.Context, id string, params *SimpleTokenPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AssetPlatformsList(ctx context.Context, params *AssetPlatformsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetPlatformsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsCategories(ctx context.Context, params *CoinsCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsCategoriesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsCategoriesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsList(ctx context.Context, params *CoinsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsMarkets(ctx context.Context, params *CoinsMarketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsMarketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsId(ctx context.Context, id string, params *CoinsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsContractAddress(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsContractAddressRequest(c.Server, id, contractAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContractAddressMarketChart(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContractAddressMarketChartRequest(c.Server, id, contractAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ContractAddressMarketChartRange(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewContractAddressMarketChartRangeRequest(c.Server, id, contractAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsIdHistory(ctx context.Context, id string, params *CoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsIdHistoryRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsIdMarketChart(ctx context.Context, id string, params *CoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsIdMarketChartRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsIdMarketChartRange(ctx context.Context, id string, params *CoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsIdMarketChartRangeRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsIdOhlc(ctx context.Context, id string, params *CoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsIdOhlcRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CoinsIdTickers(ctx context.Context, id string, params *CoinsIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCoinsIdTickersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompaniesPublicTreasury(ctx context.Context, coinId CompaniesPublicTreasuryParamsCoinId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompaniesPublicTreasuryRequest(c.Server, coinId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DerivativesTickers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDerivativesTickersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DerivativesExchanges(ctx context.Context, params *DerivativesExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDerivativesExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DerivativesExchangesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDerivativesExchangesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DerivativesExchangesId(ctx context.Context, id string, params *DerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDerivativesExchangesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeRates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeRatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Exchanges(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangesList(ctx context.Context, params *ExchangesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangesId(ctx context.Context, id string, params *ExchangesIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangesIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangesIdTickers(ctx context.Context, id string, params *ExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangesIdTickersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangesIdVolumeChart(ctx context.Context, id string, params *ExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangesIdVolumeChartRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CryptoGlobal(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCryptoGlobalRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GlobalDeFi(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlobalDeFiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NftsList(ctx context.Context, params *NftsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNftsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NftsContractAddress(ctx context.Context, assetPlatformId string, contractAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNftsContractAddressRequest(c.Server, assetPlatformId, contractAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NftsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNftsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PingServer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPingServerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchData(ctx context.Context, params *SearchDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrendingSearch(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrendingSearchRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimplePrice(ctx context.Context, params *SimplePriceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimplePriceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimpleSupportedCurrencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimpleSupportedCurrenciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SimpleTokenPrice(ctx context.Context, id string, params *SimpleTokenPriceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSimpleTokenPriceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAssetPlatformsListRequest generates requests for AssetPlatformsList
func NewAssetPlatformsListRequest(server string, params *AssetPlatformsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/asset_platforms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsCategoriesRequest generates requests for CoinsCategories
func NewCoinsCategoriesRequest(server string, params *CoinsCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsCategoriesListRequest generates requests for CoinsCategoriesList
func NewCoinsCategoriesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/categories/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsListRequest generates requests for CoinsList
func NewCoinsListRequest(server string, params *CoinsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludePlatform != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_platform", runtime.ParamLocationQuery, *params.IncludePlatform); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsMarketsRequest generates requests for CoinsMarkets
func NewCoinsMarketsRequest(server string, params *CoinsMarketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/markets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Symbols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, *params.Symbols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tokens", runtime.ParamLocationQuery, *params.IncludeTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sparkline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sparkline", runtime.ParamLocationQuery, *params.Sparkline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PriceChangePercentage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "price_change_percentage", runtime.ParamLocationQuery, *params.PriceChangePercentage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsIdRequest generates requests for CoinsId
func NewCoinsIdRequest(server string, id string, params *CoinsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Localization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "localization", runtime.ParamLocationQuery, *params.Localization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickers", runtime.ParamLocationQuery, *params.Tickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_data", runtime.ParamLocationQuery, *params.MarketData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CommunityData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "community_data", runtime.ParamLocationQuery, *params.CommunityData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeveloperData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "developer_data", runtime.ParamLocationQuery, *params.DeveloperData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sparkline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sparkline", runtime.ParamLocationQuery, *params.Sparkline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DexPairFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dex_pair_format", runtime.ParamLocationQuery, *params.DexPairFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsContractAddressRequest generates requests for CoinsContractAddress
func NewCoinsContractAddressRequest(server string, id string, contractAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/contract/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContractAddressMarketChartRequest generates requests for ContractAddressMarketChart
func NewContractAddressMarketChartRequest(server string, id string, contractAddress string, params *ContractAddressMarketChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/contract/%s/market_chart", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewContractAddressMarketChartRangeRequest generates requests for ContractAddressMarketChartRange
func NewContractAddressMarketChartRangeRequest(server string, id string, contractAddress string, params *ContractAddressMarketChartRangeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/contract/%s/market_chart/range", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsIdHistoryRequest generates requests for CoinsIdHistory
func NewCoinsIdHistoryRequest(server string, id string, params *CoinsIdHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Localization != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "localization", runtime.ParamLocationQuery, *params.Localization); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsIdMarketChartRequest generates requests for CoinsIdMarketChart
func NewCoinsIdMarketChartRequest(server string, id string, params *CoinsIdMarketChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/market_chart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsIdMarketChartRangeRequest generates requests for CoinsIdMarketChartRange
func NewCoinsIdMarketChartRangeRequest(server string, id string, params *CoinsIdMarketChartRangeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/market_chart/range", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsIdOhlcRequest generates requests for CoinsIdOhlc
func NewCoinsIdOhlcRequest(server string, id string, params *CoinsIdOhlcParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/ohlc", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currency", runtime.ParamLocationQuery, params.VsCurrency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCoinsIdTickersRequest generates requests for CoinsIdTickers
func NewCoinsIdTickersRequest(server string, id string, params *CoinsIdTickersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/coins/%s/tickers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExchangeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange_ids", runtime.ParamLocationQuery, *params.ExchangeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExchangeLogo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_exchange_logo", runtime.ParamLocationQuery, *params.IncludeExchangeLogo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DexPairFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dex_pair_format", runtime.ParamLocationQuery, *params.DexPairFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompaniesPublicTreasuryRequest generates requests for CompaniesPublicTreasury
func NewCompaniesPublicTreasuryRequest(server string, coinId CompaniesPublicTreasuryParamsCoinId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "coin_id", runtime.ParamLocationPath, coinId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/companies/public_treasury/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDerivativesTickersRequest generates requests for DerivativesTickers
func NewDerivativesTickersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDerivativesExchangesRequest generates requests for DerivativesExchanges
func NewDerivativesExchangesRequest(server string, params *DerivativesExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDerivativesExchangesListRequest generates requests for DerivativesExchangesList
func NewDerivativesExchangesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives/exchanges/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDerivativesExchangesIdRequest generates requests for DerivativesExchangesId
func NewDerivativesExchangesIdRequest(server string, id string, params *DerivativesExchangesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/derivatives/exchanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeTickers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tickers", runtime.ParamLocationQuery, *params.IncludeTickers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeRatesRequest generates requests for ExchangeRates
func NewExchangeRatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchange_rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangesRequest generates requests for Exchanges
func NewExchangesRequest(server string, params *ExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangesListRequest generates requests for ExchangesList
func NewExchangesListRequest(server string, params *ExchangesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangesIdRequest generates requests for ExchangesId
func NewExchangesIdRequest(server string, id string, params *ExchangesIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DexPairFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dex_pair_format", runtime.ParamLocationQuery, *params.DexPairFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangesIdTickersRequest generates requests for ExchangesIdTickers
func NewExchangesIdTickersRequest(server string, id string, params *ExchangesIdTickersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/tickers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CoinIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "coin_ids", runtime.ParamLocationQuery, *params.CoinIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExchangeLogo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_exchange_logo", runtime.ParamLocationQuery, *params.IncludeExchangeLogo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Depth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "depth", runtime.ParamLocationQuery, *params.Depth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DexPairFormat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dex_pair_format", runtime.ParamLocationQuery, *params.DexPairFormat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangesIdVolumeChartRequest generates requests for ExchangesIdVolumeChart
func NewExchangesIdVolumeChartRequest(server string, id string, params *ExchangesIdVolumeChartParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/volume_chart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCryptoGlobalRequest generates requests for CryptoGlobal
func NewCryptoGlobalRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlobalDeFiRequest generates requests for GlobalDeFi
func NewGlobalDeFiRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/global/decentralized_finance_defi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNftsListRequest generates requests for NftsList
func NewNftsListRequest(server string, params *NftsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nfts/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNftsContractAddressRequest generates requests for NftsContractAddress
func NewNftsContractAddressRequest(server string, assetPlatformId string, contractAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_platform_id", runtime.ParamLocationPath, assetPlatformId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "contract_address", runtime.ParamLocationPath, contractAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nfts/%s/contract/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNftsIdRequest generates requests for NftsId
func NewNftsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nfts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPingServerRequest generates requests for PingServer
func NewPingServerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDataRequest generates requests for SearchData
func NewSearchDataRequest(server string, params *SearchDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTrendingSearchRequest generates requests for TrendingSearch
func NewTrendingSearchRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/trending")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSimplePriceRequest generates requests for SimplePrice
func NewSimplePriceRequest(server string, params *SimplePriceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/simple/price")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currencies", runtime.ParamLocationQuery, params.VsCurrencies); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Symbols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, *params.Symbols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeTokens != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_tokens", runtime.ParamLocationQuery, *params.IncludeTokens); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeMarketCap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_market_cap", runtime.ParamLocationQuery, *params.IncludeMarketCap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include24hrVol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_vol", runtime.ParamLocationQuery, *params.Include24hrVol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include24hrChange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_change", runtime.ParamLocationQuery, *params.Include24hrChange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLastUpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_last_updated_at", runtime.ParamLocationQuery, *params.IncludeLastUpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSimpleSupportedCurrenciesRequest generates requests for SimpleSupportedCurrencies
func NewSimpleSupportedCurrenciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/simple/supported_vs_currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSimpleTokenPriceRequest generates requests for SimpleTokenPrice
func NewSimpleTokenPriceRequest(server string, id string, params *SimpleTokenPriceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/simple/token_price/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contract_addresses", runtime.ParamLocationQuery, params.ContractAddresses); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vs_currencies", runtime.ParamLocationQuery, params.VsCurrencies); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeMarketCap != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_market_cap", runtime.ParamLocationQuery, *params.IncludeMarketCap); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include24hrVol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_vol", runtime.ParamLocationQuery, *params.Include24hrVol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include24hrChange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_24hr_change", runtime.ParamLocationQuery, *params.Include24hrChange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeLastUpdatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_last_updated_at", runtime.ParamLocationQuery, *params.IncludeLastUpdatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Precision != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "precision", runtime.ParamLocationQuery, *params.Precision); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AssetPlatformsListWithResponse request
	AssetPlatformsListWithResponse(ctx context.Context, params *AssetPlatformsListParams, reqEditors ...RequestEditorFn) (*AssetPlatformsListResponse, error)

	// CoinsCategoriesWithResponse request
	CoinsCategoriesWithResponse(ctx context.Context, params *CoinsCategoriesParams, reqEditors ...RequestEditorFn) (*CoinsCategoriesResponse, error)

	// CoinsCategoriesListWithResponse request
	CoinsCategoriesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CoinsCategoriesListResponse, error)

	// CoinsListWithResponse request
	CoinsListWithResponse(ctx context.Context, params *CoinsListParams, reqEditors ...RequestEditorFn) (*CoinsListResponse, error)

	// CoinsMarketsWithResponse request
	CoinsMarketsWithResponse(ctx context.Context, params *CoinsMarketsParams, reqEditors ...RequestEditorFn) (*CoinsMarketsResponse, error)

	// CoinsIdWithResponse request
	CoinsIdWithResponse(ctx context.Context, id string, params *CoinsIdParams, reqEditors ...RequestEditorFn) (*CoinsIdResponse, error)

	// CoinsContractAddressWithResponse request
	CoinsContractAddressWithResponse(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*CoinsContractAddressResponse, error)

	// ContractAddressMarketChartWithResponse request
	ContractAddressMarketChartWithResponse(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*ContractAddressMarketChartResponse, error)

	// ContractAddressMarketChartRangeWithResponse request
	ContractAddressMarketChartRangeWithResponse(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*ContractAddressMarketChartRangeResponse, error)

	// CoinsIdHistoryWithResponse request
	CoinsIdHistoryWithResponse(ctx context.Context, id string, params *CoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*CoinsIdHistoryResponse, error)

	// CoinsIdMarketChartWithResponse request
	CoinsIdMarketChartWithResponse(ctx context.Context, id string, params *CoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*CoinsIdMarketChartResponse, error)

	// CoinsIdMarketChartRangeWithResponse request
	CoinsIdMarketChartRangeWithResponse(ctx context.Context, id string, params *CoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*CoinsIdMarketChartRangeResponse, error)

	// CoinsIdOhlcWithResponse request
	CoinsIdOhlcWithResponse(ctx context.Context, id string, params *CoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*CoinsIdOhlcResponse, error)

	// CoinsIdTickersWithResponse request
	CoinsIdTickersWithResponse(ctx context.Context, id string, params *CoinsIdTickersParams, reqEditors ...RequestEditorFn) (*CoinsIdTickersResponse, error)

	// CompaniesPublicTreasuryWithResponse request
	CompaniesPublicTreasuryWithResponse(ctx context.Context, coinId CompaniesPublicTreasuryParamsCoinId, reqEditors ...RequestEditorFn) (*CompaniesPublicTreasuryResponse, error)

	// DerivativesTickersWithResponse request
	DerivativesTickersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DerivativesTickersResponse, error)

	// DerivativesExchangesWithResponse request
	DerivativesExchangesWithResponse(ctx context.Context, params *DerivativesExchangesParams, reqEditors ...RequestEditorFn) (*DerivativesExchangesResponse, error)

	// DerivativesExchangesListWithResponse request
	DerivativesExchangesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DerivativesExchangesListResponse, error)

	// DerivativesExchangesIdWithResponse request
	DerivativesExchangesIdWithResponse(ctx context.Context, id string, params *DerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*DerivativesExchangesIdResponse, error)

	// ExchangeRatesWithResponse request
	ExchangeRatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExchangeRatesResponse, error)

	// ExchangesWithResponse request
	ExchangesWithResponse(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*ExchangesResponse, error)

	// ExchangesListWithResponse request
	ExchangesListWithResponse(ctx context.Context, params *ExchangesListParams, reqEditors ...RequestEditorFn) (*ExchangesListResponse, error)

	// ExchangesIdWithResponse request
	ExchangesIdWithResponse(ctx context.Context, id string, params *ExchangesIdParams, reqEditors ...RequestEditorFn) (*ExchangesIdResponse, error)

	// ExchangesIdTickersWithResponse request
	ExchangesIdTickersWithResponse(ctx context.Context, id string, params *ExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*ExchangesIdTickersResponse, error)

	// ExchangesIdVolumeChartWithResponse request
	ExchangesIdVolumeChartWithResponse(ctx context.Context, id string, params *ExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*ExchangesIdVolumeChartResponse, error)

	// CryptoGlobalWithResponse request
	CryptoGlobalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CryptoGlobalResponse, error)

	// GlobalDeFiWithResponse request
	GlobalDeFiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalDeFiResponse, error)

	// NftsListWithResponse request
	NftsListWithResponse(ctx context.Context, params *NftsListParams, reqEditors ...RequestEditorFn) (*NftsListResponse, error)

	// NftsContractAddressWithResponse request
	NftsContractAddressWithResponse(ctx context.Context, assetPlatformId string, contractAddress string, reqEditors ...RequestEditorFn) (*NftsContractAddressResponse, error)

	// NftsIdWithResponse request
	NftsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*NftsIdResponse, error)

	// PingServerWithResponse request
	PingServerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingServerResponse, error)

	// SearchDataWithResponse request
	SearchDataWithResponse(ctx context.Context, params *SearchDataParams, reqEditors ...RequestEditorFn) (*SearchDataResponse, error)

	// TrendingSearchWithResponse request
	TrendingSearchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrendingSearchResponse, error)

	// SimplePriceWithResponse request
	SimplePriceWithResponse(ctx context.Context, params *SimplePriceParams, reqEditors ...RequestEditorFn) (*SimplePriceResponse, error)

	// SimpleSupportedCurrenciesWithResponse request
	SimpleSupportedCurrenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SimpleSupportedCurrenciesResponse, error)

	// SimpleTokenPriceWithResponse request
	SimpleTokenPriceWithResponse(ctx context.Context, id string, params *SimpleTokenPriceParams, reqEditors ...RequestEditorFn) (*SimpleTokenPriceResponse, error)
}

type AssetPlatformsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssetPlatforms
}

// Status returns HTTPResponse.Status
func (r AssetPlatformsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetPlatformsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Categories
}

// Status returns HTTPResponse.Status
func (r CoinsCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsCategoriesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoriesList
}

// Status returns HTTPResponse.Status
func (r CoinsCategoriesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsCategoriesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsList
}

// Status returns HTTPResponse.Status
func (r CoinsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsMarketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsMarkets
}

// Status returns HTTPResponse.Status
func (r CoinsMarketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsMarketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsID
}

// Status returns HTTPResponse.Status
func (r CoinsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsContractAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsContractAddress
}

// Status returns HTTPResponse.Status
func (r CoinsContractAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsContractAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContractAddressMarketChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsMarketChart
}

// Status returns HTTPResponse.Status
func (r ContractAddressMarketChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContractAddressMarketChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ContractAddressMarketChartRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsMarketChartRange
}

// Status returns HTTPResponse.Status
func (r ContractAddressMarketChartRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ContractAddressMarketChartRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsIdHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsHistoricalData
}

// Status returns HTTPResponse.Status
func (r CoinsIdHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsIdHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsIdMarketChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsMarketChart
}

// Status returns HTTPResponse.Status
func (r CoinsIdMarketChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsIdMarketChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsIdMarketChartRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsMarketChartRange
}

// Status returns HTTPResponse.Status
func (r CoinsIdMarketChartRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsIdMarketChartRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsIdOhlcResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsOHLC
}

// Status returns HTTPResponse.Status
func (r CoinsIdOhlcResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsIdOhlcResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CoinsIdTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoinsTickers
}

// Status returns HTTPResponse.Status
func (r CoinsIdTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CoinsIdTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompaniesPublicTreasuryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CompaniesTreasury
}

// Status returns HTTPResponse.Status
func (r CompaniesPublicTreasuryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompaniesPublicTreasuryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DerivativesTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DerivativesTickersList
}

// Status returns HTTPResponse.Status
func (r DerivativesTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DerivativesTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DerivativesExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DerivativesExchanges
}

// Status returns HTTPResponse.Status
func (r DerivativesExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DerivativesExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DerivativesExchangesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DerivativesExchangesList
}

// Status returns HTTPResponse.Status
func (r DerivativesExchangesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DerivativesExchangesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DerivativesExchangesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DerivativesExchangesID
}

// Status returns HTTPResponse.Status
func (r DerivativesExchangesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DerivativesExchangesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeRates
}

// Status returns HTTPResponse.Status
func (r ExchangeRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Exchanges
}

// Status returns HTTPResponse.Status
func (r ExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangesList
}

// Status returns HTTPResponse.Status
func (r ExchangesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeData
}

// Status returns HTTPResponse.Status
func (r ExchangesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangesIdTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeTickers
}

// Status returns HTTPResponse.Status
func (r ExchangesIdTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangesIdTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangesIdVolumeChartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeVolumeChart
}

// Status returns HTTPResponse.Status
func (r ExchangesIdVolumeChartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangesIdVolumeChartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CryptoGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
}

// Status returns HTTPResponse.Status
func (r CryptoGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CryptoGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlobalDeFiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalDeFi
}

// Status returns HTTPResponse.Status
func (r GlobalDeFiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlobalDeFiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NftsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NFTList
}

// Status returns HTTPResponse.Status
func (r NftsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NftsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NftsContractAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NFTData
}

// Status returns HTTPResponse.Status
func (r NftsContractAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NftsContractAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NftsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NFTData
}

// Status returns HTTPResponse.Status
func (r NftsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NftsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PingServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ping
}

// Status returns HTTPResponse.Status
func (r PingServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PingServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Search
}

// Status returns HTTPResponse.Status
func (r SearchDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrendingSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrendingSearch
}

// Status returns HTTPResponse.Status
func (r TrendingSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrendingSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimplePriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimplePrice
}

// Status returns HTTPResponse.Status
func (r SimplePriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimplePriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimpleSupportedCurrenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrencyList
}

// Status returns HTTPResponse.Status
func (r SimpleSupportedCurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimpleSupportedCurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SimpleTokenPriceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SimpleTokenPrice
}

// Status returns HTTPResponse.Status
func (r SimpleTokenPriceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SimpleTokenPriceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AssetPlatformsListWithResponse request returning *AssetPlatformsListResponse
func (c *ClientWithResponses) AssetPlatformsListWithResponse(ctx context.Context, params *AssetPlatformsListParams, reqEditors ...RequestEditorFn) (*AssetPlatformsListResponse, error) {
	rsp, err := c.AssetPlatformsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetPlatformsListResponse(rsp)
}

// CoinsCategoriesWithResponse request returning *CoinsCategoriesResponse
func (c *ClientWithResponses) CoinsCategoriesWithResponse(ctx context.Context, params *CoinsCategoriesParams, reqEditors ...RequestEditorFn) (*CoinsCategoriesResponse, error) {
	rsp, err := c.CoinsCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsCategoriesResponse(rsp)
}

// CoinsCategoriesListWithResponse request returning *CoinsCategoriesListResponse
func (c *ClientWithResponses) CoinsCategoriesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CoinsCategoriesListResponse, error) {
	rsp, err := c.CoinsCategoriesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsCategoriesListResponse(rsp)
}

// CoinsListWithResponse request returning *CoinsListResponse
func (c *ClientWithResponses) CoinsListWithResponse(ctx context.Context, params *CoinsListParams, reqEditors ...RequestEditorFn) (*CoinsListResponse, error) {
	rsp, err := c.CoinsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsListResponse(rsp)
}

// CoinsMarketsWithResponse request returning *CoinsMarketsResponse
func (c *ClientWithResponses) CoinsMarketsWithResponse(ctx context.Context, params *CoinsMarketsParams, reqEditors ...RequestEditorFn) (*CoinsMarketsResponse, error) {
	rsp, err := c.CoinsMarkets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsMarketsResponse(rsp)
}

// CoinsIdWithResponse request returning *CoinsIdResponse
func (c *ClientWithResponses) CoinsIdWithResponse(ctx context.Context, id string, params *CoinsIdParams, reqEditors ...RequestEditorFn) (*CoinsIdResponse, error) {
	rsp, err := c.CoinsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsIdResponse(rsp)
}

// CoinsContractAddressWithResponse request returning *CoinsContractAddressResponse
func (c *ClientWithResponses) CoinsContractAddressWithResponse(ctx context.Context, id string, contractAddress string, reqEditors ...RequestEditorFn) (*CoinsContractAddressResponse, error) {
	rsp, err := c.CoinsContractAddress(ctx, id, contractAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsContractAddressResponse(rsp)
}

// ContractAddressMarketChartWithResponse request returning *ContractAddressMarketChartResponse
func (c *ClientWithResponses) ContractAddressMarketChartWithResponse(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartParams, reqEditors ...RequestEditorFn) (*ContractAddressMarketChartResponse, error) {
	rsp, err := c.ContractAddressMarketChart(ctx, id, contractAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContractAddressMarketChartResponse(rsp)
}

// ContractAddressMarketChartRangeWithResponse request returning *ContractAddressMarketChartRangeResponse
func (c *ClientWithResponses) ContractAddressMarketChartRangeWithResponse(ctx context.Context, id string, contractAddress string, params *ContractAddressMarketChartRangeParams, reqEditors ...RequestEditorFn) (*ContractAddressMarketChartRangeResponse, error) {
	rsp, err := c.ContractAddressMarketChartRange(ctx, id, contractAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseContractAddressMarketChartRangeResponse(rsp)
}

// CoinsIdHistoryWithResponse request returning *CoinsIdHistoryResponse
func (c *ClientWithResponses) CoinsIdHistoryWithResponse(ctx context.Context, id string, params *CoinsIdHistoryParams, reqEditors ...RequestEditorFn) (*CoinsIdHistoryResponse, error) {
	rsp, err := c.CoinsIdHistory(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsIdHistoryResponse(rsp)
}

// CoinsIdMarketChartWithResponse request returning *CoinsIdMarketChartResponse
func (c *ClientWithResponses) CoinsIdMarketChartWithResponse(ctx context.Context, id string, params *CoinsIdMarketChartParams, reqEditors ...RequestEditorFn) (*CoinsIdMarketChartResponse, error) {
	rsp, err := c.CoinsIdMarketChart(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsIdMarketChartResponse(rsp)
}

// CoinsIdMarketChartRangeWithResponse request returning *CoinsIdMarketChartRangeResponse
func (c *ClientWithResponses) CoinsIdMarketChartRangeWithResponse(ctx context.Context, id string, params *CoinsIdMarketChartRangeParams, reqEditors ...RequestEditorFn) (*CoinsIdMarketChartRangeResponse, error) {
	rsp, err := c.CoinsIdMarketChartRange(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsIdMarketChartRangeResponse(rsp)
}

// CoinsIdOhlcWithResponse request returning *CoinsIdOhlcResponse
func (c *ClientWithResponses) CoinsIdOhlcWithResponse(ctx context.Context, id string, params *CoinsIdOhlcParams, reqEditors ...RequestEditorFn) (*CoinsIdOhlcResponse, error) {
	rsp, err := c.CoinsIdOhlc(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsIdOhlcResponse(rsp)
}

// CoinsIdTickersWithResponse request returning *CoinsIdTickersResponse
func (c *ClientWithResponses) CoinsIdTickersWithResponse(ctx context.Context, id string, params *CoinsIdTickersParams, reqEditors ...RequestEditorFn) (*CoinsIdTickersResponse, error) {
	rsp, err := c.CoinsIdTickers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCoinsIdTickersResponse(rsp)
}

// CompaniesPublicTreasuryWithResponse request returning *CompaniesPublicTreasuryResponse
func (c *ClientWithResponses) CompaniesPublicTreasuryWithResponse(ctx context.Context, coinId CompaniesPublicTreasuryParamsCoinId, reqEditors ...RequestEditorFn) (*CompaniesPublicTreasuryResponse, error) {
	rsp, err := c.CompaniesPublicTreasury(ctx, coinId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompaniesPublicTreasuryResponse(rsp)
}

// DerivativesTickersWithResponse request returning *DerivativesTickersResponse
func (c *ClientWithResponses) DerivativesTickersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DerivativesTickersResponse, error) {
	rsp, err := c.DerivativesTickers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDerivativesTickersResponse(rsp)
}

// DerivativesExchangesWithResponse request returning *DerivativesExchangesResponse
func (c *ClientWithResponses) DerivativesExchangesWithResponse(ctx context.Context, params *DerivativesExchangesParams, reqEditors ...RequestEditorFn) (*DerivativesExchangesResponse, error) {
	rsp, err := c.DerivativesExchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDerivativesExchangesResponse(rsp)
}

// DerivativesExchangesListWithResponse request returning *DerivativesExchangesListResponse
func (c *ClientWithResponses) DerivativesExchangesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DerivativesExchangesListResponse, error) {
	rsp, err := c.DerivativesExchangesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDerivativesExchangesListResponse(rsp)
}

// DerivativesExchangesIdWithResponse request returning *DerivativesExchangesIdResponse
func (c *ClientWithResponses) DerivativesExchangesIdWithResponse(ctx context.Context, id string, params *DerivativesExchangesIdParams, reqEditors ...RequestEditorFn) (*DerivativesExchangesIdResponse, error) {
	rsp, err := c.DerivativesExchangesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDerivativesExchangesIdResponse(rsp)
}

// ExchangeRatesWithResponse request returning *ExchangeRatesResponse
func (c *ClientWithResponses) ExchangeRatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExchangeRatesResponse, error) {
	rsp, err := c.ExchangeRates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeRatesResponse(rsp)
}

// ExchangesWithResponse request returning *ExchangesResponse
func (c *ClientWithResponses) ExchangesWithResponse(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*ExchangesResponse, error) {
	rsp, err := c.Exchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangesResponse(rsp)
}

// ExchangesListWithResponse request returning *ExchangesListResponse
func (c *ClientWithResponses) ExchangesListWithResponse(ctx context.Context, params *ExchangesListParams, reqEditors ...RequestEditorFn) (*ExchangesListResponse, error) {
	rsp, err := c.ExchangesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangesListResponse(rsp)
}

// ExchangesIdWithResponse request returning *ExchangesIdResponse
func (c *ClientWithResponses) ExchangesIdWithResponse(ctx context.Context, id string, params *ExchangesIdParams, reqEditors ...RequestEditorFn) (*ExchangesIdResponse, error) {
	rsp, err := c.ExchangesId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangesIdResponse(rsp)
}

// ExchangesIdTickersWithResponse request returning *ExchangesIdTickersResponse
func (c *ClientWithResponses) ExchangesIdTickersWithResponse(ctx context.Context, id string, params *ExchangesIdTickersParams, reqEditors ...RequestEditorFn) (*ExchangesIdTickersResponse, error) {
	rsp, err := c.ExchangesIdTickers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangesIdTickersResponse(rsp)
}

// ExchangesIdVolumeChartWithResponse request returning *ExchangesIdVolumeChartResponse
func (c *ClientWithResponses) ExchangesIdVolumeChartWithResponse(ctx context.Context, id string, params *ExchangesIdVolumeChartParams, reqEditors ...RequestEditorFn) (*ExchangesIdVolumeChartResponse, error) {
	rsp, err := c.ExchangesIdVolumeChart(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangesIdVolumeChartResponse(rsp)
}

// CryptoGlobalWithResponse request returning *CryptoGlobalResponse
func (c *ClientWithResponses) CryptoGlobalWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CryptoGlobalResponse, error) {
	rsp, err := c.CryptoGlobal(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCryptoGlobalResponse(rsp)
}

// GlobalDeFiWithResponse request returning *GlobalDeFiResponse
func (c *ClientWithResponses) GlobalDeFiWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlobalDeFiResponse, error) {
	rsp, err := c.GlobalDeFi(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlobalDeFiResponse(rsp)
}

// NftsListWithResponse request returning *NftsListResponse
func (c *ClientWithResponses) NftsListWithResponse(ctx context.Context, params *NftsListParams, reqEditors ...RequestEditorFn) (*NftsListResponse, error) {
	rsp, err := c.NftsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNftsListResponse(rsp)
}

// NftsContractAddressWithResponse request returning *NftsContractAddressResponse
func (c *ClientWithResponses) NftsContractAddressWithResponse(ctx context.Context, assetPlatformId string, contractAddress string, reqEditors ...RequestEditorFn) (*NftsContractAddressResponse, error) {
	rsp, err := c.NftsContractAddress(ctx, assetPlatformId, contractAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNftsContractAddressResponse(rsp)
}

// NftsIdWithResponse request returning *NftsIdResponse
func (c *ClientWithResponses) NftsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*NftsIdResponse, error) {
	rsp, err := c.NftsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNftsIdResponse(rsp)
}

// PingServerWithResponse request returning *PingServerResponse
func (c *ClientWithResponses) PingServerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PingServerResponse, error) {
	rsp, err := c.PingServer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePingServerResponse(rsp)
}

// SearchDataWithResponse request returning *SearchDataResponse
func (c *ClientWithResponses) SearchDataWithResponse(ctx context.Context, params *SearchDataParams, reqEditors ...RequestEditorFn) (*SearchDataResponse, error) {
	rsp, err := c.SearchData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDataResponse(rsp)
}

// TrendingSearchWithResponse request returning *TrendingSearchResponse
func (c *ClientWithResponses) TrendingSearchWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TrendingSearchResponse, error) {
	rsp, err := c.TrendingSearch(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrendingSearchResponse(rsp)
}

// SimplePriceWithResponse request returning *SimplePriceResponse
func (c *ClientWithResponses) SimplePriceWithResponse(ctx context.Context, params *SimplePriceParams, reqEditors ...RequestEditorFn) (*SimplePriceResponse, error) {
	rsp, err := c.SimplePrice(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimplePriceResponse(rsp)
}

// SimpleSupportedCurrenciesWithResponse request returning *SimpleSupportedCurrenciesResponse
func (c *ClientWithResponses) SimpleSupportedCurrenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SimpleSupportedCurrenciesResponse, error) {
	rsp, err := c.SimpleSupportedCurrencies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimpleSupportedCurrenciesResponse(rsp)
}

// SimpleTokenPriceWithResponse request returning *SimpleTokenPriceResponse
func (c *ClientWithResponses) SimpleTokenPriceWithResponse(ctx context.Context, id string, params *SimpleTokenPriceParams, reqEditors ...RequestEditorFn) (*SimpleTokenPriceResponse, error) {
	rsp, err := c.SimpleTokenPrice(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSimpleTokenPriceResponse(rsp)
}

// ParseAssetPlatformsListResponse parses an HTTP response from a AssetPlatformsListWithResponse call
func ParseAssetPlatformsListResponse(rsp *http.Response) (*AssetPlatformsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetPlatformsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssetPlatforms
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsCategoriesResponse parses an HTTP response from a CoinsCategoriesWithResponse call
func ParseCoinsCategoriesResponse(rsp *http.Response) (*CoinsCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Categories
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsCategoriesListResponse parses an HTTP response from a CoinsCategoriesListWithResponse call
func ParseCoinsCategoriesListResponse(rsp *http.Response) (*CoinsCategoriesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsCategoriesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoriesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsListResponse parses an HTTP response from a CoinsListWithResponse call
func ParseCoinsListResponse(rsp *http.Response) (*CoinsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsMarketsResponse parses an HTTP response from a CoinsMarketsWithResponse call
func ParseCoinsMarketsResponse(rsp *http.Response) (*CoinsMarketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsMarketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsMarkets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsIdResponse parses an HTTP response from a CoinsIdWithResponse call
func ParseCoinsIdResponse(rsp *http.Response) (*CoinsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsContractAddressResponse parses an HTTP response from a CoinsContractAddressWithResponse call
func ParseCoinsContractAddressResponse(rsp *http.Response) (*CoinsContractAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsContractAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsContractAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseContractAddressMarketChartResponse parses an HTTP response from a ContractAddressMarketChartWithResponse call
func ParseContractAddressMarketChartResponse(rsp *http.Response) (*ContractAddressMarketChartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContractAddressMarketChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsMarketChart
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseContractAddressMarketChartRangeResponse parses an HTTP response from a ContractAddressMarketChartRangeWithResponse call
func ParseContractAddressMarketChartRangeResponse(rsp *http.Response) (*ContractAddressMarketChartRangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ContractAddressMarketChartRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsMarketChartRange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsIdHistoryResponse parses an HTTP response from a CoinsIdHistoryWithResponse call
func ParseCoinsIdHistoryResponse(rsp *http.Response) (*CoinsIdHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsIdHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsHistoricalData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsIdMarketChartResponse parses an HTTP response from a CoinsIdMarketChartWithResponse call
func ParseCoinsIdMarketChartResponse(rsp *http.Response) (*CoinsIdMarketChartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsIdMarketChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsMarketChart
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsIdMarketChartRangeResponse parses an HTTP response from a CoinsIdMarketChartRangeWithResponse call
func ParseCoinsIdMarketChartRangeResponse(rsp *http.Response) (*CoinsIdMarketChartRangeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsIdMarketChartRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsMarketChartRange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsIdOhlcResponse parses an HTTP response from a CoinsIdOhlcWithResponse call
func ParseCoinsIdOhlcResponse(rsp *http.Response) (*CoinsIdOhlcResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsIdOhlcResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsOHLC
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCoinsIdTickersResponse parses an HTTP response from a CoinsIdTickersWithResponse call
func ParseCoinsIdTickersResponse(rsp *http.Response) (*CoinsIdTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CoinsIdTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoinsTickers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCompaniesPublicTreasuryResponse parses an HTTP response from a CompaniesPublicTreasuryWithResponse call
func ParseCompaniesPublicTreasuryResponse(rsp *http.Response) (*CompaniesPublicTreasuryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompaniesPublicTreasuryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CompaniesTreasury
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDerivativesTickersResponse parses an HTTP response from a DerivativesTickersWithResponse call
func ParseDerivativesTickersResponse(rsp *http.Response) (*DerivativesTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DerivativesTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DerivativesTickersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDerivativesExchangesResponse parses an HTTP response from a DerivativesExchangesWithResponse call
func ParseDerivativesExchangesResponse(rsp *http.Response) (*DerivativesExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DerivativesExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DerivativesExchanges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDerivativesExchangesListResponse parses an HTTP response from a DerivativesExchangesListWithResponse call
func ParseDerivativesExchangesListResponse(rsp *http.Response) (*DerivativesExchangesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DerivativesExchangesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DerivativesExchangesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDerivativesExchangesIdResponse parses an HTTP response from a DerivativesExchangesIdWithResponse call
func ParseDerivativesExchangesIdResponse(rsp *http.Response) (*DerivativesExchangesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DerivativesExchangesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DerivativesExchangesID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangeRatesResponse parses an HTTP response from a ExchangeRatesWithResponse call
func ParseExchangeRatesResponse(rsp *http.Response) (*ExchangeRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeRates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangesResponse parses an HTTP response from a ExchangesWithResponse call
func ParseExchangesResponse(rsp *http.Response) (*ExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Exchanges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangesListResponse parses an HTTP response from a ExchangesListWithResponse call
func ParseExchangesListResponse(rsp *http.Response) (*ExchangesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangesIdResponse parses an HTTP response from a ExchangesIdWithResponse call
func ParseExchangesIdResponse(rsp *http.Response) (*ExchangesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangesIdTickersResponse parses an HTTP response from a ExchangesIdTickersWithResponse call
func ParseExchangesIdTickersResponse(rsp *http.Response) (*ExchangesIdTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangesIdTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeTickers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExchangesIdVolumeChartResponse parses an HTTP response from a ExchangesIdVolumeChartWithResponse call
func ParseExchangesIdVolumeChartResponse(rsp *http.Response) (*ExchangesIdVolumeChartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangesIdVolumeChartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeVolumeChart
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCryptoGlobalResponse parses an HTTP response from a CryptoGlobalWithResponse call
func ParseCryptoGlobalResponse(rsp *http.Response) (*CryptoGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CryptoGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGlobalDeFiResponse parses an HTTP response from a GlobalDeFiWithResponse call
func ParseGlobalDeFiResponse(rsp *http.Response) (*GlobalDeFiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlobalDeFiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalDeFi
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNftsListResponse parses an HTTP response from a NftsListWithResponse call
func ParseNftsListResponse(rsp *http.Response) (*NftsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NftsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NFTList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNftsContractAddressResponse parses an HTTP response from a NftsContractAddressWithResponse call
func ParseNftsContractAddressResponse(rsp *http.Response) (*NftsContractAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NftsContractAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NFTData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNftsIdResponse parses an HTTP response from a NftsIdWithResponse call
func ParseNftsIdResponse(rsp *http.Response) (*NftsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NftsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NFTData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePingServerResponse parses an HTTP response from a PingServerWithResponse call
func ParsePingServerResponse(rsp *http.Response) (*PingServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PingServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchDataResponse parses an HTTP response from a SearchDataWithResponse call
func ParseSearchDataResponse(rsp *http.Response) (*SearchDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Search
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTrendingSearchResponse parses an HTTP response from a TrendingSearchWithResponse call
func ParseTrendingSearchResponse(rsp *http.Response) (*TrendingSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrendingSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrendingSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSimplePriceResponse parses an HTTP response from a SimplePriceWithResponse call
func ParseSimplePriceResponse(rsp *http.Response) (*SimplePriceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimplePriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimplePrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSimpleSupportedCurrenciesResponse parses an HTTP response from a SimpleSupportedCurrenciesWithResponse call
func ParseSimpleSupportedCurrenciesResponse(rsp *http.Response) (*SimpleSupportedCurrenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimpleSupportedCurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrencyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSimpleTokenPriceResponse parses an HTTP response from a SimpleTokenPriceWithResponse call
func ParseSimpleTokenPriceResponse(rsp *http.Response) (*SimpleTokenPriceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SimpleTokenPriceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SimpleTokenPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
