// Package noaa provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package noaa

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	UserAgentScopes = "userAgent.Scopes"
)

// Defines values for AlertCategory.
const (
	AlertCategoryCBRNE     AlertCategory = "CBRNE"
	AlertCategoryEnv       AlertCategory = "Env"
	AlertCategoryFire      AlertCategory = "Fire"
	AlertCategoryGeo       AlertCategory = "Geo"
	AlertCategoryHealth    AlertCategory = "Health"
	AlertCategoryInfra     AlertCategory = "Infra"
	AlertCategoryMet       AlertCategory = "Met"
	AlertCategoryOther     AlertCategory = "Other"
	AlertCategoryRescue    AlertCategory = "Rescue"
	AlertCategorySafety    AlertCategory = "Safety"
	AlertCategorySecurity  AlertCategory = "Security"
	AlertCategoryTransport AlertCategory = "Transport"
)

// Defines values for AlertResponse.
const (
	AllClear AlertResponse = "AllClear"
	Assess   AlertResponse = "Assess"
	Avoid    AlertResponse = "Avoid"
	Evacuate AlertResponse = "Evacuate"
	Execute  AlertResponse = "Execute"
	Monitor  AlertResponse = "Monitor"
	None     AlertResponse = "None"
	Prepare  AlertResponse = "Prepare"
	Shelter  AlertResponse = "Shelter"
)

// Defines values for AlertScope.
const (
	Private    AlertScope = "Private"
	Public     AlertScope = "Public"
	Restricted AlertScope = "Restricted"
)

// Defines values for AlertCertaintyEnum.
const (
	AlertCertaintyEnumLikely   AlertCertaintyEnum = "Likely"
	AlertCertaintyEnumObserved AlertCertaintyEnum = "Observed"
	AlertCertaintyEnumPossible AlertCertaintyEnum = "Possible"
	AlertCertaintyEnumUnknown  AlertCertaintyEnum = "Unknown"
	AlertCertaintyEnumUnlikely AlertCertaintyEnum = "Unlikely"
)

// Defines values for AlertCollectionGeoJsonType.
const (
	AlertCollectionGeoJsonTypeFeatureCollection AlertCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for AlertGeoJsonType.
const (
	AlertGeoJsonTypeFeature AlertGeoJsonType = "Feature"
)

// Defines values for AlertMessageTypeEnum.
const (
	AlertMessageTypeEnumAck    AlertMessageTypeEnum = "Ack"
	AlertMessageTypeEnumAlert  AlertMessageTypeEnum = "Alert"
	AlertMessageTypeEnumCancel AlertMessageTypeEnum = "Cancel"
	AlertMessageTypeEnumError  AlertMessageTypeEnum = "Error"
	AlertMessageTypeEnumUpdate AlertMessageTypeEnum = "Update"
)

// Defines values for AlertSeverityEnum.
const (
	AlertSeverityEnumExtreme  AlertSeverityEnum = "Extreme"
	AlertSeverityEnumMinor    AlertSeverityEnum = "Minor"
	AlertSeverityEnumModerate AlertSeverityEnum = "Moderate"
	AlertSeverityEnumSevere   AlertSeverityEnum = "Severe"
	AlertSeverityEnumUnknown  AlertSeverityEnum = "Unknown"
)

// Defines values for AlertStatusEnum.
const (
	AlertStatusEnumActual   AlertStatusEnum = "Actual"
	AlertStatusEnumDraft    AlertStatusEnum = "Draft"
	AlertStatusEnumExercise AlertStatusEnum = "Exercise"
	AlertStatusEnumSystem   AlertStatusEnum = "System"
	AlertStatusEnumTest     AlertStatusEnum = "Test"
)

// Defines values for AlertUrgencyEnum.
const (
	AlertUrgencyEnumExpected  AlertUrgencyEnum = "Expected"
	AlertUrgencyEnumFuture    AlertUrgencyEnum = "Future"
	AlertUrgencyEnumImmediate AlertUrgencyEnum = "Immediate"
	AlertUrgencyEnumPast      AlertUrgencyEnum = "Past"
	AlertUrgencyEnumUnknown   AlertUrgencyEnum = "Unknown"
)

// Defines values for CenterWeatherAdvisoryCollectionGeoJsonType.
const (
	CenterWeatherAdvisoryCollectionGeoJsonTypeFeatureCollection CenterWeatherAdvisoryCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for CenterWeatherAdvisoryGeoJsonType.
const (
	CenterWeatherAdvisoryGeoJsonTypeFeature CenterWeatherAdvisoryGeoJsonType = "Feature"
)

// Defines values for GeoJsonFeatureType.
const (
	GeoJsonFeatureTypeFeature GeoJsonFeatureType = "Feature"
)

// Defines values for GeoJsonFeatureCollectionType.
const (
	GeoJsonFeatureCollectionTypeFeatureCollection GeoJsonFeatureCollectionType = "FeatureCollection"
)

// Defines values for GeoJsonGeometry0Type.
const (
	GeoJsonGeometry0TypePoint GeoJsonGeometry0Type = "Point"
)

// Defines values for GeoJsonGeometry1Type.
const (
	LineString GeoJsonGeometry1Type = "LineString"
)

// Defines values for GeoJsonGeometry2Type.
const (
	Polygon GeoJsonGeometry2Type = "Polygon"
)

// Defines values for GeoJsonGeometry3Type.
const (
	MultiPoint GeoJsonGeometry3Type = "MultiPoint"
)

// Defines values for GeoJsonGeometry4Type.
const (
	MultiLineString GeoJsonGeometry4Type = "MultiLineString"
)

// Defines values for GeoJsonGeometry5Type.
const (
	MultiPolygon GeoJsonGeometry5Type = "MultiPolygon"
)

// Defines values for GridpointType.
const (
	WxGridpoint GridpointType = "wx:Gridpoint"
)

// Defines values for GridpointWeatherValuesValueAttributes.
const (
	DamagingWind     GridpointWeatherValuesValueAttributes = "damaging_wind"
	DryThunderstorms GridpointWeatherValuesValueAttributes = "dry_thunderstorms"
	Flooding         GridpointWeatherValuesValueAttributes = "flooding"
	GustyWind        GridpointWeatherValuesValueAttributes = "gusty_wind"
	HeavyRain        GridpointWeatherValuesValueAttributes = "heavy_rain"
	LargeHail        GridpointWeatherValuesValueAttributes = "large_hail"
	SmallHail        GridpointWeatherValuesValueAttributes = "small_hail"
	Tornadoes        GridpointWeatherValuesValueAttributes = "tornadoes"
)

// Defines values for GridpointWeatherValuesValueCoverage.
const (
	Areas        GridpointWeatherValuesValueCoverage = "areas"
	Brief        GridpointWeatherValuesValueCoverage = "brief"
	Chance       GridpointWeatherValuesValueCoverage = "chance"
	Definite     GridpointWeatherValuesValueCoverage = "definite"
	Few          GridpointWeatherValuesValueCoverage = "few"
	Frequent     GridpointWeatherValuesValueCoverage = "frequent"
	Intermittent GridpointWeatherValuesValueCoverage = "intermittent"
	Isolated     GridpointWeatherValuesValueCoverage = "isolated"
	Likely       GridpointWeatherValuesValueCoverage = "likely"
	Numerous     GridpointWeatherValuesValueCoverage = "numerous"
	Occasional   GridpointWeatherValuesValueCoverage = "occasional"
	Patchy       GridpointWeatherValuesValueCoverage = "patchy"
	Periods      GridpointWeatherValuesValueCoverage = "periods"
	Scattered    GridpointWeatherValuesValueCoverage = "scattered"
	SlightChance GridpointWeatherValuesValueCoverage = "slight_chance"
	Widespread   GridpointWeatherValuesValueCoverage = "widespread"
)

// Defines values for GridpointWeatherValuesValueIntensity.
const (
	GridpointWeatherValuesValueIntensityHeavy     GridpointWeatherValuesValueIntensity = "heavy"
	GridpointWeatherValuesValueIntensityLight     GridpointWeatherValuesValueIntensity = "light"
	GridpointWeatherValuesValueIntensityModerate  GridpointWeatherValuesValueIntensity = "moderate"
	GridpointWeatherValuesValueIntensityVeryLight GridpointWeatherValuesValueIntensity = "very_light"
)

// Defines values for GridpointWeatherValuesValueWeather.
const (
	BlowingDust     GridpointWeatherValuesValueWeather = "blowing_dust"
	BlowingSand     GridpointWeatherValuesValueWeather = "blowing_sand"
	BlowingSnow     GridpointWeatherValuesValueWeather = "blowing_snow"
	Drizzle         GridpointWeatherValuesValueWeather = "drizzle"
	Fog             GridpointWeatherValuesValueWeather = "fog"
	FreezingDrizzle GridpointWeatherValuesValueWeather = "freezing_drizzle"
	FreezingFog     GridpointWeatherValuesValueWeather = "freezing_fog"
	FreezingRain    GridpointWeatherValuesValueWeather = "freezing_rain"
	FreezingSpray   GridpointWeatherValuesValueWeather = "freezing_spray"
	Frost           GridpointWeatherValuesValueWeather = "frost"
	Hail            GridpointWeatherValuesValueWeather = "hail"
	Haze            GridpointWeatherValuesValueWeather = "haze"
	IceCrystals     GridpointWeatherValuesValueWeather = "ice_crystals"
	IceFog          GridpointWeatherValuesValueWeather = "ice_fog"
	Rain            GridpointWeatherValuesValueWeather = "rain"
	RainShowers     GridpointWeatherValuesValueWeather = "rain_showers"
	Sleet           GridpointWeatherValuesValueWeather = "sleet"
	Smoke           GridpointWeatherValuesValueWeather = "smoke"
	Snow            GridpointWeatherValuesValueWeather = "snow"
	SnowShowers     GridpointWeatherValuesValueWeather = "snow_showers"
	Thunderstorms   GridpointWeatherValuesValueWeather = "thunderstorms"
	VolcanicAsh     GridpointWeatherValuesValueWeather = "volcanic_ash"
	WaterSpouts     GridpointWeatherValuesValueWeather = "water_spouts"
)

// Defines values for Gridpoint12hForecastGeoJsonType.
const (
	Gridpoint12hForecastGeoJsonTypeFeature Gridpoint12hForecastGeoJsonType = "Feature"
)

// Defines values for Gridpoint12hForecastPeriodTemperatureTrend.
const (
	Gridpoint12hForecastPeriodTemperatureTrendFalling Gridpoint12hForecastPeriodTemperatureTrend = "falling"
	Gridpoint12hForecastPeriodTemperatureTrendRising  Gridpoint12hForecastPeriodTemperatureTrend = "rising"
)

// Defines values for Gridpoint12hForecastPeriodTemperatureUnit.
const (
	Gridpoint12hForecastPeriodTemperatureUnitC Gridpoint12hForecastPeriodTemperatureUnit = "C"
	Gridpoint12hForecastPeriodTemperatureUnitF Gridpoint12hForecastPeriodTemperatureUnit = "F"
)

// Defines values for Gridpoint12hForecastPeriodWindDirection.
const (
	Gridpoint12hForecastPeriodWindDirectionE   Gridpoint12hForecastPeriodWindDirection = "E"
	Gridpoint12hForecastPeriodWindDirectionENE Gridpoint12hForecastPeriodWindDirection = "ENE"
	Gridpoint12hForecastPeriodWindDirectionESE Gridpoint12hForecastPeriodWindDirection = "ESE"
	Gridpoint12hForecastPeriodWindDirectionN   Gridpoint12hForecastPeriodWindDirection = "N"
	Gridpoint12hForecastPeriodWindDirectionNE  Gridpoint12hForecastPeriodWindDirection = "NE"
	Gridpoint12hForecastPeriodWindDirectionNNE Gridpoint12hForecastPeriodWindDirection = "NNE"
	Gridpoint12hForecastPeriodWindDirectionNNW Gridpoint12hForecastPeriodWindDirection = "NNW"
	Gridpoint12hForecastPeriodWindDirectionNW  Gridpoint12hForecastPeriodWindDirection = "NW"
	Gridpoint12hForecastPeriodWindDirectionS   Gridpoint12hForecastPeriodWindDirection = "S"
	Gridpoint12hForecastPeriodWindDirectionSE  Gridpoint12hForecastPeriodWindDirection = "SE"
	Gridpoint12hForecastPeriodWindDirectionSSE Gridpoint12hForecastPeriodWindDirection = "SSE"
	Gridpoint12hForecastPeriodWindDirectionSSW Gridpoint12hForecastPeriodWindDirection = "SSW"
	Gridpoint12hForecastPeriodWindDirectionSW  Gridpoint12hForecastPeriodWindDirection = "SW"
	Gridpoint12hForecastPeriodWindDirectionW   Gridpoint12hForecastPeriodWindDirection = "W"
	Gridpoint12hForecastPeriodWindDirectionWNW Gridpoint12hForecastPeriodWindDirection = "WNW"
	Gridpoint12hForecastPeriodWindDirectionWSW Gridpoint12hForecastPeriodWindDirection = "WSW"
)

// Defines values for GridpointForecastUnits.
const (
	Si GridpointForecastUnits = "si"
	Us GridpointForecastUnits = "us"
)

// Defines values for GridpointGeoJsonType.
const (
	GridpointGeoJsonTypeFeature GridpointGeoJsonType = "Feature"
)

// Defines values for GridpointHourlyForecastGeoJsonType.
const (
	GridpointHourlyForecastGeoJsonTypeFeature GridpointHourlyForecastGeoJsonType = "Feature"
)

// Defines values for GridpointHourlyForecastPeriodTemperatureTrend.
const (
	GridpointHourlyForecastPeriodTemperatureTrendFalling GridpointHourlyForecastPeriodTemperatureTrend = "falling"
	GridpointHourlyForecastPeriodTemperatureTrendRising  GridpointHourlyForecastPeriodTemperatureTrend = "rising"
)

// Defines values for GridpointHourlyForecastPeriodTemperatureUnit.
const (
	GridpointHourlyForecastPeriodTemperatureUnitC GridpointHourlyForecastPeriodTemperatureUnit = "C"
	GridpointHourlyForecastPeriodTemperatureUnitF GridpointHourlyForecastPeriodTemperatureUnit = "F"
)

// Defines values for GridpointHourlyForecastPeriodWindDirection.
const (
	GridpointHourlyForecastPeriodWindDirectionE   GridpointHourlyForecastPeriodWindDirection = "E"
	GridpointHourlyForecastPeriodWindDirectionENE GridpointHourlyForecastPeriodWindDirection = "ENE"
	GridpointHourlyForecastPeriodWindDirectionESE GridpointHourlyForecastPeriodWindDirection = "ESE"
	GridpointHourlyForecastPeriodWindDirectionN   GridpointHourlyForecastPeriodWindDirection = "N"
	GridpointHourlyForecastPeriodWindDirectionNE  GridpointHourlyForecastPeriodWindDirection = "NE"
	GridpointHourlyForecastPeriodWindDirectionNNE GridpointHourlyForecastPeriodWindDirection = "NNE"
	GridpointHourlyForecastPeriodWindDirectionNNW GridpointHourlyForecastPeriodWindDirection = "NNW"
	GridpointHourlyForecastPeriodWindDirectionNW  GridpointHourlyForecastPeriodWindDirection = "NW"
	GridpointHourlyForecastPeriodWindDirectionS   GridpointHourlyForecastPeriodWindDirection = "S"
	GridpointHourlyForecastPeriodWindDirectionSE  GridpointHourlyForecastPeriodWindDirection = "SE"
	GridpointHourlyForecastPeriodWindDirectionSSE GridpointHourlyForecastPeriodWindDirection = "SSE"
	GridpointHourlyForecastPeriodWindDirectionSSW GridpointHourlyForecastPeriodWindDirection = "SSW"
	GridpointHourlyForecastPeriodWindDirectionSW  GridpointHourlyForecastPeriodWindDirection = "SW"
	GridpointHourlyForecastPeriodWindDirectionW   GridpointHourlyForecastPeriodWindDirection = "W"
	GridpointHourlyForecastPeriodWindDirectionWNW GridpointHourlyForecastPeriodWindDirection = "WNW"
	GridpointHourlyForecastPeriodWindDirectionWSW GridpointHourlyForecastPeriodWindDirection = "WSW"
)

// Defines values for LandRegionCode.
const (
	LandRegionCodeAR LandRegionCode = "AR"
	LandRegionCodeCR LandRegionCode = "CR"
	LandRegionCodeER LandRegionCode = "ER"
	LandRegionCodePR LandRegionCode = "PR"
	LandRegionCodeSR LandRegionCode = "SR"
	LandRegionCodeWR LandRegionCode = "WR"
)

// Defines values for MarineAreaCode.
const (
	MarineAreaCodeAM MarineAreaCode = "AM"
	MarineAreaCodeAN MarineAreaCode = "AN"
	MarineAreaCodeGM MarineAreaCode = "GM"
	MarineAreaCodeLC MarineAreaCode = "LC"
	MarineAreaCodeLE MarineAreaCode = "LE"
	MarineAreaCodeLH MarineAreaCode = "LH"
	MarineAreaCodeLM MarineAreaCode = "LM"
	MarineAreaCodeLO MarineAreaCode = "LO"
	MarineAreaCodeLS MarineAreaCode = "LS"
	MarineAreaCodePH MarineAreaCode = "PH"
	MarineAreaCodePK MarineAreaCode = "PK"
	MarineAreaCodePM MarineAreaCode = "PM"
	MarineAreaCodePS MarineAreaCode = "PS"
	MarineAreaCodePZ MarineAreaCode = "PZ"
	MarineAreaCodeSL MarineAreaCode = "SL"
)

// Defines values for MarineRegionCode.
const (
	MarineRegionCodeAL MarineRegionCode = "AL"
	MarineRegionCodeAT MarineRegionCode = "AT"
	MarineRegionCodeGL MarineRegionCode = "GL"
	MarineRegionCodeGM MarineRegionCode = "GM"
	MarineRegionCodePA MarineRegionCode = "PA"
	MarineRegionCodePI MarineRegionCode = "PI"
)

// Defines values for MetarPhenomenonIntensity.
const (
	MetarPhenomenonIntensityHeavy MetarPhenomenonIntensity = "heavy"
	MetarPhenomenonIntensityLight MetarPhenomenonIntensity = "light"
)

// Defines values for MetarPhenomenonModifier.
const (
	Blowing     MetarPhenomenonModifier = "blowing"
	Freezing    MetarPhenomenonModifier = "freezing"
	LowDrifting MetarPhenomenonModifier = "low_drifting"
	Partial     MetarPhenomenonModifier = "partial"
	Patches     MetarPhenomenonModifier = "patches"
	Shallow     MetarPhenomenonModifier = "shallow"
	Showers     MetarPhenomenonModifier = "showers"
)

// Defines values for MetarPhenomenonWeather.
const (
	MetarPhenomenonWeatherDrizzle       MetarPhenomenonWeather = "drizzle"
	MetarPhenomenonWeatherDust          MetarPhenomenonWeather = "dust"
	MetarPhenomenonWeatherDustStorm     MetarPhenomenonWeather = "dust_storm"
	MetarPhenomenonWeatherDustWhirls    MetarPhenomenonWeather = "dust_whirls"
	MetarPhenomenonWeatherFog           MetarPhenomenonWeather = "fog"
	MetarPhenomenonWeatherFogMist       MetarPhenomenonWeather = "fog_mist"
	MetarPhenomenonWeatherFunnelCloud   MetarPhenomenonWeather = "funnel_cloud"
	MetarPhenomenonWeatherHail          MetarPhenomenonWeather = "hail"
	MetarPhenomenonWeatherHaze          MetarPhenomenonWeather = "haze"
	MetarPhenomenonWeatherIceCrystals   MetarPhenomenonWeather = "ice_crystals"
	MetarPhenomenonWeatherIcePellets    MetarPhenomenonWeather = "ice_pellets"
	MetarPhenomenonWeatherRain          MetarPhenomenonWeather = "rain"
	MetarPhenomenonWeatherSand          MetarPhenomenonWeather = "sand"
	MetarPhenomenonWeatherSandStorm     MetarPhenomenonWeather = "sand_storm"
	MetarPhenomenonWeatherSmoke         MetarPhenomenonWeather = "smoke"
	MetarPhenomenonWeatherSnow          MetarPhenomenonWeather = "snow"
	MetarPhenomenonWeatherSnowGrains    MetarPhenomenonWeather = "snow_grains"
	MetarPhenomenonWeatherSnowPellets   MetarPhenomenonWeather = "snow_pellets"
	MetarPhenomenonWeatherSpray         MetarPhenomenonWeather = "spray"
	MetarPhenomenonWeatherSqualls       MetarPhenomenonWeather = "squalls"
	MetarPhenomenonWeatherThunderstorms MetarPhenomenonWeather = "thunderstorms"
	MetarPhenomenonWeatherUnknown       MetarPhenomenonWeather = "unknown"
	MetarPhenomenonWeatherVolcanicAsh   MetarPhenomenonWeather = "volcanic_ash"
)

// Defines values for MetarSkyCoverage.
const (
	BKN MetarSkyCoverage = "BKN"
	CLR MetarSkyCoverage = "CLR"
	FEW MetarSkyCoverage = "FEW"
	OVC MetarSkyCoverage = "OVC"
	SCT MetarSkyCoverage = "SCT"
	SKC MetarSkyCoverage = "SKC"
	VV  MetarSkyCoverage = "VV"
)

// Defines values for NWSCenterWeatherServiceUnitId.
const (
	ZAB NWSCenterWeatherServiceUnitId = "ZAB"
	ZAN NWSCenterWeatherServiceUnitId = "ZAN"
	ZAU NWSCenterWeatherServiceUnitId = "ZAU"
	ZBW NWSCenterWeatherServiceUnitId = "ZBW"
	ZDC NWSCenterWeatherServiceUnitId = "ZDC"
	ZDV NWSCenterWeatherServiceUnitId = "ZDV"
	ZFA NWSCenterWeatherServiceUnitId = "ZFA"
	ZFW NWSCenterWeatherServiceUnitId = "ZFW"
	ZHU NWSCenterWeatherServiceUnitId = "ZHU"
	ZID NWSCenterWeatherServiceUnitId = "ZID"
	ZJX NWSCenterWeatherServiceUnitId = "ZJX"
	ZKC NWSCenterWeatherServiceUnitId = "ZKC"
	ZLA NWSCenterWeatherServiceUnitId = "ZLA"
	ZLC NWSCenterWeatherServiceUnitId = "ZLC"
	ZMA NWSCenterWeatherServiceUnitId = "ZMA"
	ZME NWSCenterWeatherServiceUnitId = "ZME"
	ZMP NWSCenterWeatherServiceUnitId = "ZMP"
	ZNY NWSCenterWeatherServiceUnitId = "ZNY"
	ZOA NWSCenterWeatherServiceUnitId = "ZOA"
	ZOB NWSCenterWeatherServiceUnitId = "ZOB"
	ZSE NWSCenterWeatherServiceUnitId = "ZSE"
	ZTL NWSCenterWeatherServiceUnitId = "ZTL"
)

// Defines values for NWSForecastOfficeId.
const (
	ABQ NWSForecastOfficeId = "ABQ"
	ABR NWSForecastOfficeId = "ABR"
	AER NWSForecastOfficeId = "AER"
	AFC NWSForecastOfficeId = "AFC"
	AFG NWSForecastOfficeId = "AFG"
	AJK NWSForecastOfficeId = "AJK"
	AKQ NWSForecastOfficeId = "AKQ"
	ALU NWSForecastOfficeId = "ALU"
	ALY NWSForecastOfficeId = "ALY"
	AMA NWSForecastOfficeId = "AMA"
	APX NWSForecastOfficeId = "APX"
	ARX NWSForecastOfficeId = "ARX"
	BGM NWSForecastOfficeId = "BGM"
	BIS NWSForecastOfficeId = "BIS"
	BMX NWSForecastOfficeId = "BMX"
	BOI NWSForecastOfficeId = "BOI"
	BOU NWSForecastOfficeId = "BOU"
	BOX NWSForecastOfficeId = "BOX"
	BRO NWSForecastOfficeId = "BRO"
	BTV NWSForecastOfficeId = "BTV"
	BUF NWSForecastOfficeId = "BUF"
	BYZ NWSForecastOfficeId = "BYZ"
	CAE NWSForecastOfficeId = "CAE"
	CAR NWSForecastOfficeId = "CAR"
	CHS NWSForecastOfficeId = "CHS"
	CLE NWSForecastOfficeId = "CLE"
	CRP NWSForecastOfficeId = "CRP"
	CTP NWSForecastOfficeId = "CTP"
	CYS NWSForecastOfficeId = "CYS"
	DDC NWSForecastOfficeId = "DDC"
	DLH NWSForecastOfficeId = "DLH"
	DMX NWSForecastOfficeId = "DMX"
	DTX NWSForecastOfficeId = "DTX"
	DVN NWSForecastOfficeId = "DVN"
	EAX NWSForecastOfficeId = "EAX"
	EKA NWSForecastOfficeId = "EKA"
	EPZ NWSForecastOfficeId = "EPZ"
	EWX NWSForecastOfficeId = "EWX"
	FFC NWSForecastOfficeId = "FFC"
	FGF NWSForecastOfficeId = "FGF"
	FGZ NWSForecastOfficeId = "FGZ"
	FSD NWSForecastOfficeId = "FSD"
	FWD NWSForecastOfficeId = "FWD"
	GGW NWSForecastOfficeId = "GGW"
	GID NWSForecastOfficeId = "GID"
	GJT NWSForecastOfficeId = "GJT"
	GLD NWSForecastOfficeId = "GLD"
	GRB NWSForecastOfficeId = "GRB"
	GRR NWSForecastOfficeId = "GRR"
	GSP NWSForecastOfficeId = "GSP"
	GUM NWSForecastOfficeId = "GUM"
	GYX NWSForecastOfficeId = "GYX"
	HFO NWSForecastOfficeId = "HFO"
	HGX NWSForecastOfficeId = "HGX"
	HNX NWSForecastOfficeId = "HNX"
	HPA NWSForecastOfficeId = "HPA"
	HUN NWSForecastOfficeId = "HUN"
	ICT NWSForecastOfficeId = "ICT"
	ILM NWSForecastOfficeId = "ILM"
	ILN NWSForecastOfficeId = "ILN"
	ILX NWSForecastOfficeId = "ILX"
	IND NWSForecastOfficeId = "IND"
	IWX NWSForecastOfficeId = "IWX"
	JAN NWSForecastOfficeId = "JAN"
	JAX NWSForecastOfficeId = "JAX"
	JKL NWSForecastOfficeId = "JKL"
	KEY NWSForecastOfficeId = "KEY"
	LBF NWSForecastOfficeId = "LBF"
	LCH NWSForecastOfficeId = "LCH"
	LIX NWSForecastOfficeId = "LIX"
	LKN NWSForecastOfficeId = "LKN"
	LMK NWSForecastOfficeId = "LMK"
	LOT NWSForecastOfficeId = "LOT"
	LOX NWSForecastOfficeId = "LOX"
	LSX NWSForecastOfficeId = "LSX"
	LUB NWSForecastOfficeId = "LUB"
	LWX NWSForecastOfficeId = "LWX"
	LZK NWSForecastOfficeId = "LZK"
	MAF NWSForecastOfficeId = "MAF"
	MEG NWSForecastOfficeId = "MEG"
	MFL NWSForecastOfficeId = "MFL"
	MFR NWSForecastOfficeId = "MFR"
	MHX NWSForecastOfficeId = "MHX"
	MKX NWSForecastOfficeId = "MKX"
	MLB NWSForecastOfficeId = "MLB"
	MOB NWSForecastOfficeId = "MOB"
	MPX NWSForecastOfficeId = "MPX"
	MQT NWSForecastOfficeId = "MQT"
	MRX NWSForecastOfficeId = "MRX"
	MSO NWSForecastOfficeId = "MSO"
	MTR NWSForecastOfficeId = "MTR"
	NH1 NWSForecastOfficeId = "NH1"
	NH2 NWSForecastOfficeId = "NH2"
	OAX NWSForecastOfficeId = "OAX"
	OHX NWSForecastOfficeId = "OHX"
	OKX NWSForecastOfficeId = "OKX"
	ONA NWSForecastOfficeId = "ONA"
	ONP NWSForecastOfficeId = "ONP"
	OTX NWSForecastOfficeId = "OTX"
	OUN NWSForecastOfficeId = "OUN"
	PAH NWSForecastOfficeId = "PAH"
	PBZ NWSForecastOfficeId = "PBZ"
	PDT NWSForecastOfficeId = "PDT"
	PHI NWSForecastOfficeId = "PHI"
	PIH NWSForecastOfficeId = "PIH"
	PPG NWSForecastOfficeId = "PPG"
	PQR NWSForecastOfficeId = "PQR"
	PSR NWSForecastOfficeId = "PSR"
	PUB NWSForecastOfficeId = "PUB"
	RAH NWSForecastOfficeId = "RAH"
	REV NWSForecastOfficeId = "REV"
	RIW NWSForecastOfficeId = "RIW"
	RLX NWSForecastOfficeId = "RLX"
	RNK NWSForecastOfficeId = "RNK"
	SEW NWSForecastOfficeId = "SEW"
	SGF NWSForecastOfficeId = "SGF"
	SGX NWSForecastOfficeId = "SGX"
	SHV NWSForecastOfficeId = "SHV"
	SJT NWSForecastOfficeId = "SJT"
	SJU NWSForecastOfficeId = "SJU"
	SLC NWSForecastOfficeId = "SLC"
	STO NWSForecastOfficeId = "STO"
	STU NWSForecastOfficeId = "STU"
	TAE NWSForecastOfficeId = "TAE"
	TBW NWSForecastOfficeId = "TBW"
	TFX NWSForecastOfficeId = "TFX"
	TOP NWSForecastOfficeId = "TOP"
	TSA NWSForecastOfficeId = "TSA"
	TWC NWSForecastOfficeId = "TWC"
	UNR NWSForecastOfficeId = "UNR"
	VEF NWSForecastOfficeId = "VEF"
)

// Defines values for NWSNationalHQId.
const (
	NWS NWSNationalHQId = "NWS"
)

// Defines values for NWSRegionalHQId.
const (
	ARH NWSRegionalHQId = "ARH"
	CRH NWSRegionalHQId = "CRH"
	ERH NWSRegionalHQId = "ERH"
	PRH NWSRegionalHQId = "PRH"
	SRH NWSRegionalHQId = "SRH"
	WRH NWSRegionalHQId = "WRH"
)

// Defines values for NWSZoneType.
const (
	NWSZoneTypeCoastal  NWSZoneType = "coastal"
	NWSZoneTypeCounty   NWSZoneType = "county"
	NWSZoneTypeFire     NWSZoneType = "fire"
	NWSZoneTypeForecast NWSZoneType = "forecast"
	NWSZoneTypeLand     NWSZoneType = "land"
	NWSZoneTypeMarine   NWSZoneType = "marine"
	NWSZoneTypeOffshore NWSZoneType = "offshore"
	NWSZoneTypePublic   NWSZoneType = "public"
)

// Defines values for ObservationType.
const (
	ObservationTypeWxObservationStation ObservationType = "wx:ObservationStation"
)

// Defines values for ObservationCollectionGeoJsonType.
const (
	ObservationCollectionGeoJsonTypeFeatureCollection ObservationCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for ObservationGeoJsonType.
const (
	ObservationGeoJsonTypeFeature ObservationGeoJsonType = "Feature"
)

// Defines values for ObservationStationType.
const (
	ObservationStationTypeWxObservationStation ObservationStationType = "wx:ObservationStation"
)

// Defines values for ObservationStationCollectionGeoJsonType.
const (
	ObservationStationCollectionGeoJsonTypeFeatureCollection ObservationStationCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for ObservationStationGeoJsonType.
const (
	ObservationStationGeoJsonTypeFeature ObservationStationGeoJsonType = "Feature"
)

// Defines values for ObservationStationJsonLdType.
const (
	WxObservationStation ObservationStationJsonLdType = "wx:ObservationStation"
)

// Defines values for OfficeType.
const (
	GovernmentOrganization OfficeType = "GovernmentOrganization"
)

// Defines values for OfficeAddressType.
const (
	PostalAddress OfficeAddressType = "PostalAddress"
)

// Defines values for PointType.
const (
	PointTypeWxPoint PointType = "wx:Point"
)

// Defines values for PointGeoJsonType.
const (
	PointGeoJsonTypeFeature PointGeoJsonType = "Feature"
)

// Defines values for PointJsonLdType.
const (
	PointJsonLdTypeWxPoint PointJsonLdType = "wx:Point"
)

// Defines values for QuantitativeValueQualityControl.
const (
	B QuantitativeValueQualityControl = "B"
	C QuantitativeValueQualityControl = "C"
	G QuantitativeValueQualityControl = "G"
	Q QuantitativeValueQualityControl = "Q"
	S QuantitativeValueQualityControl = "S"
	T QuantitativeValueQualityControl = "T"
	V QuantitativeValueQualityControl = "V"
	X QuantitativeValueQualityControl = "X"
	Z QuantitativeValueQualityControl = "Z"
)

// Defines values for RelativeLocationGeoJsonType.
const (
	RelativeLocationGeoJsonTypeFeature RelativeLocationGeoJsonType = "Feature"
)

// Defines values for SigmetCollectionGeoJsonType.
const (
	SigmetCollectionGeoJsonTypeFeatureCollection SigmetCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for SigmetGeoJsonType.
const (
	SigmetGeoJsonTypeFeature SigmetGeoJsonType = "Feature"
)

// Defines values for StateTerritoryCode.
const (
	StateTerritoryCodeAK StateTerritoryCode = "AK"
	StateTerritoryCodeAL StateTerritoryCode = "AL"
	StateTerritoryCodeAR StateTerritoryCode = "AR"
	StateTerritoryCodeAS StateTerritoryCode = "AS"
	StateTerritoryCodeAZ StateTerritoryCode = "AZ"
	StateTerritoryCodeCA StateTerritoryCode = "CA"
	StateTerritoryCodeCO StateTerritoryCode = "CO"
	StateTerritoryCodeCT StateTerritoryCode = "CT"
	StateTerritoryCodeDC StateTerritoryCode = "DC"
	StateTerritoryCodeDE StateTerritoryCode = "DE"
	StateTerritoryCodeFL StateTerritoryCode = "FL"
	StateTerritoryCodeFM StateTerritoryCode = "FM"
	StateTerritoryCodeGA StateTerritoryCode = "GA"
	StateTerritoryCodeGU StateTerritoryCode = "GU"
	StateTerritoryCodeHI StateTerritoryCode = "HI"
	StateTerritoryCodeIA StateTerritoryCode = "IA"
	StateTerritoryCodeID StateTerritoryCode = "ID"
	StateTerritoryCodeIL StateTerritoryCode = "IL"
	StateTerritoryCodeIN StateTerritoryCode = "IN"
	StateTerritoryCodeKS StateTerritoryCode = "KS"
	StateTerritoryCodeKY StateTerritoryCode = "KY"
	StateTerritoryCodeLA StateTerritoryCode = "LA"
	StateTerritoryCodeMA StateTerritoryCode = "MA"
	StateTerritoryCodeMD StateTerritoryCode = "MD"
	StateTerritoryCodeME StateTerritoryCode = "ME"
	StateTerritoryCodeMH StateTerritoryCode = "MH"
	StateTerritoryCodeMI StateTerritoryCode = "MI"
	StateTerritoryCodeMN StateTerritoryCode = "MN"
	StateTerritoryCodeMO StateTerritoryCode = "MO"
	StateTerritoryCodeMP StateTerritoryCode = "MP"
	StateTerritoryCodeMS StateTerritoryCode = "MS"
	StateTerritoryCodeMT StateTerritoryCode = "MT"
	StateTerritoryCodeNC StateTerritoryCode = "NC"
	StateTerritoryCodeND StateTerritoryCode = "ND"
	StateTerritoryCodeNE StateTerritoryCode = "NE"
	StateTerritoryCodeNH StateTerritoryCode = "NH"
	StateTerritoryCodeNJ StateTerritoryCode = "NJ"
	StateTerritoryCodeNM StateTerritoryCode = "NM"
	StateTerritoryCodeNV StateTerritoryCode = "NV"
	StateTerritoryCodeNY StateTerritoryCode = "NY"
	StateTerritoryCodeOH StateTerritoryCode = "OH"
	StateTerritoryCodeOK StateTerritoryCode = "OK"
	StateTerritoryCodeOR StateTerritoryCode = "OR"
	StateTerritoryCodePA StateTerritoryCode = "PA"
	StateTerritoryCodePR StateTerritoryCode = "PR"
	StateTerritoryCodePW StateTerritoryCode = "PW"
	StateTerritoryCodeRI StateTerritoryCode = "RI"
	StateTerritoryCodeSC StateTerritoryCode = "SC"
	StateTerritoryCodeSD StateTerritoryCode = "SD"
	StateTerritoryCodeTN StateTerritoryCode = "TN"
	StateTerritoryCodeTX StateTerritoryCode = "TX"
	StateTerritoryCodeUT StateTerritoryCode = "UT"
	StateTerritoryCodeVA StateTerritoryCode = "VA"
	StateTerritoryCodeVI StateTerritoryCode = "VI"
	StateTerritoryCodeVT StateTerritoryCode = "VT"
	StateTerritoryCodeWA StateTerritoryCode = "WA"
	StateTerritoryCodeWI StateTerritoryCode = "WI"
	StateTerritoryCodeWV StateTerritoryCode = "WV"
	StateTerritoryCodeWY StateTerritoryCode = "WY"
)

// Defines values for ZoneState1.
const (
	Empty ZoneState1 = ""
)

// Defines values for ZoneCollectionGeoJsonType.
const (
	FeatureCollection ZoneCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for ZoneForecastGeoJsonType.
const (
	ZoneForecastGeoJsonTypeFeature ZoneForecastGeoJsonType = "Feature"
)

// Defines values for ZoneGeoJsonType.
const (
	Feature ZoneGeoJsonType = "Feature"
)

// Defines values for AlertRegionType.
const (
	AlertRegionTypeLand   AlertRegionType = "land"
	AlertRegionTypeMarine AlertRegionType = "marine"
)

// Defines values for AlertsQueryParamsStatus.
const (
	AlertsQueryParamsStatusActual   AlertsQueryParamsStatus = "actual"
	AlertsQueryParamsStatusDraft    AlertsQueryParamsStatus = "draft"
	AlertsQueryParamsStatusExercise AlertsQueryParamsStatus = "exercise"
	AlertsQueryParamsStatusSystem   AlertsQueryParamsStatus = "system"
	AlertsQueryParamsStatusTest     AlertsQueryParamsStatus = "test"
)

// Defines values for AlertsQueryParamsMessageType.
const (
	AlertsQueryParamsMessageTypeAlert  AlertsQueryParamsMessageType = "alert"
	AlertsQueryParamsMessageTypeCancel AlertsQueryParamsMessageType = "cancel"
	AlertsQueryParamsMessageTypeUpdate AlertsQueryParamsMessageType = "update"
)

// Defines values for AlertsQueryParamsRegionType.
const (
	AlertsQueryParamsRegionTypeLand   AlertsQueryParamsRegionType = "land"
	AlertsQueryParamsRegionTypeMarine AlertsQueryParamsRegionType = "marine"
)

// Defines values for AlertsActiveParamsStatus.
const (
	Actual   AlertsActiveParamsStatus = "actual"
	Draft    AlertsActiveParamsStatus = "draft"
	Exercise AlertsActiveParamsStatus = "exercise"
	System   AlertsActiveParamsStatus = "system"
	Test     AlertsActiveParamsStatus = "test"
)

// Defines values for AlertsActiveParamsMessageType.
const (
	AlertsActiveParamsMessageTypeAlert  AlertsActiveParamsMessageType = "alert"
	AlertsActiveParamsMessageTypeCancel AlertsActiveParamsMessageType = "cancel"
	AlertsActiveParamsMessageTypeUpdate AlertsActiveParamsMessageType = "update"
)

// Defines values for AlertsActiveParamsRegionType.
const (
	Land   AlertsActiveParamsRegionType = "land"
	Marine AlertsActiveParamsRegionType = "marine"
)

// Defines values for GridpointForecastParamsFeatureFlags.
const (
	GridpointForecastParamsFeatureFlagsForecastTemperatureQv GridpointForecastParamsFeatureFlags = "forecast_temperature_qv"
	GridpointForecastParamsFeatureFlagsForecastWindSpeedQv   GridpointForecastParamsFeatureFlags = "forecast_wind_speed_qv"
)

// Defines values for GridpointForecastHourlyParamsFeatureFlags.
const (
	GridpointForecastHourlyParamsFeatureFlagsForecastTemperatureQv GridpointForecastHourlyParamsFeatureFlags = "forecast_temperature_qv"
	GridpointForecastHourlyParamsFeatureFlagsForecastWindSpeedQv   GridpointForecastHourlyParamsFeatureFlags = "forecast_wind_speed_qv"
)

// Defines values for ObsStationsParamsFeatureFlags.
const (
	ObsStationsParamsFeatureFlagsObsStationProvider ObsStationsParamsFeatureFlags = "obs_station_provider"
)

// Defines values for ObsStationParamsFeatureFlags.
const (
	ObsStationParamsFeatureFlagsObsStationProvider ObsStationParamsFeatureFlags = "obs_station_provider"
)

// ATSUIdentifier ATSU Identifier
type ATSUIdentifier = string

// Alert An object representing a public alert message.
// Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information.
// http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://vlab.noaa.gov/web/nws-common-alerting-protocol/cap-documentation
type Alert struct {
	// AffectedZones An array of API links for zones affected by the alert. This is an API-specific extension field and is not part of the CAP specification.
	AffectedZones *[]string `json:"affectedZones,omitempty"`

	// AreaDesc A textual description of the area affected by the alert.
	AreaDesc *string `json:"areaDesc,omitempty"`

	// Category The code denoting the category of the subject event of the alert message.
	Category  *AlertCategory      `json:"category,omitempty"`
	Certainty *AlertCertaintyEnum `json:"certainty,omitempty"`

	// Code The code denoting the special handling of the alert message.
	Code *string `json:"code,omitempty"`

	// Description The text describing the subject event of the alert message.
	Description *string `json:"description,omitempty"`

	// Effective The effective time of the information of the alert message.
	Effective *time.Time `json:"effective,omitempty"`

	// Ends The expected end time of the subject event of the alert message.
	Ends *time.Time `json:"ends"`

	// Event The text denoting the type of the subject event of the alert message.
	Event *string `json:"event,omitempty"`

	// EventCode System-specific code identifiying the event type of the alert message The keys in this object correspond to eventCode definitions in the NWS CAP specification.
	EventCode *map[string][]interface{} `json:"eventCode,omitempty"`

	// Expires The expiry time of the information of the alert message.
	Expires *time.Time `json:"expires,omitempty"`

	// Geocode Lists of codes for NWS public zones and counties affected by the alert.
	Geocode *struct {
		// SAME A list of SAME (Specific Area Message Encoding) codes for affected counties.
		SAME *[]string `json:"SAME,omitempty"`

		// UGC A list of NWS public zone or county identifiers.
		UGC *[]NWSZoneID `json:"UGC,omitempty"`
	} `json:"geocode,omitempty"`

	// Headline The text headline of the alert message.
	Headline *string `json:"headline"`

	// Id The identifier of the alert message.
	Id *AlertId `json:"id,omitempty"`

	// Instruction The text describing the recommended action to be taken by recipients of the alert message.
	Instruction *string `json:"instruction"`

	// Language The code denoting the language of the info sub-element of the alert message.
	Language    *string               `json:"language,omitempty"`
	MessageType *AlertMessageTypeEnum `json:"messageType,omitempty"`

	// Onset The expected time of the beginning of the subject event of the alert message.
	Onset *time.Time `json:"onset"`

	// Parameters System-specific additional parameters associated with the alert message.
	// The keys in this object correspond to parameter definitions in the NWS CAP specification.
	Parameters *map[string][]interface{} `json:"parameters,omitempty"`

	// References A list of prior alerts that this alert updates or replaces.
	References *[]struct {
		// Id An API link to the prior alert.
		Id *string `json:"@id,omitempty"`

		// Identifier The identifier of the alert message.
		Identifier *AlertId `json:"identifier,omitempty"`

		// Sender The sender of the prior alert.
		Sender *string `json:"sender,omitempty"`

		// Sent The time the prior alert was sent.
		Sent *time.Time `json:"sent,omitempty"`
	} `json:"references,omitempty"`

	// Response The code denoting the type of action recommended for the target audience.
	// This corresponds to responseType in the CAP specification.
	Response *AlertResponse `json:"response,omitempty"`

	// Scope The code denoting the intended distribution of the alert message.
	Scope *AlertScope `json:"scope,omitempty"`

	// Sender Email address of the NWS webmaster.
	Sender *string `json:"sender,omitempty"`

	// SenderName The text naming the originator of the alert message.
	SenderName *string `json:"senderName,omitempty"`

	// Sent The time of the origination of the alert message.
	Sent     *time.Time         `json:"sent,omitempty"`
	Severity *AlertSeverityEnum `json:"severity,omitempty"`
	Status   *AlertStatusEnum   `json:"status,omitempty"`
	Urgency  *AlertUrgencyEnum  `json:"urgency,omitempty"`

	// Web The identifier of the hyperlink associating additional information within the alert message.
	Web *string `json:"web,omitempty"`
}

// AlertCategory The code denoting the category of the subject event of the alert message.
type AlertCategory string

// AlertResponse The code denoting the type of action recommended for the target audience.
// This corresponds to responseType in the CAP specification.
type AlertResponse string

// AlertScope The code denoting the intended distribution of the alert message.
type AlertScope string

// AlertAtomEntry An alert entry in an Atom feed
type AlertAtomEntry struct {
	AreaDesc *string `json:"areaDesc,omitempty"`
	Author   *struct {
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`
	Category  *string              `json:"category,omitempty"`
	Certainty *string              `json:"certainty,omitempty"`
	Effective *string              `json:"effective,omitempty"`
	Event     *string              `json:"event,omitempty"`
	Expires   *string              `json:"expires,omitempty"`
	Geocode   *[]AlertXMLParameter `json:"geocode,omitempty"`
	Id        *string              `json:"id,omitempty"`
	MsgType   *string              `json:"msgType,omitempty"`
	Parameter *[]AlertXMLParameter `json:"parameter,omitempty"`
	Polygon   *string              `json:"polygon,omitempty"`
	Published *string              `json:"published,omitempty"`
	Sent      *string              `json:"sent,omitempty"`
	Severity  *string              `json:"severity,omitempty"`
	Status    *string              `json:"status,omitempty"`
	Summary   *string              `json:"summary,omitempty"`
	Updated   *string              `json:"updated,omitempty"`
	Urgency   *string              `json:"urgency,omitempty"`
}

// AlertAtomFeed An alert feed in Atom format
type AlertAtomFeed struct {
	Author *struct {
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`
	Entry     *[]AlertAtomEntry `json:"entry,omitempty"`
	Generator *string           `json:"generator,omitempty"`
	Id        *string           `json:"id,omitempty"`
	Title     *string           `json:"title,omitempty"`
	Updated   *string           `json:"updated,omitempty"`
}

// AlertCap defines model for AlertCap.
type AlertCap = map[string]interface{}

// AlertCertaintyEnum defines model for AlertCertaintyEnum.
type AlertCertaintyEnum string

// AlertCollection defines model for AlertCollection.
type AlertCollection struct {
	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`

	// Title A title describing the alert collection
	Title *string `json:"title,omitempty"`

	// Updated The last time a change occurred to this collection
	Updated *time.Time `json:"updated,omitempty"`
}

// AlertCollectionGeoJson defines model for AlertCollectionGeoJson.
type AlertCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		// Properties An object representing a public alert message.
		// Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information.
		// http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://vlab.noaa.gov/web/nws-common-alerting-protocol/cap-documentation
		Properties *Alert `json:"properties,omitempty"`
	} `json:"features"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`

	// Title A title describing the alert collection
	Title *string                    `json:"title,omitempty"`
	Type  AlertCollectionGeoJsonType `json:"type"`

	// Updated The last time a change occurred to this collection
	Updated *time.Time `json:"updated,omitempty"`
}

// AlertCollectionGeoJsonType defines model for AlertCollectionGeoJson.Type.
type AlertCollectionGeoJsonType string

// AlertCollectionJsonLd defines model for AlertCollectionJsonLd.
type AlertCollectionJsonLd struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]Alert       `json:"@graph,omitempty"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`

	// Title A title describing the alert collection
	Title *string `json:"title,omitempty"`

	// Updated The last time a change occurred to this collection
	Updated *time.Time `json:"updated,omitempty"`
}

// AlertGeoJson defines model for AlertGeoJson.
type AlertGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties An object representing a public alert message.
	// Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information.
	// http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://vlab.noaa.gov/web/nws-common-alerting-protocol/cap-documentation
	Properties Alert            `json:"properties"`
	Type       AlertGeoJsonType `json:"type"`
}

// AlertGeoJsonType defines model for AlertGeoJson.Type.
type AlertGeoJsonType string

// AlertId The identifier of the alert message.
type AlertId = string

// AlertJsonLd defines model for AlertJsonLd.
type AlertJsonLd struct {
	Graph *[]Alert `json:"@graph,omitempty"`
}

// AlertMessageTypeEnum defines model for AlertMessageTypeEnum.
type AlertMessageTypeEnum string

// AlertSeverityEnum defines model for AlertSeverityEnum.
type AlertSeverityEnum string

// AlertStatusEnum defines model for AlertStatusEnum.
type AlertStatusEnum string

// AlertUrgencyEnum defines model for AlertUrgencyEnum.
type AlertUrgencyEnum string

// AlertXMLParameter defines model for AlertXMLParameter.
type AlertXMLParameter struct {
	Value     *string `json:"value,omitempty"`
	ValueName *string `json:"valueName,omitempty"`
}

// AreaCode State/territory codes and marine area codes
type AreaCode struct {
	union json.RawMessage
}

// BinaryFile defines model for BinaryFile.
type BinaryFile = openapi_types.File

// CenterWeatherAdvisory defines model for CenterWeatherAdvisory.
type CenterWeatherAdvisory struct {
	// Cwsu Three-letter identifier for a Center Weather Service Unit (CWSU).
	Cwsu             *NWSCenterWeatherServiceUnitId `json:"cwsu,omitempty"`
	End              *time.Time                     `json:"end,omitempty"`
	Id               *string                        `json:"id,omitempty"`
	IssueTime        *time.Time                     `json:"issueTime,omitempty"`
	ObservedProperty *string                        `json:"observedProperty,omitempty"`
	Sequence         *int                           `json:"sequence,omitempty"`
	Start            *time.Time                     `json:"start,omitempty"`
	Text             *string                        `json:"text,omitempty"`
}

// CenterWeatherAdvisoryCollectionGeoJson defines model for CenterWeatherAdvisoryCollectionGeoJson.
type CenterWeatherAdvisoryCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *CenterWeatherAdvisory `json:"properties,omitempty"`
	} `json:"features"`
	Type CenterWeatherAdvisoryCollectionGeoJsonType `json:"type"`
}

// CenterWeatherAdvisoryCollectionGeoJsonType defines model for CenterWeatherAdvisoryCollectionGeoJson.Type.
type CenterWeatherAdvisoryCollectionGeoJsonType string

// CenterWeatherAdvisoryGeoJson defines model for CenterWeatherAdvisoryGeoJson.
type CenterWeatherAdvisoryGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry                 `json:"geometry"`
	Id         *string                          `json:"id,omitempty"`
	Properties CenterWeatherAdvisory            `json:"properties"`
	Type       CenterWeatherAdvisoryGeoJsonType `json:"type"`
}

// CenterWeatherAdvisoryGeoJsonType defines model for CenterWeatherAdvisoryGeoJson.Type.
type CenterWeatherAdvisoryGeoJsonType string

// CenterWeatherServiceUnitJsonLd defines model for CenterWeatherServiceUnitJsonLd.
type CenterWeatherServiceUnitJsonLd = Office

// Date Date (in YYYY-MM-DD format).
type Date = openapi_types.Date

// GeoJsonBoundingBox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonBoundingBox = []float32

// GeoJsonCoordinate A GeoJSON coordinate. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonCoordinate = []float32

// GeoJsonFeature A GeoJSON feature. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonFeature struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry       `json:"geometry"`
	Id         *string                `json:"id,omitempty"`
	Properties map[string]interface{} `json:"properties"`
	Type       GeoJsonFeatureType     `json:"type"`
}

// GeoJsonFeatureType defines model for GeoJsonFeature.Type.
type GeoJsonFeatureType string

// GeoJsonFeatureCollection A GeoJSON feature collection. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonFeatureCollection struct {
	Context  *JsonLdContext               `json:"@context,omitempty"`
	Features []GeoJsonFeature             `json:"features"`
	Type     GeoJsonFeatureCollectionType `json:"type"`
}

// GeoJsonFeatureCollectionType defines model for GeoJsonFeatureCollection.Type.
type GeoJsonFeatureCollectionType string

// GeoJsonGeometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonGeometry struct {
	union json.RawMessage
}

// GeoJsonGeometry0 defines model for .
type GeoJsonGeometry0 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox *GeoJsonBoundingBox `json:"bbox,omitempty"`

	// Coordinates A GeoJSON coordinate. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Coordinates GeoJsonCoordinate    `json:"coordinates"`
	Type        GeoJsonGeometry0Type `json:"type"`
}

// GeoJsonGeometry0Type defines model for GeoJsonGeometry.0.Type.
type GeoJsonGeometry0Type string

// GeoJsonGeometry1 defines model for .
type GeoJsonGeometry1 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox *GeoJsonBoundingBox `json:"bbox,omitempty"`

	// Coordinates A GeoJSON line string. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Coordinates GeoJsonLineString    `json:"coordinates"`
	Type        GeoJsonGeometry1Type `json:"type"`
}

// GeoJsonGeometry1Type defines model for GeoJsonGeometry.1.Type.
type GeoJsonGeometry1Type string

// GeoJsonGeometry2 defines model for .
type GeoJsonGeometry2 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox *GeoJsonBoundingBox `json:"bbox,omitempty"`

	// Coordinates A GeoJSON polygon. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Coordinates GeoJsonPolygon       `json:"coordinates"`
	Type        GeoJsonGeometry2Type `json:"type"`
}

// GeoJsonGeometry2Type defines model for GeoJsonGeometry.2.Type.
type GeoJsonGeometry2Type string

// GeoJsonGeometry3 defines model for .
type GeoJsonGeometry3 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox        *GeoJsonBoundingBox  `json:"bbox,omitempty"`
	Coordinates []GeoJsonCoordinate  `json:"coordinates"`
	Type        GeoJsonGeometry3Type `json:"type"`
}

// GeoJsonGeometry3Type defines model for GeoJsonGeometry.3.Type.
type GeoJsonGeometry3Type string

// GeoJsonGeometry4 defines model for .
type GeoJsonGeometry4 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox        *GeoJsonBoundingBox  `json:"bbox,omitempty"`
	Coordinates []GeoJsonLineString  `json:"coordinates"`
	Type        GeoJsonGeometry4Type `json:"type"`
}

// GeoJsonGeometry4Type defines model for GeoJsonGeometry.4.Type.
type GeoJsonGeometry4Type string

// GeoJsonGeometry5 defines model for .
type GeoJsonGeometry5 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox        *GeoJsonBoundingBox  `json:"bbox,omitempty"`
	Coordinates []GeoJsonPolygon     `json:"coordinates"`
	Type        GeoJsonGeometry5Type `json:"type"`
}

// GeoJsonGeometry5Type defines model for GeoJsonGeometry.5.Type.
type GeoJsonGeometry5Type string

// GeoJsonLineString A GeoJSON line string. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonLineString = []GeoJsonCoordinate

// GeoJsonPolygon A GeoJSON polygon. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonPolygon = [][]GeoJsonCoordinate

// GeometryString A geometry represented in Well-Known Text (WKT) format.
type GeometryString = string

// Gridpoint Raw forecast data for a 2.5km grid square.
// This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
// * temperature
// * dewpoint
// * maxTemperature
// * minTemperature
// * relativeHumidity
// * apparentTemperature
// * heatIndex
// * windChill
// * wetBulbGlobeTemperature
// * skyCover
// * windDirection
// * windSpeed
// * windGust
// * weather
// * hazards: Watch and advisory products in effect
// * probabilityOfPrecipitation
// * quantitativePrecipitation
// * iceAccumulation
// * snowfallAmount
// * snowLevel
// * ceilingHeight
// * visibility
// * transportWindSpeed
// * transportWindDirection
// * mixingHeight
// * hainesIndex
// * lightningActivityLevel
// * twentyFootWindSpeed
// * twentyFootWindDirection
// * waveHeight
// * wavePeriod
// * waveDirection
// * primarySwellHeight
// * primarySwellDirection
// * secondarySwellHeight
// * secondarySwellDirection
// * wavePeriod2
// * windWaveHeight
// * dispersionIndex
// * pressure: Barometric pressure
// * probabilityOfTropicalStormWinds
// * probabilityOfHurricaneWinds
// * potentialOf15mphWinds
// * potentialOf25mphWinds
// * potentialOf35mphWinds
// * potentialOf45mphWinds
// * potentialOf20mphWindGusts
// * potentialOf30mphWindGusts
// * potentialOf40mphWindGusts
// * potentialOf50mphWindGusts
// * potentialOf60mphWindGusts
// * grasslandFireDangerIndex
// * probabilityOfThunder
// * davisStabilityIndex
// * atmosphericDispersionIndex
// * lowVisibilityOccurrenceRiskIndex
// * stability
// * redFlagThreatIndex
type Gridpoint struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Id      *string        `json:"@id,omitempty"`
	Type    *GridpointType `json:"@type,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation      *QuantitativeValue `json:"elevation,omitempty"`
	ForecastOffice *string            `json:"forecastOffice,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`
	GridId   *string         `json:"gridId,omitempty"`
	GridX    *int            `json:"gridX,omitempty"`
	GridY    *int            `json:"gridY,omitempty"`
	Hazards  *struct {
		Values []struct {
			// ValidTime A time interval in ISO 8601 format. This can be one of:
			//
			//     1. Start and end time
			//     2. Start time and duration
			//     3. Duration and end time
			// The string "NOW" can also be used in place of a start/end time.
			ValidTime ISO8601Interval `json:"validTime"`
			Value     []struct {
				// EventNumber Event number. If this hazard refers to a national or regional center product (such as a Storm Prediction Center convective watch), this value will be the sequence number of that product.
				EventNumber *int `json:"event_number"`

				// Phenomenon Hazard code. This value will correspond to a P-VTEC phenomenon code as defined in NWS Directive 10-1703.
				Phenomenon string `json:"phenomenon"`

				// Significance Significance code. This value will correspond to a P-VTEC significance code as defined in NWS Directive 10-1703.
				// This will most frequently be "A" for a watch or "Y" for an advisory.
				Significance string `json:"significance"`
			} `json:"value"`
		} `json:"values"`
	} `json:"hazards,omitempty"`
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
	Weather    *struct {
		Values []struct {
			// ValidTime A time interval in ISO 8601 format. This can be one of:
			//
			//     1. Start and end time
			//     2. Start time and duration
			//     3. Duration and end time
			// The string "NOW" can also be used in place of a start/end time.
			ValidTime ISO8601Interval `json:"validTime"`
			Value     []struct {
				Attributes []GridpointWeatherValuesValueAttributes `json:"attributes"`
				Coverage   *GridpointWeatherValuesValueCoverage    `json:"coverage"`
				Intensity  *GridpointWeatherValuesValueIntensity   `json:"intensity"`

				// Visibility A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
				Visibility QuantitativeValue                   `json:"visibility"`
				Weather    *GridpointWeatherValuesValueWeather `json:"weather"`
			} `json:"value"`
		} `json:"values"`
	} `json:"weather,omitempty"`
	AdditionalProperties map[string]GridpointQuantitativeValueLayer `json:"-"`
}

// GridpointType defines model for Gridpoint.Type.
type GridpointType string

// GridpointWeatherValuesValueAttributes defines model for Gridpoint.Weather.Values.Value.Attributes.
type GridpointWeatherValuesValueAttributes string

// GridpointWeatherValuesValueCoverage defines model for Gridpoint.Weather.Values.Value.Coverage.
type GridpointWeatherValuesValueCoverage string

// GridpointWeatherValuesValueIntensity defines model for Gridpoint.Weather.Values.Value.Intensity.
type GridpointWeatherValuesValueIntensity string

// GridpointWeatherValuesValueWeather defines model for Gridpoint.Weather.Values.Value.Weather.
type GridpointWeatherValuesValueWeather string

// Gridpoint12hForecast A multi-day forecast for a 2.5km grid square.
type Gridpoint12hForecast struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// ForecastGenerator The internal generator class used to create the forecast text (used for NWS debugging).
	ForecastGenerator *string `json:"forecastGenerator,omitempty"`

	// GeneratedAt The time this forecast data was generated.
	GeneratedAt *time.Time `json:"generatedAt,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]Gridpoint12hForecastPeriod `json:"periods,omitempty"`

	// Units Denotes the units used in the textual portions of the forecast.
	Units *GridpointForecastUnits `json:"units,omitempty"`

	// UpdateTime The last update time of the data this forecast was generated from.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
}

// Gridpoint12hForecastGeoJson defines model for Gridpoint12hForecastGeoJson.
type Gridpoint12hForecastGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties A multi-day forecast for a 2.5km grid square.
	Properties Gridpoint12hForecast            `json:"properties"`
	Type       Gridpoint12hForecastGeoJsonType `json:"type"`
}

// Gridpoint12hForecastGeoJsonType defines model for Gridpoint12hForecastGeoJson.Type.
type Gridpoint12hForecastGeoJsonType string

// Gridpoint12hForecastJsonLd defines model for Gridpoint12hForecastJsonLd.
type Gridpoint12hForecastJsonLd struct {
	Context JsonLdContext `json:"@context"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// ForecastGenerator The internal generator class used to create the forecast text (used for NWS debugging).
	ForecastGenerator *string `json:"forecastGenerator,omitempty"`

	// GeneratedAt The time this forecast data was generated.
	GeneratedAt *time.Time `json:"generatedAt,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]Gridpoint12hForecastPeriod `json:"periods,omitempty"`

	// Units Denotes the units used in the textual portions of the forecast.
	Units *GridpointForecastUnits `json:"units,omitempty"`

	// UpdateTime The last update time of the data this forecast was generated from.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
}

// Gridpoint12hForecastPeriod An object containing forecast information for a specific time period (generally 12-hour or 1-hour).
type Gridpoint12hForecastPeriod struct {
	// DetailedForecast A detailed textual forecast for the period.
	DetailedForecast *string `json:"detailedForecast,omitempty"`

	// EndTime The ending time that this forecast period is valid for.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Icon A link to an icon representing the forecast summary.
	// Deprecated:
	Icon *string `json:"icon,omitempty"`

	// IsDaytime Indicates whether this period is daytime or nighttime.
	IsDaytime *bool `json:"isDaytime,omitempty"`

	// Name A textual identifier for the period. This value will not be present for hourly forecasts.
	Name *string `json:"name,omitempty"`

	// Number Sequential period number.
	Number *int `json:"number,omitempty"`

	// ProbabilityOfPrecipitation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	ProbabilityOfPrecipitation *QuantitativeValue `json:"probabilityOfPrecipitation,omitempty"`

	// ShortForecast A brief textual forecast summary for the period.
	ShortForecast *string `json:"shortForecast,omitempty"`

	// StartTime The starting time that this forecast period is valid for.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Temperature High/low temperature for the period, depending on whether the period is day or night.
	// This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
	Temperature *Gridpoint12hForecastPeriod_Temperature `json:"temperature,omitempty"`

	// TemperatureTrend If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
	TemperatureTrend *Gridpoint12hForecastPeriodTemperatureTrend `json:"temperatureTrend"`

	// TemperatureUnit The unit of the temperature value (Fahrenheit or Celsius).
	// This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
	// Deprecated:
	TemperatureUnit *Gridpoint12hForecastPeriodTemperatureUnit `json:"temperatureUnit,omitempty"`

	// WindDirection The prevailing direction of the wind for the period, using a 16-point compass.
	WindDirection *Gridpoint12hForecastPeriodWindDirection `json:"windDirection,omitempty"`

	// WindGust Peak wind gust for the period.
	// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
	WindGust *Gridpoint12hForecastPeriod_WindGust `json:"windGust"`

	// WindSpeed Wind speed for the period.
	// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
	WindSpeed *Gridpoint12hForecastPeriod_WindSpeed `json:"windSpeed,omitempty"`
}

// Gridpoint12hForecastPeriodTemperature1 defines model for .
type Gridpoint12hForecastPeriodTemperature1 = int

// Gridpoint12hForecastPeriod_Temperature High/low temperature for the period, depending on whether the period is day or night.
// This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
type Gridpoint12hForecastPeriod_Temperature struct {
	union json.RawMessage
}

// Gridpoint12hForecastPeriodTemperatureTrend If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
type Gridpoint12hForecastPeriodTemperatureTrend string

// Gridpoint12hForecastPeriodTemperatureUnit The unit of the temperature value (Fahrenheit or Celsius).
// This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
type Gridpoint12hForecastPeriodTemperatureUnit string

// Gridpoint12hForecastPeriodWindDirection The prevailing direction of the wind for the period, using a 16-point compass.
type Gridpoint12hForecastPeriodWindDirection string

// Gridpoint12hForecastPeriodWindGust1 defines model for .
type Gridpoint12hForecastPeriodWindGust1 = string

// Gridpoint12hForecastPeriod_WindGust Peak wind gust for the period.
// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
type Gridpoint12hForecastPeriod_WindGust struct {
	union json.RawMessage
}

// Gridpoint12hForecastPeriodWindSpeed1 defines model for .
type Gridpoint12hForecastPeriodWindSpeed1 = string

// Gridpoint12hForecastPeriod_WindSpeed Wind speed for the period.
// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
type Gridpoint12hForecastPeriod_WindSpeed struct {
	union json.RawMessage
}

// GridpointForecastUnits Denotes the units used in the textual portions of the forecast.
type GridpointForecastUnits string

// GridpointGeoJson defines model for GridpointGeoJson.
type GridpointGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties Raw forecast data for a 2.5km grid square.
	// This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
	// * temperature
	// * dewpoint
	// * maxTemperature
	// * minTemperature
	// * relativeHumidity
	// * apparentTemperature
	// * heatIndex
	// * windChill
	// * wetBulbGlobeTemperature
	// * skyCover
	// * windDirection
	// * windSpeed
	// * windGust
	// * weather
	// * hazards: Watch and advisory products in effect
	// * probabilityOfPrecipitation
	// * quantitativePrecipitation
	// * iceAccumulation
	// * snowfallAmount
	// * snowLevel
	// * ceilingHeight
	// * visibility
	// * transportWindSpeed
	// * transportWindDirection
	// * mixingHeight
	// * hainesIndex
	// * lightningActivityLevel
	// * twentyFootWindSpeed
	// * twentyFootWindDirection
	// * waveHeight
	// * wavePeriod
	// * waveDirection
	// * primarySwellHeight
	// * primarySwellDirection
	// * secondarySwellHeight
	// * secondarySwellDirection
	// * wavePeriod2
	// * windWaveHeight
	// * dispersionIndex
	// * pressure: Barometric pressure
	// * probabilityOfTropicalStormWinds
	// * probabilityOfHurricaneWinds
	// * potentialOf15mphWinds
	// * potentialOf25mphWinds
	// * potentialOf35mphWinds
	// * potentialOf45mphWinds
	// * potentialOf20mphWindGusts
	// * potentialOf30mphWindGusts
	// * potentialOf40mphWindGusts
	// * potentialOf50mphWindGusts
	// * potentialOf60mphWindGusts
	// * grasslandFireDangerIndex
	// * probabilityOfThunder
	// * davisStabilityIndex
	// * atmosphericDispersionIndex
	// * lowVisibilityOccurrenceRiskIndex
	// * stability
	// * redFlagThreatIndex
	Properties Gridpoint            `json:"properties"`
	Type       GridpointGeoJsonType `json:"type"`
}

// GridpointGeoJsonType defines model for GridpointGeoJson.Type.
type GridpointGeoJsonType string

// GridpointHourlyForecast An hourly forecast for a 2.5km grid square.
type GridpointHourlyForecast struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// ForecastGenerator The internal generator class used to create the forecast text (used for NWS debugging).
	ForecastGenerator *string `json:"forecastGenerator,omitempty"`

	// GeneratedAt The time this forecast data was generated.
	GeneratedAt *time.Time `json:"generatedAt,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]GridpointHourlyForecastPeriod `json:"periods,omitempty"`

	// Units Denotes the units used in the textual portions of the forecast.
	Units *GridpointForecastUnits `json:"units,omitempty"`

	// UpdateTime The last update time of the data this forecast was generated from.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
}

// GridpointHourlyForecastGeoJson defines model for GridpointHourlyForecastGeoJson.
type GridpointHourlyForecastGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties An hourly forecast for a 2.5km grid square.
	Properties GridpointHourlyForecast            `json:"properties"`
	Type       GridpointHourlyForecastGeoJsonType `json:"type"`
}

// GridpointHourlyForecastGeoJsonType defines model for GridpointHourlyForecastGeoJson.Type.
type GridpointHourlyForecastGeoJsonType string

// GridpointHourlyForecastJsonLd defines model for GridpointHourlyForecastJsonLd.
type GridpointHourlyForecastJsonLd struct {
	Context JsonLdContext `json:"@context"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// ForecastGenerator The internal generator class used to create the forecast text (used for NWS debugging).
	ForecastGenerator *string `json:"forecastGenerator,omitempty"`

	// GeneratedAt The time this forecast data was generated.
	GeneratedAt *time.Time `json:"generatedAt,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]GridpointHourlyForecastPeriod `json:"periods,omitempty"`

	// Units Denotes the units used in the textual portions of the forecast.
	Units *GridpointForecastUnits `json:"units,omitempty"`

	// UpdateTime The last update time of the data this forecast was generated from.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
}

// GridpointHourlyForecastPeriod An object containing forecast information for a specific time period (generally 12-hour or 1-hour).
type GridpointHourlyForecastPeriod struct {
	// DetailedForecast A detailed textual forecast for the period.
	DetailedForecast *string `json:"detailedForecast,omitempty"`

	// Dewpoint A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Dewpoint *QuantitativeValue `json:"dewpoint,omitempty"`

	// EndTime The ending time that this forecast period is valid for.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Icon A link to an icon representing the forecast summary.
	// Deprecated:
	Icon *string `json:"icon,omitempty"`

	// IsDaytime Indicates whether this period is daytime or nighttime.
	IsDaytime *bool `json:"isDaytime,omitempty"`

	// Name A textual identifier for the period. This value will not be present for hourly forecasts.
	Name *string `json:"name,omitempty"`

	// Number Sequential period number.
	Number *int `json:"number,omitempty"`

	// ProbabilityOfPrecipitation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	ProbabilityOfPrecipitation *QuantitativeValue `json:"probabilityOfPrecipitation,omitempty"`

	// RelativeHumidity A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	RelativeHumidity *QuantitativeValue `json:"relativeHumidity,omitempty"`

	// ShortForecast A brief textual forecast summary for the period.
	ShortForecast *string `json:"shortForecast,omitempty"`

	// StartTime The starting time that this forecast period is valid for.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Temperature High/low temperature for the period, depending on whether the period is day or night.
	// This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
	Temperature *GridpointHourlyForecastPeriod_Temperature `json:"temperature,omitempty"`

	// TemperatureTrend If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
	TemperatureTrend *GridpointHourlyForecastPeriodTemperatureTrend `json:"temperatureTrend"`

	// TemperatureUnit The unit of the temperature value (Fahrenheit or Celsius).
	// This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
	// Deprecated:
	TemperatureUnit *GridpointHourlyForecastPeriodTemperatureUnit `json:"temperatureUnit,omitempty"`

	// WindDirection The prevailing direction of the wind for the period, using a 16-point compass.
	WindDirection *GridpointHourlyForecastPeriodWindDirection `json:"windDirection,omitempty"`

	// WindGust Peak wind gust for the period.
	// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
	WindGust *GridpointHourlyForecastPeriod_WindGust `json:"windGust"`

	// WindSpeed Wind speed for the period.
	// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
	WindSpeed *GridpointHourlyForecastPeriod_WindSpeed `json:"windSpeed,omitempty"`
}

// GridpointHourlyForecastPeriodTemperature1 defines model for .
type GridpointHourlyForecastPeriodTemperature1 = int

// GridpointHourlyForecastPeriod_Temperature High/low temperature for the period, depending on whether the period is day or night.
// This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
type GridpointHourlyForecastPeriod_Temperature struct {
	union json.RawMessage
}

// GridpointHourlyForecastPeriodTemperatureTrend If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
type GridpointHourlyForecastPeriodTemperatureTrend string

// GridpointHourlyForecastPeriodTemperatureUnit The unit of the temperature value (Fahrenheit or Celsius).
// This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
type GridpointHourlyForecastPeriodTemperatureUnit string

// GridpointHourlyForecastPeriodWindDirection The prevailing direction of the wind for the period, using a 16-point compass.
type GridpointHourlyForecastPeriodWindDirection string

// GridpointHourlyForecastPeriodWindGust1 defines model for .
type GridpointHourlyForecastPeriodWindGust1 = string

// GridpointHourlyForecastPeriod_WindGust Peak wind gust for the period.
// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
type GridpointHourlyForecastPeriod_WindGust struct {
	union json.RawMessage
}

// GridpointHourlyForecastPeriodWindSpeed1 defines model for .
type GridpointHourlyForecastPeriodWindSpeed1 = string

// GridpointHourlyForecastPeriod_WindSpeed Wind speed for the period.
// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
type GridpointHourlyForecastPeriod_WindSpeed struct {
	union json.RawMessage
}

// GridpointJsonLd Raw forecast data for a 2.5km grid square.
// This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
// * temperature
// * dewpoint
// * maxTemperature
// * minTemperature
// * relativeHumidity
// * apparentTemperature
// * heatIndex
// * windChill
// * wetBulbGlobeTemperature
// * skyCover
// * windDirection
// * windSpeed
// * windGust
// * weather
// * hazards: Watch and advisory products in effect
// * probabilityOfPrecipitation
// * quantitativePrecipitation
// * iceAccumulation
// * snowfallAmount
// * snowLevel
// * ceilingHeight
// * visibility
// * transportWindSpeed
// * transportWindDirection
// * mixingHeight
// * hainesIndex
// * lightningActivityLevel
// * twentyFootWindSpeed
// * twentyFootWindDirection
// * waveHeight
// * wavePeriod
// * waveDirection
// * primarySwellHeight
// * primarySwellDirection
// * secondarySwellHeight
// * secondarySwellDirection
// * wavePeriod2
// * windWaveHeight
// * dispersionIndex
// * pressure: Barometric pressure
// * probabilityOfTropicalStormWinds
// * probabilityOfHurricaneWinds
// * potentialOf15mphWinds
// * potentialOf25mphWinds
// * potentialOf35mphWinds
// * potentialOf45mphWinds
// * potentialOf20mphWindGusts
// * potentialOf30mphWindGusts
// * potentialOf40mphWindGusts
// * potentialOf50mphWindGusts
// * potentialOf60mphWindGusts
// * grasslandFireDangerIndex
// * probabilityOfThunder
// * davisStabilityIndex
// * atmosphericDispersionIndex
// * lowVisibilityOccurrenceRiskIndex
// * stability
// * redFlagThreatIndex
type GridpointJsonLd = Gridpoint

// GridpointQuantitativeValueLayer A gridpoint layer consisting of quantitative values (numeric values with associated units of measure).
type GridpointQuantitativeValueLayer struct {
	// Uom A string denoting a unit of measure, expressed in the format "{unit}" or "{namespace}:{unit}".
	// Units with the namespace "wmo" or "wmoUnit" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}.
	// Units with the namespace "nwsUnit" are currently custom and do not align to any standard.
	// Units with no namespace or the namespace "uc" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156).
	// Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
	Uom    *UnitOfMeasure `json:"uom,omitempty"`
	Values []struct {
		// ValidTime A time interval in ISO 8601 format. This can be one of:
		//
		//     1. Start and end time
		//     2. Start time and duration
		//     3. Duration and end time
		// The string "NOW" can also be used in place of a start/end time.
		ValidTime ISO8601Interval `json:"validTime"`
		Value     *float32        `json:"value"`
	} `json:"values"`
}

// ISO8601Duration A time duration in ISO 8601 format.
type ISO8601Duration = string

// ISO8601Interval A time interval in ISO 8601 format. This can be one of:
//
//  1. Start and end time
//  2. Start time and duration
//  3. Duration and end time
//
// The string "NOW" can also be used in place of a start/end time.
type ISO8601Interval struct {
	union json.RawMessage
}

// ISO8601Interval0 defines model for .
type ISO8601Interval0 = string

// ISO8601Interval1 defines model for .
type ISO8601Interval1 = string

// ISO8601Interval2 defines model for .
type ISO8601Interval2 = string

// JsonLdContext defines model for JsonLdContext.
type JsonLdContext struct {
	union json.RawMessage
}

// JsonLdContext0 defines model for .
type JsonLdContext0 = []interface{}

// JsonLdContext1 defines model for .
type JsonLdContext1 = map[string]interface{}

// LandRegionCode Land region code. These correspond to the six NWS regional headquarters:
// * AR: Alaska Region
// * CR: Central Region
// * ER: Eastern Region
// * PR: Pacific Region
// * SR: Southern Region
// * WR: Western Region
type LandRegionCode string

// MarineAreaCode Marine area code as defined in NWS Directive 10-302:
// * AM: Western North Atlantic Ocean and along U.S. East Coast south of Currituck Beach Light NC following the coastline into Gulf of Mexico to Ocean Reef FL including the Caribbean
// * AN: Western North Atlantic Ocean and along U.S. East Coast from Canadian border south to Currituck Beach Light NC
// * GM: Gulf of Mexico and along the U.S. Gulf Coast from the Mexican border to Ocean Reef FL
// * LC: Lake St. Clair
// * LE: Lake Erie
// * LH: Lake Huron
// * LM: Lake Michigan
// * LO: Lake Ontario
// * LS: Lake Superior
// * PH: Central Pacific Ocean including Hawaiian waters
// * PK: North Pacific Ocean near Alaska and along Alaska coastline including the Bering Sea and the Gulf of Alaska
// * PM: Western Pacific Ocean including Mariana Island waters
// * PS: South Central Pacific Ocean including American Samoa waters
// * PZ: Eastern North Pacific Ocean and along U.S. West Coast from Canadian border to Mexican border
// * SL: St. Lawrence River above St. Regis
type MarineAreaCode string

// MarineRegionCode Marine region code. These are groups of marine areas combined.
// * AL: Alaska waters (PK)
// * AT: Atlantic Ocean (AM, AN)
// * GL: Great Lakes (LC, LE, LH, LM, LO, LS, SL)
// * GM: Gulf of Mexico (GM)
// * PA: Eastern Pacific Ocean and U.S. West Coast (PZ)
// * PI: Central and Western Pacific (PH, PM, PS)
type MarineRegionCode string

// MetarPhenomenon An object representing a decoded METAR phenomenon string.
type MetarPhenomenon struct {
	InVicinity *bool                     `json:"inVicinity,omitempty"`
	Intensity  *MetarPhenomenonIntensity `json:"intensity"`
	Modifier   *MetarPhenomenonModifier  `json:"modifier"`
	RawString  string                    `json:"rawString"`
	Weather    MetarPhenomenonWeather    `json:"weather"`
}

// MetarPhenomenonIntensity defines model for MetarPhenomenon.Intensity.
type MetarPhenomenonIntensity string

// MetarPhenomenonModifier defines model for MetarPhenomenon.Modifier.
type MetarPhenomenonModifier string

// MetarPhenomenonWeather defines model for MetarPhenomenon.Weather.
type MetarPhenomenonWeather string

// MetarSkyCoverage defines model for MetarSkyCoverage.
type MetarSkyCoverage string

// NWSCenterWeatherServiceUnitId Three-letter identifier for a Center Weather Service Unit (CWSU).
type NWSCenterWeatherServiceUnitId string

// NWSForecastOfficeId Three-letter identifier for a NWS office.
type NWSForecastOfficeId string

// NWSNationalHQId Three-letter identifier for NWS National HQ.
type NWSNationalHQId string

// NWSOfficeId defines model for NWSOfficeId.
type NWSOfficeId struct {
	union json.RawMessage
}

// NWSRegionalHQId Three-letter identifier for a NWS Regional HQ.
type NWSRegionalHQId string

// NWSZoneID UGC identifier for a NWS forecast zone or county.
// The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations).
// The third letter will be Z for public/fire zone or C for county.
type NWSZoneID = string

// NWSZoneType defines model for NWSZoneType.
type NWSZoneType string

// Observation defines model for Observation.
type Observation struct {
	Context *JsonLdContext   `json:"@context,omitempty"`
	Id      *string          `json:"@id,omitempty"`
	Type    *ObservationType `json:"@type,omitempty"`

	// BarometricPressure A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	BarometricPressure *QuantitativeValue `json:"barometricPressure,omitempty"`
	CloudLayers        *[]struct {
		Amount MetarSkyCoverage `json:"amount"`

		// Base A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
		Base QuantitativeValue `json:"base"`
	} `json:"cloudLayers"`

	// Dewpoint A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Dewpoint *QuantitativeValue `json:"dewpoint,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// HeatIndex A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	HeatIndex *QuantitativeValue `json:"heatIndex,omitempty"`
	// Deprecated:
	Icon *string `json:"icon"`

	// MaxTemperatureLast24Hours A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	MaxTemperatureLast24Hours *QuantitativeValue `json:"maxTemperatureLast24Hours,omitempty"`

	// MinTemperatureLast24Hours A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	MinTemperatureLast24Hours *QuantitativeValue `json:"minTemperatureLast24Hours,omitempty"`

	// PrecipitationLast3Hours A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	PrecipitationLast3Hours *QuantitativeValue `json:"precipitationLast3Hours,omitempty"`

	// PrecipitationLast6Hours A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	PrecipitationLast6Hours *QuantitativeValue `json:"precipitationLast6Hours,omitempty"`

	// PrecipitationLastHour A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	PrecipitationLastHour *QuantitativeValue `json:"precipitationLastHour,omitempty"`
	PresentWeather        *[]MetarPhenomenon `json:"presentWeather,omitempty"`
	RawMessage            *string            `json:"rawMessage,omitempty"`

	// RelativeHumidity A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	RelativeHumidity *QuantitativeValue `json:"relativeHumidity,omitempty"`

	// SeaLevelPressure A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	SeaLevelPressure *QuantitativeValue `json:"seaLevelPressure,omitempty"`
	Station          *string            `json:"station,omitempty"`

	// Temperature A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Temperature     *QuantitativeValue `json:"temperature,omitempty"`
	TextDescription *string            `json:"textDescription,omitempty"`
	Timestamp       *time.Time         `json:"timestamp,omitempty"`

	// Visibility A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Visibility *QuantitativeValue `json:"visibility,omitempty"`

	// WindChill A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindChill *QuantitativeValue `json:"windChill,omitempty"`

	// WindDirection A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindDirection *QuantitativeValue `json:"windDirection,omitempty"`

	// WindGust A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindGust *QuantitativeValue `json:"windGust,omitempty"`

	// WindSpeed A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindSpeed *QuantitativeValue `json:"windSpeed,omitempty"`
}

// ObservationType defines model for Observation.Type.
type ObservationType string

// ObservationCollectionGeoJson defines model for ObservationCollectionGeoJson.
type ObservationCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *Observation `json:"properties,omitempty"`
	} `json:"features"`
	Type ObservationCollectionGeoJsonType `json:"type"`
}

// ObservationCollectionGeoJsonType defines model for ObservationCollectionGeoJson.Type.
type ObservationCollectionGeoJsonType string

// ObservationCollectionJsonLd defines model for ObservationCollectionJsonLd.
type ObservationCollectionJsonLd struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]Observation `json:"@graph,omitempty"`
}

// ObservationGeoJson defines model for ObservationGeoJson.
type ObservationGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry       `json:"geometry"`
	Id         *string                `json:"id,omitempty"`
	Properties Observation            `json:"properties"`
	Type       ObservationGeoJsonType `json:"type"`
}

// ObservationGeoJsonType defines model for ObservationGeoJson.Type.
type ObservationGeoJsonType string

// ObservationJsonLd defines model for ObservationJsonLd.
type ObservationJsonLd = Observation

// ObservationStation defines model for ObservationStation.
type ObservationStation struct {
	Context *JsonLdContext          `json:"@context,omitempty"`
	Id      *string                 `json:"@id,omitempty"`
	Type    *ObservationStationType `json:"@type,omitempty"`

	// Bearing A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Bearing *QuantitativeValue `json:"bearing,omitempty"`

	// County A link to the NWS county zone containing this station.
	County *string `json:"county,omitempty"`

	// Distance A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Distance *QuantitativeValue `json:"distance,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// FireWeatherZone A link to the NWS fire weather forecast zone containing this station.
	FireWeatherZone *string `json:"fireWeatherZone,omitempty"`

	// Forecast A link to the NWS public forecast zone containing this station.
	Forecast *string `json:"forecast,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`
	Name     *string         `json:"name,omitempty"`

	// Provider The data provider for this station. E.g., "ASOS," "MesoWest," etc.
	Provider          *string `json:"provider,omitempty"`
	StationIdentifier *string `json:"stationIdentifier,omitempty"`

	// SubProvider The sub-provider of for this station. E.g., "FAA," "DOT," etc.
	SubProvider *string `json:"subProvider,omitempty"`
	TimeZone    *string `json:"timeZone,omitempty"`
}

// ObservationStationType defines model for ObservationStation.Type.
type ObservationStationType string

// ObservationStationCollectionGeoJson defines model for ObservationStationCollectionGeoJson.
type ObservationStationCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *ObservationStation `json:"properties,omitempty"`
	} `json:"features"`
	ObservationStations *[]string `json:"observationStations,omitempty"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo                         `json:"pagination,omitempty"`
	Type       ObservationStationCollectionGeoJsonType `json:"type"`
}

// ObservationStationCollectionGeoJsonType defines model for ObservationStationCollectionGeoJson.Type.
type ObservationStationCollectionGeoJsonType string

// ObservationStationCollectionJsonLd defines model for ObservationStationCollectionJsonLd.
type ObservationStationCollectionJsonLd struct {
	Context             *JsonLdContext        `json:"@context,omitempty"`
	Graph               *[]ObservationStation `json:"@graph,omitempty"`
	ObservationStations *[]string             `json:"observationStations,omitempty"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`
}

// ObservationStationGeoJson defines model for ObservationStationGeoJson.
type ObservationStationGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry              `json:"geometry"`
	Id         *string                       `json:"id,omitempty"`
	Properties ObservationStation            `json:"properties"`
	Type       ObservationStationGeoJsonType `json:"type"`
}

// ObservationStationGeoJsonType defines model for ObservationStationGeoJson.Type.
type ObservationStationGeoJsonType string

// ObservationStationJsonLd defines model for ObservationStationJsonLd.
type ObservationStationJsonLd struct {
	Context JsonLdContext                 `json:"@context"`
	Id      *string                       `json:"@id,omitempty"`
	Type    *ObservationStationJsonLdType `json:"@type,omitempty"`

	// Bearing A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Bearing *QuantitativeValue `json:"bearing,omitempty"`

	// County A link to the NWS county zone containing this station.
	County *string `json:"county,omitempty"`

	// Distance A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Distance *QuantitativeValue `json:"distance,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// FireWeatherZone A link to the NWS fire weather forecast zone containing this station.
	FireWeatherZone *string `json:"fireWeatherZone,omitempty"`

	// Forecast A link to the NWS public forecast zone containing this station.
	Forecast *string `json:"forecast,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`
	Name     *string         `json:"name,omitempty"`

	// Provider The data provider for this station. E.g., "ASOS," "MesoWest," etc.
	Provider          *string `json:"provider,omitempty"`
	StationIdentifier *string `json:"stationIdentifier,omitempty"`

	// SubProvider The sub-provider of for this station. E.g., "FAA," "DOT," etc.
	SubProvider *string `json:"subProvider,omitempty"`
	TimeZone    *string `json:"timeZone,omitempty"`
}

// ObservationStationJsonLdType defines model for ObservationStationJsonLd.Type.
type ObservationStationJsonLdType string

// Office defines model for Office.
type Office struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Type    *OfficeType    `json:"@type,omitempty"`
	Address *struct {
		Type            *OfficeAddressType `json:"@type,omitempty"`
		AddressLocality *string            `json:"addressLocality,omitempty"`
		AddressRegion   *string            `json:"addressRegion,omitempty"`
		PostalCode      *string            `json:"postalCode,omitempty"`
		StreetAddress   *string            `json:"streetAddress,omitempty"`
	} `json:"address,omitempty"`
	ApprovedObservationStations *[]string `json:"approvedObservationStations,omitempty"`
	Email                       *string   `json:"email,omitempty"`
	FaxNumber                   *string   `json:"faxNumber,omitempty"`
	Id                          *string   `json:"id,omitempty"`
	Name                        *string   `json:"name,omitempty"`
	NwsRegion                   *string   `json:"nwsRegion,omitempty"`
	ParentOrganization          *string   `json:"parentOrganization,omitempty"`
	ResponsibleCounties         *[]string `json:"responsibleCounties,omitempty"`
	ResponsibleFireZones        *[]string `json:"responsibleFireZones,omitempty"`
	ResponsibleForecastZones    *[]string `json:"responsibleForecastZones,omitempty"`
	SameAs                      *string   `json:"sameAs,omitempty"`
	Telephone                   *string   `json:"telephone,omitempty"`
}

// OfficeType defines model for Office.Type.
type OfficeType string

// OfficeAddressType defines model for Office.Address.Type.
type OfficeAddressType string

// OfficeHeadline defines model for OfficeHeadline.
type OfficeHeadline struct {
	Context      *JsonLdContext `json:"@context,omitempty"`
	Content      *string        `json:"content,omitempty"`
	Id           *string        `json:"id,omitempty"`
	Important    *bool          `json:"important,omitempty"`
	IssuanceTime *time.Time     `json:"issuanceTime,omitempty"`
	Link         *string        `json:"link,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Office       *string        `json:"office,omitempty"`
	Summary      *string        `json:"summary"`
	Title        *string        `json:"title,omitempty"`
}

// OfficeHeadlineCollection defines model for OfficeHeadlineCollection.
type OfficeHeadlineCollection struct {
	Context JsonLdContext    `json:"@context"`
	Graph   []OfficeHeadline `json:"@graph"`
}

// PaginationInfo Links for retrieving more data from paged data sets
type PaginationInfo struct {
	// Next A link to the next page of records
	Next string `json:"next"`
}

// Point defines model for Point.
type Point struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Id      *string        `json:"@id,omitempty"`
	Type    *PointType     `json:"@type,omitempty"`
	County  *string        `json:"county,omitempty"`

	// Cwa Three-letter identifier for a NWS office.
	Cwa              *NWSForecastOfficeId `json:"cwa,omitempty"`
	FireWeatherZone  *string              `json:"fireWeatherZone,omitempty"`
	Forecast         *string              `json:"forecast,omitempty"`
	ForecastGridData *string              `json:"forecastGridData,omitempty"`
	ForecastHourly   *string              `json:"forecastHourly,omitempty"`
	ForecastOffice   *string              `json:"forecastOffice,omitempty"`
	ForecastZone     *string              `json:"forecastZone,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// GridId Three-letter identifier for a NWS office.
	GridId              *NWSForecastOfficeId    `json:"gridId,omitempty"`
	GridX               *int                    `json:"gridX,omitempty"`
	GridY               *int                    `json:"gridY,omitempty"`
	ObservationStations *string                 `json:"observationStations,omitempty"`
	RadarStation        *string                 `json:"radarStation,omitempty"`
	RelativeLocation    *Point_RelativeLocation `json:"relativeLocation,omitempty"`
	TimeZone            *string                 `json:"timeZone,omitempty"`
}

// PointType defines model for Point.Type.
type PointType string

// Point_RelativeLocation defines model for Point.RelativeLocation.
type Point_RelativeLocation struct {
	union json.RawMessage
}

// PointGeoJson defines model for PointGeoJson.
type PointGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry `json:"geometry"`
	Id         *string          `json:"id,omitempty"`
	Properties Point            `json:"properties"`
	Type       PointGeoJsonType `json:"type"`
}

// PointGeoJsonType defines model for PointGeoJson.Type.
type PointGeoJsonType string

// PointJsonLd defines model for PointJsonLd.
type PointJsonLd struct {
	Context JsonLdContext    `json:"@context"`
	Id      *string          `json:"@id,omitempty"`
	Type    *PointJsonLdType `json:"@type,omitempty"`
	County  *string          `json:"county,omitempty"`

	// Cwa Three-letter identifier for a NWS office.
	Cwa              *NWSForecastOfficeId `json:"cwa,omitempty"`
	FireWeatherZone  *string              `json:"fireWeatherZone,omitempty"`
	Forecast         *string              `json:"forecast,omitempty"`
	ForecastGridData *string              `json:"forecastGridData,omitempty"`
	ForecastHourly   *string              `json:"forecastHourly,omitempty"`
	ForecastOffice   *string              `json:"forecastOffice,omitempty"`
	ForecastZone     *string              `json:"forecastZone,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// GridId Three-letter identifier for a NWS office.
	GridId              *NWSForecastOfficeId          `json:"gridId,omitempty"`
	GridX               *int                          `json:"gridX,omitempty"`
	GridY               *int                          `json:"gridY,omitempty"`
	ObservationStations *string                       `json:"observationStations,omitempty"`
	RadarStation        *string                       `json:"radarStation,omitempty"`
	RelativeLocation    *PointJsonLd_RelativeLocation `json:"relativeLocation,omitempty"`
	TimeZone            *string                       `json:"timeZone,omitempty"`
}

// PointJsonLdType defines model for PointJsonLd.Type.
type PointJsonLdType string

// PointJsonLd_RelativeLocation defines model for PointJsonLd.RelativeLocation.
type PointJsonLd_RelativeLocation struct {
	union json.RawMessage
}

// PointString defines model for PointString.
type PointString = string

// ProblemDetail Detail about an error. This document conforms to RFC 7807 (Problem Details for HTTP APIs).
type ProblemDetail struct {
	// CorrelationId A unique identifier for the request, used for NWS debugging purposes. Please include this identifier with any correspondence to help us investigate your issue.
	CorrelationId string `json:"correlationId"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Instance A URI reference (RFC 3986) that identifies the specific occurrence of the problem. This is only an identifier and is not necessarily a resolvable URL.
	Instance string `json:"instance"`

	// Status The HTTP status code (RFC 7231, Section 6) generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem type.
	Title string `json:"title"`

	// Type A URI reference (RFC 3986) that identifies the problem type. This is only an identifier and is not necessarily a resolvable URL.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// QuantitativeValue A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
type QuantitativeValue struct {
	// MaxValue The maximum value of a range of measured values
	MaxValue *float32 `json:"maxValue,omitempty"`

	// MinValue The minimum value of a range of measured values
	MinValue *float32 `json:"minValue,omitempty"`

	// QualityControl For values in observation records, the quality control flag from the MADIS system. The definitions of these flags can be found at https://madis.ncep.noaa.gov/madis_sfc_qc_notes.shtml
	QualityControl *QuantitativeValueQualityControl `json:"qualityControl,omitempty"`

	// UnitCode A string denoting a unit of measure, expressed in the format "{unit}" or "{namespace}:{unit}".
	// Units with the namespace "wmo" or "wmoUnit" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}.
	// Units with the namespace "nwsUnit" are currently custom and do not align to any standard.
	// Units with no namespace or the namespace "uc" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156).
	// Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
	UnitCode *UnitOfMeasure `json:"unitCode,omitempty"`

	// Value A measured value
	Value *float32 `json:"value"`
}

// QuantitativeValueQualityControl For values in observation records, the quality control flag from the MADIS system. The definitions of these flags can be found at https://madis.ncep.noaa.gov/madis_sfc_qc_notes.shtml
type QuantitativeValueQualityControl string

// RegionCode defines model for RegionCode.
type RegionCode struct {
	union json.RawMessage
}

// RelativeLocation defines model for RelativeLocation.
type RelativeLocation struct {
	// Bearing A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Bearing *QuantitativeValue `json:"bearing,omitempty"`
	City    *string            `json:"city,omitempty"`

	// Distance A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Distance *QuantitativeValue `json:"distance,omitempty"`
	State    *string            `json:"state,omitempty"`
}

// RelativeLocationGeoJson defines model for RelativeLocationGeoJson.
type RelativeLocationGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry            `json:"geometry"`
	Id         *string                     `json:"id,omitempty"`
	Properties RelativeLocation            `json:"properties"`
	Type       RelativeLocationGeoJsonType `json:"type"`
}

// RelativeLocationGeoJsonType defines model for RelativeLocationGeoJson.Type.
type RelativeLocationGeoJsonType string

// RelativeLocationJsonLd defines model for RelativeLocationJsonLd.
type RelativeLocationJsonLd struct {
	// Bearing A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Bearing *QuantitativeValue `json:"bearing,omitempty"`
	City    *string            `json:"city,omitempty"`

	// Distance A structured value representing a measurement and its unit of measure. This object is a slightly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Distance *QuantitativeValue `json:"distance,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`
	State    *string         `json:"state,omitempty"`
}

// Sigmet defines model for Sigmet.
type Sigmet struct {
	// Atsu ATSU Identifier
	Atsu       *ATSUIdentifier `json:"atsu,omitempty"`
	End        *time.Time      `json:"end,omitempty"`
	Fir        *string         `json:"fir"`
	Id         *string         `json:"id,omitempty"`
	IssueTime  *time.Time      `json:"issueTime,omitempty"`
	Phenomenon *string         `json:"phenomenon"`
	Sequence   *string         `json:"sequence"`
	Start      *time.Time      `json:"start,omitempty"`
}

// SigmetCollectionGeoJson defines model for SigmetCollectionGeoJson.
type SigmetCollectionGeoJson struct {
	Context  *JsonLdContext              `json:"@context,omitempty"`
	Features []SigmetGeoJson             `json:"features"`
	Type     SigmetCollectionGeoJsonType `json:"type"`
}

// SigmetCollectionGeoJsonType defines model for SigmetCollectionGeoJson.Type.
type SigmetCollectionGeoJsonType string

// SigmetGeoJson defines model for SigmetGeoJson.
type SigmetGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry  `json:"geometry"`
	Id         *string           `json:"id,omitempty"`
	Properties Sigmet            `json:"properties"`
	Type       SigmetGeoJsonType `json:"type"`
}

// SigmetGeoJsonType defines model for SigmetGeoJson.Type.
type SigmetGeoJsonType string

// SigmetSequenceNumber defines model for SigmetSequenceNumber.
type SigmetSequenceNumber = string

// StateTerritoryCode defines model for StateTerritoryCode.
type StateTerritoryCode string

// TextProduct defines model for TextProduct.
type TextProduct struct {
	Context         *JsonLdContext `json:"@context,omitempty"`
	Id              *string        `json:"id,omitempty"`
	IssuanceTime    *time.Time     `json:"issuanceTime,omitempty"`
	IssuingOffice   *string        `json:"issuingOffice,omitempty"`
	ProductCode     *string        `json:"productCode,omitempty"`
	ProductName     *string        `json:"productName,omitempty"`
	ProductText     *string        `json:"productText,omitempty"`
	WmoCollectiveId *string        `json:"wmoCollectiveId,omitempty"`
}

// TextProductCollection defines model for TextProductCollection.
type TextProductCollection struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]TextProduct `json:"@graph,omitempty"`
}

// TextProductLocationCollection defines model for TextProductLocationCollection.
type TextProductLocationCollection struct {
	Context   *JsonLdContext      `json:"@context,omitempty"`
	Locations *map[string]*string `json:"locations,omitempty"`
}

// TextProductTypeCollection defines model for TextProductTypeCollection.
type TextProductTypeCollection struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]struct {
		ProductCode string `json:"productCode"`
		ProductName string `json:"productName"`
	} `json:"@graph,omitempty"`
}

// Time A time (in HHMM format). This is always specified in UTC (Zulu) time.
type Time = string

// UnitOfMeasure A string denoting a unit of measure, expressed in the format "{unit}" or "{namespace}:{unit}".
// Units with the namespace "wmo" or "wmoUnit" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}.
// Units with the namespace "nwsUnit" are currently custom and do not align to any standard.
// Units with no namespace or the namespace "uc" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156).
// Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
type UnitOfMeasure = string

// Zone defines model for Zone.
type Zone struct {
	Context                 *JsonLdContext `json:"@context,omitempty"`
	AwipsLocationIdentifier *string        `json:"awipsLocationIdentifier,omitempty"`
	// Deprecated:
	Cwa            *[]NWSForecastOfficeId `json:"cwa,omitempty"`
	EffectiveDate  *time.Time             `json:"effectiveDate,omitempty"`
	ExpirationDate *time.Time             `json:"expirationDate,omitempty"`
	ForecastOffice *string                `json:"forecastOffice,omitempty"`
	// Deprecated:
	ForecastOffices *[]string `json:"forecastOffices,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry       *GeometryString `json:"geometry"`
	GridIdentifier *string         `json:"gridIdentifier,omitempty"`

	// Id UGC identifier for a NWS forecast zone or county.
	// The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations).
	// The third letter will be Z for public/fire zone or C for county.
	Id                  *NWSZoneID   `json:"id,omitempty"`
	Name                *string      `json:"name,omitempty"`
	ObservationStations *[]string    `json:"observationStations,omitempty"`
	RadarStation        *string      `json:"radarStation"`
	State               *Zone_State  `json:"state,omitempty"`
	TimeZone            *[]string    `json:"timeZone,omitempty"`
	Type                *NWSZoneType `json:"type,omitempty"`
}

// ZoneState1 defines model for Zone.State.1.
type ZoneState1 string

// Zone_State defines model for Zone.State.
type Zone_State struct {
	union json.RawMessage
}

// ZoneCollectionGeoJson defines model for ZoneCollectionGeoJson.
type ZoneCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *Zone `json:"properties,omitempty"`
	} `json:"features"`
	Type ZoneCollectionGeoJsonType `json:"type"`
}

// ZoneCollectionGeoJsonType defines model for ZoneCollectionGeoJson.Type.
type ZoneCollectionGeoJsonType string

// ZoneCollectionJsonLd defines model for ZoneCollectionJsonLd.
type ZoneCollectionJsonLd struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]Zone        `json:"@graph,omitempty"`
}

// ZoneForecast An object representing a zone area forecast.
type ZoneForecast struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]struct {
		// DetailedForecast A detailed textual forecast for the period.
		DetailedForecast string `json:"detailedForecast"`

		// Name A textual description of the period.
		Name string `json:"name"`

		// Number A sequential identifier number.
		Number int `json:"number"`
	} `json:"periods,omitempty"`

	// Updated The time this zone forecast product was published.
	Updated *time.Time `json:"updated,omitempty"`

	// Zone An API link to the zone this forecast is for.
	Zone *string `json:"zone,omitempty"`
}

// ZoneForecastGeoJson defines model for ZoneForecastGeoJson.
type ZoneForecastGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties An object representing a zone area forecast.
	Properties ZoneForecast            `json:"properties"`
	Type       ZoneForecastGeoJsonType `json:"type"`
}

// ZoneForecastGeoJsonType defines model for ZoneForecastGeoJson.Type.
type ZoneForecastGeoJsonType string

// ZoneForecastJsonLd An object representing a zone area forecast.
type ZoneForecastJsonLd = ZoneForecast

// ZoneGeoJson defines model for ZoneGeoJson.
type ZoneGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry `json:"geometry"`
	Id         *string          `json:"id,omitempty"`
	Properties Zone             `json:"properties"`
	Type       ZoneGeoJsonType  `json:"type"`
}

// ZoneGeoJsonType defines model for ZoneGeoJson.Type.
type ZoneGeoJsonType string

// ZoneJsonLd defines model for ZoneJsonLd.
type ZoneJsonLd = Zone

// AlertArea defines model for AlertArea.
type AlertArea = []AreaCode

// AlertCertainty defines model for AlertCertainty.
type AlertCertainty = []AlertCertaintyEnum

// AlertCode defines model for AlertCode.
type AlertCode = []string

// AlertEventName defines model for AlertEventName.
type AlertEventName = []string

// AlertMessageType defines model for AlertMessageType.
type AlertMessageType = []string

// AlertPoint defines model for AlertPoint.
type AlertPoint = PointString

// AlertRegion defines model for AlertRegion.
type AlertRegion = []MarineRegionCode

// AlertRegionType defines model for AlertRegionType.
type AlertRegionType string

// AlertSeverity defines model for AlertSeverity.
type AlertSeverity = []AlertSeverityEnum

// AlertStatus defines model for AlertStatus.
type AlertStatus = []string

// AlertUrgency defines model for AlertUrgency.
type AlertUrgency = []AlertUrgencyEnum

// AlertZone defines model for AlertZone.
type AlertZone = []NWSZoneID

// GridpointForecastFeatureFlags defines model for GridpointForecastFeatureFlags.
type GridpointForecastFeatureFlags = []string

// GridpointWFO Three-letter identifier for a NWS office.
type GridpointWFO = NWSForecastOfficeId

// GridpointX defines model for GridpointX.
type GridpointX = int

// GridpointY defines model for GridpointY.
type GridpointY = int

// Latitude defines model for Latitude.
type Latitude = float32

// Limit defines model for Limit.
type Limit = int

// Longitude defines model for Longitude.
type Longitude = float32

// NWSZoneId UGC identifier for a NWS forecast zone or county.
// The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations).
// The third letter will be Z for public/fire zone or C for county.
type NWSZoneId = NWSZoneID

// ObservationStationId defines model for ObservationStationId.
type ObservationStationId = string

// ObservationsStationFeatureFlags defines model for ObservationsStationFeatureFlags.
type ObservationsStationFeatureFlags = []string

// PaginationCursor defines model for PaginationCursor.
type PaginationCursor = string

// QueryDate Date (in YYYY-MM-DD format).
type QueryDate = Date

// QueryEndTime defines model for QueryEndTime.
type QueryEndTime = time.Time

// QueryStartTime defines model for QueryStartTime.
type QueryStartTime = time.Time

// AlertCollectionApplicationGeoPlusJSON defines model for AlertCollection.
type AlertCollectionApplicationGeoPlusJSON = AlertCollectionGeoJson

// AlertCollectionApplicationLdPlusJSON defines model for AlertCollection.
type AlertCollectionApplicationLdPlusJSON = AlertCollectionJsonLd

// Error Detail about an error. This document conforms to RFC 7807 (Problem Details for HTTP APIs).
type Error = ProblemDetail

// Gridpoint12hForecastApplicationGeoPlusJSON defines model for Gridpoint12hForecast.
type Gridpoint12hForecastApplicationGeoPlusJSON = Gridpoint12hForecastGeoJson

// Gridpoint12hForecastApplicationLdPlusJSON defines model for Gridpoint12hForecast.
type Gridpoint12hForecastApplicationLdPlusJSON = Gridpoint12hForecastJsonLd

// GridpointHourlyForecastApplicationGeoPlusJSON defines model for GridpointHourlyForecast.
type GridpointHourlyForecastApplicationGeoPlusJSON = GridpointHourlyForecastGeoJson

// GridpointHourlyForecastApplicationLdPlusJSON defines model for GridpointHourlyForecast.
type GridpointHourlyForecastApplicationLdPlusJSON = GridpointHourlyForecastJsonLd

// ObservationApplicationGeoPlusJSON defines model for Observation.
type ObservationApplicationGeoPlusJSON = ObservationGeoJson

// ObservationApplicationLdPlusJSON defines model for Observation.
type ObservationApplicationLdPlusJSON = ObservationJsonLd

// ObservationCollectionApplicationGeoPlusJSON defines model for ObservationCollection.
type ObservationCollectionApplicationGeoPlusJSON = ObservationCollectionGeoJson

// ObservationCollectionApplicationLdPlusJSON defines model for ObservationCollection.
type ObservationCollectionApplicationLdPlusJSON = ObservationCollectionJsonLd

// ObservationStationCollectionApplicationGeoPlusJSON defines model for ObservationStationCollection.
type ObservationStationCollectionApplicationGeoPlusJSON = ObservationStationCollectionGeoJson

// ObservationStationCollectionApplicationLdPlusJSON defines model for ObservationStationCollection.
type ObservationStationCollectionApplicationLdPlusJSON = ObservationStationCollectionJsonLd

// AlertsQueryParams defines parameters for AlertsQuery.
type AlertsQueryParams struct {
	// Active List only active alerts (use /alerts/active endpoints instead)
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Start Start time
	Start *QueryStartTime `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *QueryEndTime `form:"end,omitempty" json:"end,omitempty"`

	// Status Status (actual, exercise, system, test, draft)
	Status *AlertStatus `form:"status,omitempty" json:"status,omitempty"`

	// MessageType Message type (alert, update, cancel)
	MessageType *AlertMessageType `form:"message_type,omitempty" json:"message_type,omitempty"`

	// Event Event name
	Event *AlertEventName `form:"event,omitempty" json:"event,omitempty"`

	// Code Event code
	Code *AlertCode `form:"code,omitempty" json:"code,omitempty"`

	// Area State/territory code or marine area code
	// This parameter is incompatible with the following parameters: point, region, region_type, zone
	Area *AlertArea `form:"area,omitempty" json:"area,omitempty"`

	// Point Point (latitude,longitude)
	// This parameter is incompatible with the following parameters: area, region, region_type, zone
	Point *AlertPoint `form:"point,omitempty" json:"point,omitempty"`

	// Region Marine region code
	// This parameter is incompatible with the following parameters: area, point, region_type, zone
	Region *AlertRegion `form:"region,omitempty" json:"region,omitempty"`

	// RegionType Region type (land or marine)
	// This parameter is incompatible with the following parameters: area, point, region, zone
	RegionType *AlertsQueryParamsRegionType `form:"region_type,omitempty" json:"region_type,omitempty"`

	// Zone Zone ID (forecast or county)
	// This parameter is incompatible with the following parameters: area, point, region, region_type
	Zone *AlertZone `form:"zone,omitempty" json:"zone,omitempty"`

	// Urgency Urgency (immediate, expected, future, past, unknown)
	Urgency *AlertUrgency `form:"urgency,omitempty" json:"urgency,omitempty"`

	// Severity Severity (extreme, severe, moderate, minor, unknown)
	Severity *AlertSeverity `form:"severity,omitempty" json:"severity,omitempty"`

	// Certainty Certainty (observed, likely, possible, unlikely, unknown)
	Certainty *AlertCertainty `form:"certainty,omitempty" json:"certainty,omitempty"`

	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AlertsQueryParamsStatus defines parameters for AlertsQuery.
type AlertsQueryParamsStatus string

// AlertsQueryParamsMessageType defines parameters for AlertsQuery.
type AlertsQueryParamsMessageType string

// AlertsQueryParamsRegionType defines parameters for AlertsQuery.
type AlertsQueryParamsRegionType string

// AlertsActiveParams defines parameters for AlertsActive.
type AlertsActiveParams struct {
	// Status Status (actual, exercise, system, test, draft)
	Status *AlertStatus `form:"status,omitempty" json:"status,omitempty"`

	// MessageType Message type (alert, update, cancel)
	MessageType *AlertMessageType `form:"message_type,omitempty" json:"message_type,omitempty"`

	// Event Event name
	Event *AlertEventName `form:"event,omitempty" json:"event,omitempty"`

	// Code Event code
	Code *AlertCode `form:"code,omitempty" json:"code,omitempty"`

	// Area State/territory code or marine area code
	// This parameter is incompatible with the following parameters: point, region, region_type, zone
	Area *AlertArea `form:"area,omitempty" json:"area,omitempty"`

	// Point Point (latitude,longitude)
	// This parameter is incompatible with the following parameters: area, region, region_type, zone
	Point *AlertPoint `form:"point,omitempty" json:"point,omitempty"`

	// Region Marine region code
	// This parameter is incompatible with the following parameters: area, point, region_type, zone
	Region *AlertRegion `form:"region,omitempty" json:"region,omitempty"`

	// RegionType Region type (land or marine)
	// This parameter is incompatible with the following parameters: area, point, region, zone
	RegionType *AlertsActiveParamsRegionType `form:"region_type,omitempty" json:"region_type,omitempty"`

	// Zone Zone ID (forecast or county)
	// This parameter is incompatible with the following parameters: area, point, region, region_type
	Zone *AlertZone `form:"zone,omitempty" json:"zone,omitempty"`

	// Urgency Urgency (immediate, expected, future, past, unknown)
	Urgency *AlertUrgency `form:"urgency,omitempty" json:"urgency,omitempty"`

	// Severity Severity (extreme, severe, moderate, minor, unknown)
	Severity *AlertSeverity `form:"severity,omitempty" json:"severity,omitempty"`

	// Certainty Certainty (observed, likely, possible, unlikely, unknown)
	Certainty *AlertCertainty `form:"certainty,omitempty" json:"certainty,omitempty"`
}

// AlertsActiveParamsStatus defines parameters for AlertsActive.
type AlertsActiveParamsStatus string

// AlertsActiveParamsMessageType defines parameters for AlertsActive.
type AlertsActiveParamsMessageType string

// AlertsActiveParamsRegionType defines parameters for AlertsActive.
type AlertsActiveParamsRegionType string

// SigmetQueryParams defines parameters for SigmetQuery.
type SigmetQueryParams struct {
	// Start Start time
	Start *QueryStartTime `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *QueryEndTime `form:"end,omitempty" json:"end,omitempty"`

	// Date Date (YYYY-MM-DD format)
	Date *QueryDate `form:"date,omitempty" json:"date,omitempty"`

	// Atsu ATSU identifier
	Atsu *ATSUIdentifier `form:"atsu,omitempty" json:"atsu,omitempty"`

	// Sequence SIGMET sequence number
	Sequence *SigmetSequenceNumber `form:"sequence,omitempty" json:"sequence,omitempty"`
}

// GridpointForecastParams defines parameters for GridpointForecast.
type GridpointForecastParams struct {
	// Units Use US customary or SI (metric) units in textual output
	Units *GridpointForecastUnits `form:"units,omitempty" json:"units,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * forecast_temperature_qv: Represent temperature as QuantitativeValue
	// * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
	FeatureFlags *GridpointForecastFeatureFlags `json:"Feature-Flags,omitempty"`
}

// GridpointForecastParamsFeatureFlags defines parameters for GridpointForecast.
type GridpointForecastParamsFeatureFlags string

// GridpointForecastHourlyParams defines parameters for GridpointForecastHourly.
type GridpointForecastHourlyParams struct {
	// Units Use US customary or SI (metric) units in textual output
	Units *GridpointForecastUnits `form:"units,omitempty" json:"units,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * forecast_temperature_qv: Represent temperature as QuantitativeValue
	// * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
	FeatureFlags *GridpointForecastFeatureFlags `json:"Feature-Flags,omitempty"`
}

// GridpointForecastHourlyParamsFeatureFlags defines parameters for GridpointForecastHourly.
type GridpointForecastHourlyParamsFeatureFlags string

// GridpointStationsParams defines parameters for GridpointStations.
type GridpointStationsParams struct {
	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * obs_station_provider: Include the data provider in the metadata about observation stations
	FeatureFlags *ObservationsStationFeatureFlags `json:"Feature-Flags,omitempty"`
}

// ProductsQueryParams defines parameters for ProductsQuery.
type ProductsQueryParams struct {
	// Location Location id
	Location *[]string `form:"location,omitempty" json:"location,omitempty"`

	// Start Start time
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Office Issuing office
	Office *[]string `form:"office,omitempty" json:"office,omitempty"`

	// Wmoid WMO id code
	Wmoid *[]string `form:"wmoid,omitempty" json:"wmoid,omitempty"`

	// Type Product code
	Type *[]string `form:"type,omitempty" json:"type,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// RadarProfilerParams defines parameters for RadarProfiler.
type RadarProfilerParams struct {
	// Time Time interval
	Time *ISO8601Interval `form:"time,omitempty" json:"time,omitempty"`

	// Interval Averaging interval
	Interval *ISO8601Duration `form:"interval,omitempty" json:"interval,omitempty"`
}

// RadarQueueParams defines parameters for RadarQueue.
type RadarQueueParams struct {
	// Limit Record limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Arrived Range for arrival time
	Arrived *ISO8601Interval `form:"arrived,omitempty" json:"arrived,omitempty"`

	// Created Range for creation time
	Created *ISO8601Interval `form:"created,omitempty" json:"created,omitempty"`

	// Published Range for publish time
	Published *ISO8601Interval `form:"published,omitempty" json:"published,omitempty"`

	// Station Station identifier
	Station *string `form:"station,omitempty" json:"station,omitempty"`

	// Type Record type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Feed Originating product feed
	Feed *string `form:"feed,omitempty" json:"feed,omitempty"`

	// Resolution Resolution version
	Resolution *int `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// RadarServersParams defines parameters for RadarServers.
type RadarServersParams struct {
	// ReportingHost Show records from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`
}

// RadarServerParams defines parameters for RadarServer.
type RadarServerParams struct {
	// ReportingHost Show records from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`
}

// RadarStationsParams defines parameters for RadarStations.
type RadarStationsParams struct {
	// StationType Limit results to a specific station type or types
	StationType *[]string `form:"stationType,omitempty" json:"stationType,omitempty"`

	// ReportingHost Show RDA and latency info from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`

	// Host Show latency info from specific LDM host
	Host *string `form:"host,omitempty" json:"host,omitempty"`
}

// RadarStationParams defines parameters for RadarStation.
type RadarStationParams struct {
	// ReportingHost Show RDA and latency info from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`

	// Host Show latency info from specific LDM host
	Host *string `form:"host,omitempty" json:"host,omitempty"`
}

// ObsStationsParams defines parameters for ObsStations.
type ObsStationsParams struct {
	// Id Filter by observation station ID
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// State Filter by state/marine area code
	State *[]AreaCode `form:"state,omitempty" json:"state,omitempty"`

	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * obs_station_provider: Include the data provider in the metadata about observation stations
	FeatureFlags *ObservationsStationFeatureFlags `json:"Feature-Flags,omitempty"`
}

// ObsStationsParamsFeatureFlags defines parameters for ObsStations.
type ObsStationsParamsFeatureFlags string

// ObsStationParams defines parameters for ObsStation.
type ObsStationParams struct {
	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * obs_station_provider: Include the data provider in the metadata about observation stations
	FeatureFlags *ObservationsStationFeatureFlags `json:"Feature-Flags,omitempty"`
}

// ObsStationParamsFeatureFlags defines parameters for ObsStation.
type ObsStationParamsFeatureFlags string

// StationObservationListParams defines parameters for StationObservationList.
type StationObservationListParams struct {
	// Start Start time
	Start *QueryStartTime `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *QueryEndTime `form:"end,omitempty" json:"end,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// StationObservationLatestParams defines parameters for StationObservationLatest.
type StationObservationLatestParams struct {
	// RequireQc Require QC
	RequireQc *bool `form:"require_qc,omitempty" json:"require_qc,omitempty"`
}

// ZoneListParams defines parameters for ZoneList.
type ZoneListParams struct {
	// Id Zone ID (forecast or county)
	Id *[]NWSZoneID `form:"id,omitempty" json:"id,omitempty"`

	// Area State/marine area code
	Area *[]AreaCode `form:"area,omitempty" json:"area,omitempty"`

	// Region Region code
	Region *[]RegionCode `form:"region,omitempty" json:"region,omitempty"`

	// Type Zone type
	Type *[]NWSZoneType `form:"type,omitempty" json:"type,omitempty"`

	// Point Point (latitude,longitude)
	Point *PointString `form:"point,omitempty" json:"point,omitempty"`

	// IncludeGeometry Include geometry in results (true/false)
	IncludeGeometry *bool `form:"include_geometry,omitempty" json:"include_geometry,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Effective Effective date/time
	Effective *time.Time `form:"effective,omitempty" json:"effective,omitempty"`
}

// ZoneObsParams defines parameters for ZoneObs.
type ZoneObsParams struct {
	// Start Start date/time
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End date/time
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ZoneStationsParams defines parameters for ZoneStations.
type ZoneStationsParams struct {
	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * obs_station_provider: Include the data provider in the metadata about observation stations
	FeatureFlags *ObservationsStationFeatureFlags `json:"Feature-Flags,omitempty"`
}

// ZoneListTypeParams defines parameters for ZoneListType.
type ZoneListTypeParams struct {
	// Id Zone ID (forecast or county)
	Id *[]NWSZoneID `form:"id,omitempty" json:"id,omitempty"`

	// Area State/marine area code
	Area *[]AreaCode `form:"area,omitempty" json:"area,omitempty"`

	// Region Region code
	Region *[]RegionCode `form:"region,omitempty" json:"region,omitempty"`

	// Type Zone type
	Type *[]NWSZoneType `form:"type,omitempty" json:"type,omitempty"`

	// Point Point (latitude,longitude)
	Point *PointString `form:"point,omitempty" json:"point,omitempty"`

	// IncludeGeometry Include geometry in results (true/false)
	IncludeGeometry *bool `form:"include_geometry,omitempty" json:"include_geometry,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Effective Effective date/time
	Effective *time.Time `form:"effective,omitempty" json:"effective,omitempty"`
}

// ZoneParams defines parameters for Zone.
type ZoneParams struct {
	// Effective Effective date/time
	Effective *time.Time `form:"effective,omitempty" json:"effective,omitempty"`
}

// Getter for additional properties for Gridpoint. Returns the specified
// element and whether it was found
func (a Gridpoint) Get(fieldName string) (value GridpointQuantitativeValueLayer, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Gridpoint
func (a *Gridpoint) Set(fieldName string, value GridpointQuantitativeValueLayer) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]GridpointQuantitativeValueLayer)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Gridpoint to handle AdditionalProperties
func (a *Gridpoint) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@context"]; found {
		err = json.Unmarshal(raw, &a.Context)
		if err != nil {
			return fmt.Errorf("error reading '@context': %w", err)
		}
		delete(object, "@context")
	}

	if raw, found := object["@id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading '@id': %w", err)
		}
		delete(object, "@id")
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if raw, found := object["elevation"]; found {
		err = json.Unmarshal(raw, &a.Elevation)
		if err != nil {
			return fmt.Errorf("error reading 'elevation': %w", err)
		}
		delete(object, "elevation")
	}

	if raw, found := object["forecastOffice"]; found {
		err = json.Unmarshal(raw, &a.ForecastOffice)
		if err != nil {
			return fmt.Errorf("error reading 'forecastOffice': %w", err)
		}
		delete(object, "forecastOffice")
	}

	if raw, found := object["geometry"]; found {
		err = json.Unmarshal(raw, &a.Geometry)
		if err != nil {
			return fmt.Errorf("error reading 'geometry': %w", err)
		}
		delete(object, "geometry")
	}

	if raw, found := object["gridId"]; found {
		err = json.Unmarshal(raw, &a.GridId)
		if err != nil {
			return fmt.Errorf("error reading 'gridId': %w", err)
		}
		delete(object, "gridId")
	}

	if raw, found := object["gridX"]; found {
		err = json.Unmarshal(raw, &a.GridX)
		if err != nil {
			return fmt.Errorf("error reading 'gridX': %w", err)
		}
		delete(object, "gridX")
	}

	if raw, found := object["gridY"]; found {
		err = json.Unmarshal(raw, &a.GridY)
		if err != nil {
			return fmt.Errorf("error reading 'gridY': %w", err)
		}
		delete(object, "gridY")
	}

	if raw, found := object["hazards"]; found {
		err = json.Unmarshal(raw, &a.Hazards)
		if err != nil {
			return fmt.Errorf("error reading 'hazards': %w", err)
		}
		delete(object, "hazards")
	}

	if raw, found := object["updateTime"]; found {
		err = json.Unmarshal(raw, &a.UpdateTime)
		if err != nil {
			return fmt.Errorf("error reading 'updateTime': %w", err)
		}
		delete(object, "updateTime")
	}

	if raw, found := object["validTimes"]; found {
		err = json.Unmarshal(raw, &a.ValidTimes)
		if err != nil {
			return fmt.Errorf("error reading 'validTimes': %w", err)
		}
		delete(object, "validTimes")
	}

	if raw, found := object["weather"]; found {
		err = json.Unmarshal(raw, &a.Weather)
		if err != nil {
			return fmt.Errorf("error reading 'weather': %w", err)
		}
		delete(object, "weather")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]GridpointQuantitativeValueLayer)
		for fieldName, fieldBuf := range object {
			var fieldVal GridpointQuantitativeValueLayer
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Gridpoint to handle AdditionalProperties
func (a Gridpoint) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Context != nil {
		object["@context"], err = json.Marshal(a.Context)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@context': %w", err)
		}
	}

	if a.Id != nil {
		object["@id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@id': %w", err)
		}
	}

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	if a.Elevation != nil {
		object["elevation"], err = json.Marshal(a.Elevation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elevation': %w", err)
		}
	}

	if a.ForecastOffice != nil {
		object["forecastOffice"], err = json.Marshal(a.ForecastOffice)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'forecastOffice': %w", err)
		}
	}

	if a.Geometry != nil {
		object["geometry"], err = json.Marshal(a.Geometry)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'geometry': %w", err)
		}
	}

	if a.GridId != nil {
		object["gridId"], err = json.Marshal(a.GridId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gridId': %w", err)
		}
	}

	if a.GridX != nil {
		object["gridX"], err = json.Marshal(a.GridX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gridX': %w", err)
		}
	}

	if a.GridY != nil {
		object["gridY"], err = json.Marshal(a.GridY)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gridY': %w", err)
		}
	}

	if a.Hazards != nil {
		object["hazards"], err = json.Marshal(a.Hazards)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hazards': %w", err)
		}
	}

	if a.UpdateTime != nil {
		object["updateTime"], err = json.Marshal(a.UpdateTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updateTime': %w", err)
		}
	}

	if a.ValidTimes != nil {
		object["validTimes"], err = json.Marshal(a.ValidTimes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'validTimes': %w", err)
		}
	}

	if a.Weather != nil {
		object["weather"], err = json.Marshal(a.Weather)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'weather': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProblemDetail. Returns the specified
// element and whether it was found
func (a ProblemDetail) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProblemDetail
func (a *ProblemDetail) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProblemDetail to handle AdditionalProperties
func (a *ProblemDetail) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["correlationId"]; found {
		err = json.Unmarshal(raw, &a.CorrelationId)
		if err != nil {
			return fmt.Errorf("error reading 'correlationId': %w", err)
		}
		delete(object, "correlationId")
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["instance"]; found {
		err = json.Unmarshal(raw, &a.Instance)
		if err != nil {
			return fmt.Errorf("error reading 'instance': %w", err)
		}
		delete(object, "instance")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProblemDetail to handle AdditionalProperties
func (a ProblemDetail) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["correlationId"], err = json.Marshal(a.CorrelationId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'correlationId': %w", err)
	}

	object["detail"], err = json.Marshal(a.Detail)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'detail': %w", err)
	}

	object["instance"], err = json.Marshal(a.Instance)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'instance': %w", err)
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsStateTerritoryCode returns the union data inside the AreaCode as a StateTerritoryCode
func (t AreaCode) AsStateTerritoryCode() (StateTerritoryCode, error) {
	var body StateTerritoryCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStateTerritoryCode overwrites any union data inside the AreaCode as the provided StateTerritoryCode
func (t *AreaCode) FromStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStateTerritoryCode performs a merge with any union data inside the AreaCode, using the provided StateTerritoryCode
func (t *AreaCode) MergeStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarineAreaCode returns the union data inside the AreaCode as a MarineAreaCode
func (t AreaCode) AsMarineAreaCode() (MarineAreaCode, error) {
	var body MarineAreaCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarineAreaCode overwrites any union data inside the AreaCode as the provided MarineAreaCode
func (t *AreaCode) FromMarineAreaCode(v MarineAreaCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarineAreaCode performs a merge with any union data inside the AreaCode, using the provided MarineAreaCode
func (t *AreaCode) MergeMarineAreaCode(v MarineAreaCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AreaCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AreaCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGeoJsonGeometry0 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry0
func (t GeoJsonGeometry) AsGeoJsonGeometry0() (GeoJsonGeometry0, error) {
	var body GeoJsonGeometry0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry0 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry0
func (t *GeoJsonGeometry) FromGeoJsonGeometry0(v GeoJsonGeometry0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry0 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry0
func (t *GeoJsonGeometry) MergeGeoJsonGeometry0(v GeoJsonGeometry0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoJsonGeometry1 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry1
func (t GeoJsonGeometry) AsGeoJsonGeometry1() (GeoJsonGeometry1, error) {
	var body GeoJsonGeometry1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry1 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry1
func (t *GeoJsonGeometry) FromGeoJsonGeometry1(v GeoJsonGeometry1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry1 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry1
func (t *GeoJsonGeometry) MergeGeoJsonGeometry1(v GeoJsonGeometry1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoJsonGeometry2 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry2
func (t GeoJsonGeometry) AsGeoJsonGeometry2() (GeoJsonGeometry2, error) {
	var body GeoJsonGeometry2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry2 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry2
func (t *GeoJsonGeometry) FromGeoJsonGeometry2(v GeoJsonGeometry2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry2 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry2
func (t *GeoJsonGeometry) MergeGeoJsonGeometry2(v GeoJsonGeometry2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoJsonGeometry3 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry3
func (t GeoJsonGeometry) AsGeoJsonGeometry3() (GeoJsonGeometry3, error) {
	var body GeoJsonGeometry3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry3 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry3
func (t *GeoJsonGeometry) FromGeoJsonGeometry3(v GeoJsonGeometry3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry3 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry3
func (t *GeoJsonGeometry) MergeGeoJsonGeometry3(v GeoJsonGeometry3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoJsonGeometry4 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry4
func (t GeoJsonGeometry) AsGeoJsonGeometry4() (GeoJsonGeometry4, error) {
	var body GeoJsonGeometry4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry4 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry4
func (t *GeoJsonGeometry) FromGeoJsonGeometry4(v GeoJsonGeometry4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry4 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry4
func (t *GeoJsonGeometry) MergeGeoJsonGeometry4(v GeoJsonGeometry4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeoJsonGeometry5 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry5
func (t GeoJsonGeometry) AsGeoJsonGeometry5() (GeoJsonGeometry5, error) {
	var body GeoJsonGeometry5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry5 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry5
func (t *GeoJsonGeometry) FromGeoJsonGeometry5(v GeoJsonGeometry5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry5 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry5
func (t *GeoJsonGeometry) MergeGeoJsonGeometry5(v GeoJsonGeometry5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GeoJsonGeometry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GeoJsonGeometry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the Gridpoint12hForecastPeriod_Temperature as a QuantitativeValue
func (t Gridpoint12hForecastPeriod_Temperature) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the Gridpoint12hForecastPeriod_Temperature as the provided QuantitativeValue
func (t *Gridpoint12hForecastPeriod_Temperature) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the Gridpoint12hForecastPeriod_Temperature, using the provided QuantitativeValue
func (t *Gridpoint12hForecastPeriod_Temperature) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGridpoint12hForecastPeriodTemperature1 returns the union data inside the Gridpoint12hForecastPeriod_Temperature as a Gridpoint12hForecastPeriodTemperature1
func (t Gridpoint12hForecastPeriod_Temperature) AsGridpoint12hForecastPeriodTemperature1() (Gridpoint12hForecastPeriodTemperature1, error) {
	var body Gridpoint12hForecastPeriodTemperature1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpoint12hForecastPeriodTemperature1 overwrites any union data inside the Gridpoint12hForecastPeriod_Temperature as the provided Gridpoint12hForecastPeriodTemperature1
func (t *Gridpoint12hForecastPeriod_Temperature) FromGridpoint12hForecastPeriodTemperature1(v Gridpoint12hForecastPeriodTemperature1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpoint12hForecastPeriodTemperature1 performs a merge with any union data inside the Gridpoint12hForecastPeriod_Temperature, using the provided Gridpoint12hForecastPeriodTemperature1
func (t *Gridpoint12hForecastPeriod_Temperature) MergeGridpoint12hForecastPeriodTemperature1(v Gridpoint12hForecastPeriodTemperature1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Gridpoint12hForecastPeriod_Temperature) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Gridpoint12hForecastPeriod_Temperature) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the Gridpoint12hForecastPeriod_WindGust as a QuantitativeValue
func (t Gridpoint12hForecastPeriod_WindGust) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the Gridpoint12hForecastPeriod_WindGust as the provided QuantitativeValue
func (t *Gridpoint12hForecastPeriod_WindGust) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the Gridpoint12hForecastPeriod_WindGust, using the provided QuantitativeValue
func (t *Gridpoint12hForecastPeriod_WindGust) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGridpoint12hForecastPeriodWindGust1 returns the union data inside the Gridpoint12hForecastPeriod_WindGust as a Gridpoint12hForecastPeriodWindGust1
func (t Gridpoint12hForecastPeriod_WindGust) AsGridpoint12hForecastPeriodWindGust1() (Gridpoint12hForecastPeriodWindGust1, error) {
	var body Gridpoint12hForecastPeriodWindGust1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpoint12hForecastPeriodWindGust1 overwrites any union data inside the Gridpoint12hForecastPeriod_WindGust as the provided Gridpoint12hForecastPeriodWindGust1
func (t *Gridpoint12hForecastPeriod_WindGust) FromGridpoint12hForecastPeriodWindGust1(v Gridpoint12hForecastPeriodWindGust1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpoint12hForecastPeriodWindGust1 performs a merge with any union data inside the Gridpoint12hForecastPeriod_WindGust, using the provided Gridpoint12hForecastPeriodWindGust1
func (t *Gridpoint12hForecastPeriod_WindGust) MergeGridpoint12hForecastPeriodWindGust1(v Gridpoint12hForecastPeriodWindGust1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Gridpoint12hForecastPeriod_WindGust) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Gridpoint12hForecastPeriod_WindGust) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the Gridpoint12hForecastPeriod_WindSpeed as a QuantitativeValue
func (t Gridpoint12hForecastPeriod_WindSpeed) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the Gridpoint12hForecastPeriod_WindSpeed as the provided QuantitativeValue
func (t *Gridpoint12hForecastPeriod_WindSpeed) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the Gridpoint12hForecastPeriod_WindSpeed, using the provided QuantitativeValue
func (t *Gridpoint12hForecastPeriod_WindSpeed) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGridpoint12hForecastPeriodWindSpeed1 returns the union data inside the Gridpoint12hForecastPeriod_WindSpeed as a Gridpoint12hForecastPeriodWindSpeed1
func (t Gridpoint12hForecastPeriod_WindSpeed) AsGridpoint12hForecastPeriodWindSpeed1() (Gridpoint12hForecastPeriodWindSpeed1, error) {
	var body Gridpoint12hForecastPeriodWindSpeed1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpoint12hForecastPeriodWindSpeed1 overwrites any union data inside the Gridpoint12hForecastPeriod_WindSpeed as the provided Gridpoint12hForecastPeriodWindSpeed1
func (t *Gridpoint12hForecastPeriod_WindSpeed) FromGridpoint12hForecastPeriodWindSpeed1(v Gridpoint12hForecastPeriodWindSpeed1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpoint12hForecastPeriodWindSpeed1 performs a merge with any union data inside the Gridpoint12hForecastPeriod_WindSpeed, using the provided Gridpoint12hForecastPeriodWindSpeed1
func (t *Gridpoint12hForecastPeriod_WindSpeed) MergeGridpoint12hForecastPeriodWindSpeed1(v Gridpoint12hForecastPeriodWindSpeed1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Gridpoint12hForecastPeriod_WindSpeed) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Gridpoint12hForecastPeriod_WindSpeed) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the GridpointHourlyForecastPeriod_Temperature as a QuantitativeValue
func (t GridpointHourlyForecastPeriod_Temperature) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the GridpointHourlyForecastPeriod_Temperature as the provided QuantitativeValue
func (t *GridpointHourlyForecastPeriod_Temperature) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the GridpointHourlyForecastPeriod_Temperature, using the provided QuantitativeValue
func (t *GridpointHourlyForecastPeriod_Temperature) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGridpointHourlyForecastPeriodTemperature1 returns the union data inside the GridpointHourlyForecastPeriod_Temperature as a GridpointHourlyForecastPeriodTemperature1
func (t GridpointHourlyForecastPeriod_Temperature) AsGridpointHourlyForecastPeriodTemperature1() (GridpointHourlyForecastPeriodTemperature1, error) {
	var body GridpointHourlyForecastPeriodTemperature1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpointHourlyForecastPeriodTemperature1 overwrites any union data inside the GridpointHourlyForecastPeriod_Temperature as the provided GridpointHourlyForecastPeriodTemperature1
func (t *GridpointHourlyForecastPeriod_Temperature) FromGridpointHourlyForecastPeriodTemperature1(v GridpointHourlyForecastPeriodTemperature1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpointHourlyForecastPeriodTemperature1 performs a merge with any union data inside the GridpointHourlyForecastPeriod_Temperature, using the provided GridpointHourlyForecastPeriodTemperature1
func (t *GridpointHourlyForecastPeriod_Temperature) MergeGridpointHourlyForecastPeriodTemperature1(v GridpointHourlyForecastPeriodTemperature1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GridpointHourlyForecastPeriod_Temperature) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GridpointHourlyForecastPeriod_Temperature) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the GridpointHourlyForecastPeriod_WindGust as a QuantitativeValue
func (t GridpointHourlyForecastPeriod_WindGust) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the GridpointHourlyForecastPeriod_WindGust as the provided QuantitativeValue
func (t *GridpointHourlyForecastPeriod_WindGust) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the GridpointHourlyForecastPeriod_WindGust, using the provided QuantitativeValue
func (t *GridpointHourlyForecastPeriod_WindGust) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGridpointHourlyForecastPeriodWindGust1 returns the union data inside the GridpointHourlyForecastPeriod_WindGust as a GridpointHourlyForecastPeriodWindGust1
func (t GridpointHourlyForecastPeriod_WindGust) AsGridpointHourlyForecastPeriodWindGust1() (GridpointHourlyForecastPeriodWindGust1, error) {
	var body GridpointHourlyForecastPeriodWindGust1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpointHourlyForecastPeriodWindGust1 overwrites any union data inside the GridpointHourlyForecastPeriod_WindGust as the provided GridpointHourlyForecastPeriodWindGust1
func (t *GridpointHourlyForecastPeriod_WindGust) FromGridpointHourlyForecastPeriodWindGust1(v GridpointHourlyForecastPeriodWindGust1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpointHourlyForecastPeriodWindGust1 performs a merge with any union data inside the GridpointHourlyForecastPeriod_WindGust, using the provided GridpointHourlyForecastPeriodWindGust1
func (t *GridpointHourlyForecastPeriod_WindGust) MergeGridpointHourlyForecastPeriodWindGust1(v GridpointHourlyForecastPeriodWindGust1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GridpointHourlyForecastPeriod_WindGust) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GridpointHourlyForecastPeriod_WindGust) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the GridpointHourlyForecastPeriod_WindSpeed as a QuantitativeValue
func (t GridpointHourlyForecastPeriod_WindSpeed) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the GridpointHourlyForecastPeriod_WindSpeed as the provided QuantitativeValue
func (t *GridpointHourlyForecastPeriod_WindSpeed) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the GridpointHourlyForecastPeriod_WindSpeed, using the provided QuantitativeValue
func (t *GridpointHourlyForecastPeriod_WindSpeed) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGridpointHourlyForecastPeriodWindSpeed1 returns the union data inside the GridpointHourlyForecastPeriod_WindSpeed as a GridpointHourlyForecastPeriodWindSpeed1
func (t GridpointHourlyForecastPeriod_WindSpeed) AsGridpointHourlyForecastPeriodWindSpeed1() (GridpointHourlyForecastPeriodWindSpeed1, error) {
	var body GridpointHourlyForecastPeriodWindSpeed1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpointHourlyForecastPeriodWindSpeed1 overwrites any union data inside the GridpointHourlyForecastPeriod_WindSpeed as the provided GridpointHourlyForecastPeriodWindSpeed1
func (t *GridpointHourlyForecastPeriod_WindSpeed) FromGridpointHourlyForecastPeriodWindSpeed1(v GridpointHourlyForecastPeriodWindSpeed1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpointHourlyForecastPeriodWindSpeed1 performs a merge with any union data inside the GridpointHourlyForecastPeriod_WindSpeed, using the provided GridpointHourlyForecastPeriodWindSpeed1
func (t *GridpointHourlyForecastPeriod_WindSpeed) MergeGridpointHourlyForecastPeriodWindSpeed1(v GridpointHourlyForecastPeriodWindSpeed1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GridpointHourlyForecastPeriod_WindSpeed) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GridpointHourlyForecastPeriod_WindSpeed) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsISO8601Interval0 returns the union data inside the ISO8601Interval as a ISO8601Interval0
func (t ISO8601Interval) AsISO8601Interval0() (ISO8601Interval0, error) {
	var body ISO8601Interval0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromISO8601Interval0 overwrites any union data inside the ISO8601Interval as the provided ISO8601Interval0
func (t *ISO8601Interval) FromISO8601Interval0(v ISO8601Interval0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeISO8601Interval0 performs a merge with any union data inside the ISO8601Interval, using the provided ISO8601Interval0
func (t *ISO8601Interval) MergeISO8601Interval0(v ISO8601Interval0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsISO8601Interval1 returns the union data inside the ISO8601Interval as a ISO8601Interval1
func (t ISO8601Interval) AsISO8601Interval1() (ISO8601Interval1, error) {
	var body ISO8601Interval1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromISO8601Interval1 overwrites any union data inside the ISO8601Interval as the provided ISO8601Interval1
func (t *ISO8601Interval) FromISO8601Interval1(v ISO8601Interval1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeISO8601Interval1 performs a merge with any union data inside the ISO8601Interval, using the provided ISO8601Interval1
func (t *ISO8601Interval) MergeISO8601Interval1(v ISO8601Interval1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsISO8601Interval2 returns the union data inside the ISO8601Interval as a ISO8601Interval2
func (t ISO8601Interval) AsISO8601Interval2() (ISO8601Interval2, error) {
	var body ISO8601Interval2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromISO8601Interval2 overwrites any union data inside the ISO8601Interval as the provided ISO8601Interval2
func (t *ISO8601Interval) FromISO8601Interval2(v ISO8601Interval2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeISO8601Interval2 performs a merge with any union data inside the ISO8601Interval, using the provided ISO8601Interval2
func (t *ISO8601Interval) MergeISO8601Interval2(v ISO8601Interval2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ISO8601Interval) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ISO8601Interval) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsonLdContext0 returns the union data inside the JsonLdContext as a JsonLdContext0
func (t JsonLdContext) AsJsonLdContext0() (JsonLdContext0, error) {
	var body JsonLdContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonLdContext0 overwrites any union data inside the JsonLdContext as the provided JsonLdContext0
func (t *JsonLdContext) FromJsonLdContext0(v JsonLdContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonLdContext0 performs a merge with any union data inside the JsonLdContext, using the provided JsonLdContext0
func (t *JsonLdContext) MergeJsonLdContext0(v JsonLdContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonLdContext1 returns the union data inside the JsonLdContext as a JsonLdContext1
func (t JsonLdContext) AsJsonLdContext1() (JsonLdContext1, error) {
	var body JsonLdContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonLdContext1 overwrites any union data inside the JsonLdContext as the provided JsonLdContext1
func (t *JsonLdContext) FromJsonLdContext1(v JsonLdContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonLdContext1 performs a merge with any union data inside the JsonLdContext, using the provided JsonLdContext1
func (t *JsonLdContext) MergeJsonLdContext1(v JsonLdContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JsonLdContext) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JsonLdContext) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNWSForecastOfficeId returns the union data inside the NWSOfficeId as a NWSForecastOfficeId
func (t NWSOfficeId) AsNWSForecastOfficeId() (NWSForecastOfficeId, error) {
	var body NWSForecastOfficeId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNWSForecastOfficeId overwrites any union data inside the NWSOfficeId as the provided NWSForecastOfficeId
func (t *NWSOfficeId) FromNWSForecastOfficeId(v NWSForecastOfficeId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNWSForecastOfficeId performs a merge with any union data inside the NWSOfficeId, using the provided NWSForecastOfficeId
func (t *NWSOfficeId) MergeNWSForecastOfficeId(v NWSForecastOfficeId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNWSRegionalHQId returns the union data inside the NWSOfficeId as a NWSRegionalHQId
func (t NWSOfficeId) AsNWSRegionalHQId() (NWSRegionalHQId, error) {
	var body NWSRegionalHQId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNWSRegionalHQId overwrites any union data inside the NWSOfficeId as the provided NWSRegionalHQId
func (t *NWSOfficeId) FromNWSRegionalHQId(v NWSRegionalHQId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNWSRegionalHQId performs a merge with any union data inside the NWSOfficeId, using the provided NWSRegionalHQId
func (t *NWSOfficeId) MergeNWSRegionalHQId(v NWSRegionalHQId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNWSNationalHQId returns the union data inside the NWSOfficeId as a NWSNationalHQId
func (t NWSOfficeId) AsNWSNationalHQId() (NWSNationalHQId, error) {
	var body NWSNationalHQId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNWSNationalHQId overwrites any union data inside the NWSOfficeId as the provided NWSNationalHQId
func (t *NWSOfficeId) FromNWSNationalHQId(v NWSNationalHQId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNWSNationalHQId performs a merge with any union data inside the NWSOfficeId, using the provided NWSNationalHQId
func (t *NWSOfficeId) MergeNWSNationalHQId(v NWSNationalHQId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NWSOfficeId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NWSOfficeId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelativeLocationGeoJson returns the union data inside the Point_RelativeLocation as a RelativeLocationGeoJson
func (t Point_RelativeLocation) AsRelativeLocationGeoJson() (RelativeLocationGeoJson, error) {
	var body RelativeLocationGeoJson
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationGeoJson overwrites any union data inside the Point_RelativeLocation as the provided RelativeLocationGeoJson
func (t *Point_RelativeLocation) FromRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationGeoJson performs a merge with any union data inside the Point_RelativeLocation, using the provided RelativeLocationGeoJson
func (t *Point_RelativeLocation) MergeRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelativeLocationJsonLd returns the union data inside the Point_RelativeLocation as a RelativeLocationJsonLd
func (t Point_RelativeLocation) AsRelativeLocationJsonLd() (RelativeLocationJsonLd, error) {
	var body RelativeLocationJsonLd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationJsonLd overwrites any union data inside the Point_RelativeLocation as the provided RelativeLocationJsonLd
func (t *Point_RelativeLocation) FromRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationJsonLd performs a merge with any union data inside the Point_RelativeLocation, using the provided RelativeLocationJsonLd
func (t *Point_RelativeLocation) MergeRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Point_RelativeLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Point_RelativeLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelativeLocationGeoJson returns the union data inside the PointJsonLd_RelativeLocation as a RelativeLocationGeoJson
func (t PointJsonLd_RelativeLocation) AsRelativeLocationGeoJson() (RelativeLocationGeoJson, error) {
	var body RelativeLocationGeoJson
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationGeoJson overwrites any union data inside the PointJsonLd_RelativeLocation as the provided RelativeLocationGeoJson
func (t *PointJsonLd_RelativeLocation) FromRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationGeoJson performs a merge with any union data inside the PointJsonLd_RelativeLocation, using the provided RelativeLocationGeoJson
func (t *PointJsonLd_RelativeLocation) MergeRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRelativeLocationJsonLd returns the union data inside the PointJsonLd_RelativeLocation as a RelativeLocationJsonLd
func (t PointJsonLd_RelativeLocation) AsRelativeLocationJsonLd() (RelativeLocationJsonLd, error) {
	var body RelativeLocationJsonLd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationJsonLd overwrites any union data inside the PointJsonLd_RelativeLocation as the provided RelativeLocationJsonLd
func (t *PointJsonLd_RelativeLocation) FromRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationJsonLd performs a merge with any union data inside the PointJsonLd_RelativeLocation, using the provided RelativeLocationJsonLd
func (t *PointJsonLd_RelativeLocation) MergeRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PointJsonLd_RelativeLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PointJsonLd_RelativeLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLandRegionCode returns the union data inside the RegionCode as a LandRegionCode
func (t RegionCode) AsLandRegionCode() (LandRegionCode, error) {
	var body LandRegionCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLandRegionCode overwrites any union data inside the RegionCode as the provided LandRegionCode
func (t *RegionCode) FromLandRegionCode(v LandRegionCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLandRegionCode performs a merge with any union data inside the RegionCode, using the provided LandRegionCode
func (t *RegionCode) MergeLandRegionCode(v LandRegionCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarineRegionCode returns the union data inside the RegionCode as a MarineRegionCode
func (t RegionCode) AsMarineRegionCode() (MarineRegionCode, error) {
	var body MarineRegionCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarineRegionCode overwrites any union data inside the RegionCode as the provided MarineRegionCode
func (t *RegionCode) FromMarineRegionCode(v MarineRegionCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarineRegionCode performs a merge with any union data inside the RegionCode, using the provided MarineRegionCode
func (t *RegionCode) MergeMarineRegionCode(v MarineRegionCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegionCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RegionCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStateTerritoryCode returns the union data inside the Zone_State as a StateTerritoryCode
func (t Zone_State) AsStateTerritoryCode() (StateTerritoryCode, error) {
	var body StateTerritoryCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStateTerritoryCode overwrites any union data inside the Zone_State as the provided StateTerritoryCode
func (t *Zone_State) FromStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStateTerritoryCode performs a merge with any union data inside the Zone_State, using the provided StateTerritoryCode
func (t *Zone_State) MergeStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsZoneState1 returns the union data inside the Zone_State as a ZoneState1
func (t Zone_State) AsZoneState1() (ZoneState1, error) {
	var body ZoneState1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromZoneState1 overwrites any union data inside the Zone_State as the provided ZoneState1
func (t *Zone_State) FromZoneState1(v ZoneState1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeZoneState1 performs a merge with any union data inside the Zone_State, using the provided ZoneState1
func (t *Zone_State) MergeZoneState1(v ZoneState1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Zone_State) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Zone_State) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AlertsQuery request
	AlertsQuery(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActive request
	AlertsActive(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveArea request
	AlertsActiveArea(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveCount request
	AlertsActiveCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveRegion request
	AlertsActiveRegion(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveZone request
	AlertsActiveZone(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsTypes request
	AlertsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsSingle request
	AlertsSingle(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cwsu request
	Cwsu(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cwas request
	Cwas(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cwa request
	Cwa(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SigmetQuery request
	SigmetQuery(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SigmetsByATSU request
	SigmetsByATSU(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SigmetsByATSUByDate request
	SigmetsByATSUByDate(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sigmet request
	Sigmet(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Glossary request
	Glossary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gridpoint request
	Gridpoint(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GridpointForecast request
	GridpointForecast(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GridpointForecastHourly request
	GridpointForecastHourly(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GridpointStations request
	GridpointStations(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Office request
	Office(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OfficeHeadlines request
	OfficeHeadlines(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OfficeHeadline request
	OfficeHeadline(ctx context.Context, officeId NWSOfficeId, headlineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Point request
	Point(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PointStations request
	PointStations(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsQuery request
	ProductsQuery(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductLocations request
	ProductLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LocationProducts request
	LocationProducts(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypes request
	ProductTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsType request
	ProductsType(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsTypeLocations request
	ProductsTypeLocations(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsTypeLocation request
	ProductsTypeLocation(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LatestProductTypeLocation request
	LatestProductTypeLocation(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Product request
	Product(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarProfiler request
	RadarProfiler(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarQueue request
	RadarQueue(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarServers request
	RadarServers(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarServer request
	RadarServer(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarStations request
	RadarStations(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarStation request
	RadarStation(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarStationAlarms request
	RadarStationAlarms(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObsStations request
	ObsStations(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObsStation request
	ObsStation(ctx context.Context, stationId ObservationStationId, params *ObsStationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StationObservationList request
	StationObservationList(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StationObservationLatest request
	StationObservationLatest(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StationObservationTime request
	StationObservationTime(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Tafs request
	Tafs(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Taf request
	Taf(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SatelliteThumbnails request
	SatelliteThumbnails(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneList request
	ZoneList(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneObs request
	ZoneObs(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneStations request
	ZoneStations(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneListType request
	ZoneListType(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Zone request
	Zone(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneForecast request
	ZoneForecast(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AlertsQuery(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActive(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveArea(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveAreaRequest(c.Server, area)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveRegion(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveRegionRequest(c.Server, region)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveZone(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsSingle(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsSingleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cwsu(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCwsuRequest(c.Server, cwsuId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cwas(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCwasRequest(c.Server, cwsuId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cwa(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCwaRequest(c.Server, cwsuId, date, sequence)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SigmetQuery(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SigmetsByATSU(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetsByATSURequest(c.Server, atsu)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SigmetsByATSUByDate(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetsByATSUByDateRequest(c.Server, atsu, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sigmet(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetRequest(c.Server, atsu, date, time)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Glossary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlossaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gridpoint(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointRequest(c.Server, wfo, x, y)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GridpointForecast(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointForecastRequest(c.Server, wfo, x, y, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GridpointForecastHourly(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointForecastHourlyRequest(c.Server, wfo, x, y, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GridpointStations(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointStationsRequest(c.Server, wfo, x, y, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Office(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficeRequest(c.Server, officeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OfficeHeadlines(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficeHeadlinesRequest(c.Server, officeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OfficeHeadline(ctx context.Context, officeId NWSOfficeId, headlineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficeHeadlineRequest(c.Server, officeId, headlineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Point(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPointRequest(c.Server, latitude, longitude)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PointStations(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPointStationsRequest(c.Server, latitude, longitude)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsQuery(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductLocationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LocationProducts(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLocationProductsRequest(c.Server, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsType(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsTypeRequest(c.Server, typeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsTypeLocations(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsTypeLocationsRequest(c.Server, typeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsTypeLocation(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsTypeLocationRequest(c.Server, typeId, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LatestProductTypeLocation(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLatestProductTypeLocationRequest(c.Server, typeId, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Product(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductRequest(c.Server, productId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarProfiler(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarProfilerRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarQueue(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarQueueRequest(c.Server, host, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarServers(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarServer(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarServerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarStations(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarStationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarStation(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarStationRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarStationAlarms(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarStationAlarmsRequest(c.Server, stationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObsStations(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObsStationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObsStation(ctx context.Context, stationId ObservationStationId, params *ObsStationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObsStationRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StationObservationList(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStationObservationListRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StationObservationLatest(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStationObservationLatestRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StationObservationTime(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStationObservationTimeRequest(c.Server, stationId, time)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tafs(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTafsRequest(c.Server, stationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Taf(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTafRequest(c.Server, stationId, date, time)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SatelliteThumbnails(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSatelliteThumbnailsRequest(c.Server, area)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneList(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneObs(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneObsRequest(c.Server, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneStations(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneStationsRequest(c.Server, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneListType(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneListTypeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Zone(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneRequest(c.Server, pType, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneForecast(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneForecastRequest(c.Server, pType, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAlertsQueryRequest generates requests for AlertsQuery
func NewAlertsQueryRequest(server string, params *AlertsQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MessageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "message_type", runtime.ParamLocationQuery, *params.MessageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Area != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Point != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_type", runtime.ParamLocationQuery, *params.RegionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "zone", runtime.ParamLocationQuery, *params.Zone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Urgency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "urgency", runtime.ParamLocationQuery, *params.Urgency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Certainty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certainty", runtime.ParamLocationQuery, *params.Certainty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveRequest generates requests for AlertsActive
func NewAlertsActiveRequest(server string, params *AlertsActiveParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MessageType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "message_type", runtime.ParamLocationQuery, *params.MessageType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Area != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Point != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegionType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_type", runtime.ParamLocationQuery, *params.RegionType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "zone", runtime.ParamLocationQuery, *params.Zone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Urgency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "urgency", runtime.ParamLocationQuery, *params.Urgency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Severity != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Certainty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certainty", runtime.ParamLocationQuery, *params.Certainty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveAreaRequest generates requests for AlertsActiveArea
func NewAlertsActiveAreaRequest(server string, area AreaCode) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "area", runtime.ParamLocationPath, area)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/area/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveCountRequest generates requests for AlertsActiveCount
func NewAlertsActiveCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveRegionRequest generates requests for AlertsActiveRegion
func NewAlertsActiveRegionRequest(server string, region MarineRegionCode) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "region", runtime.ParamLocationPath, region)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/region/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveZoneRequest generates requests for AlertsActiveZone
func NewAlertsActiveZoneRequest(server string, zoneId NWSZoneId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/zone/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsTypesRequest generates requests for AlertsTypes
func NewAlertsTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsSingleRequest generates requests for AlertsSingle
func NewAlertsSingleRequest(server string, id AlertId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCwsuRequest generates requests for Cwsu
func NewCwsuRequest(server string, cwsuId NWSCenterWeatherServiceUnitId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, cwsuId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/cwsus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCwasRequest generates requests for Cwas
func NewCwasRequest(server string, cwsuId NWSCenterWeatherServiceUnitId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, cwsuId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/cwsus/%s/cwas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCwaRequest generates requests for Cwa
func NewCwaRequest(server string, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, cwsuId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sequence", runtime.ParamLocationPath, sequence)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/cwsus/%s/cwas/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetQueryRequest generates requests for SigmetQuery
func NewSigmetQueryRequest(server string, params *SigmetQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Date != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Atsu != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "atsu", runtime.ParamLocationQuery, *params.Atsu); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sequence != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sequence", runtime.ParamLocationQuery, *params.Sequence); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetsByATSURequest generates requests for SigmetsByATSU
func NewSigmetsByATSURequest(server string, atsu ATSUIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "atsu", runtime.ParamLocationPath, atsu)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetsByATSUByDateRequest generates requests for SigmetsByATSUByDate
func NewSigmetsByATSUByDateRequest(server string, atsu ATSUIdentifier, date Date) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "atsu", runtime.ParamLocationPath, atsu)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetRequest generates requests for Sigmet
func NewSigmetRequest(server string, atsu ATSUIdentifier, date Date, time Time) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "atsu", runtime.ParamLocationPath, atsu)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "time", runtime.ParamLocationPath, time)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlossaryRequest generates requests for Glossary
func NewGlossaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/glossary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGridpointRequest generates requests for Gridpoint
func NewGridpointRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGridpointForecastRequest generates requests for GridpointForecast
func NewGridpointForecastRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s/forecast", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Units != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, *params.Units); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FeatureFlags != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Feature-Flags", headerParam0)
		}

	}

	return req, nil
}

// NewGridpointForecastHourlyRequest generates requests for GridpointForecastHourly
func NewGridpointForecastHourlyRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s/forecast/hourly", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Units != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, *params.Units); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FeatureFlags != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Feature-Flags", headerParam0)
		}

	}

	return req, nil
}

// NewGridpointStationsRequest generates requests for GridpointStations
func NewGridpointStationsRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s/stations", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FeatureFlags != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Feature-Flags", headerParam0)
		}

	}

	return req, nil
}

// NewOfficeRequest generates requests for Office
func NewOfficeRequest(server string, officeId NWSOfficeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "officeId", runtime.ParamLocationPath, officeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfficeHeadlinesRequest generates requests for OfficeHeadlines
func NewOfficeHeadlinesRequest(server string, officeId NWSOfficeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "officeId", runtime.ParamLocationPath, officeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offices/%s/headlines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfficeHeadlineRequest generates requests for OfficeHeadline
func NewOfficeHeadlineRequest(server string, officeId NWSOfficeId, headlineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "officeId", runtime.ParamLocationPath, officeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "headlineId", runtime.ParamLocationPath, headlineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offices/%s/headlines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPointRequest generates requests for Point
func NewPointRequest(server string, latitude Latitude, longitude Longitude) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "latitude", runtime.ParamLocationPath, latitude)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "longitude", runtime.ParamLocationPath, longitude)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/points/%s,%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPointStationsRequest generates requests for PointStations
func NewPointStationsRequest(server string, latitude Latitude, longitude Longitude) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "latitude", runtime.ParamLocationPath, latitude)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "longitude", runtime.ParamLocationPath, longitude)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/points/%s,%s/stations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsQueryRequest generates requests for ProductsQuery
func NewProductsQueryRequest(server string, params *ProductsQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Location != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Office != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "office", runtime.ParamLocationQuery, *params.Office); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wmoid != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wmoid", runtime.ParamLocationQuery, *params.Wmoid); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductLocationsRequest generates requests for ProductLocations
func NewProductLocationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLocationProductsRequest generates requests for LocationProducts
func NewLocationProductsRequest(server string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "locationId", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/locations/%s/types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesRequest generates requests for ProductTypes
func NewProductTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsTypeRequest generates requests for ProductsType
func NewProductsTypeRequest(server string, typeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsTypeLocationsRequest generates requests for ProductsTypeLocations
func NewProductsTypeLocationsRequest(server string, typeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s/locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsTypeLocationRequest generates requests for ProductsTypeLocation
func NewProductsTypeLocationRequest(server string, typeId string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "locationId", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s/locations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLatestProductTypeLocationRequest generates requests for LatestProductTypeLocation
func NewLatestProductTypeLocationRequest(server string, typeId string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "locationId", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s/locations/%s/latest", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductRequest generates requests for Product
func NewProductRequest(server string, productId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "productId", runtime.ParamLocationPath, productId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarProfilerRequest generates requests for RadarProfiler
func NewRadarProfilerRequest(server string, stationId string, params *RadarProfilerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/profilers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarQueueRequest generates requests for RadarQueue
func NewRadarQueueRequest(server string, host string, params *RadarQueueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "host", runtime.ParamLocationPath, host)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/queues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Arrived != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrived", runtime.ParamLocationQuery, *params.Arrived); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Created != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Published != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published", runtime.ParamLocationQuery, *params.Published); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Station != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "station", runtime.ParamLocationQuery, *params.Station); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Feed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feed", runtime.ParamLocationQuery, *params.Feed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarServersRequest generates requests for RadarServers
func NewRadarServersRequest(server string, params *RadarServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReportingHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarServerRequest generates requests for RadarServer
func NewRadarServerRequest(server string, id string, params *RadarServerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReportingHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarStationsRequest generates requests for RadarStations
func NewRadarStationsRequest(server string, params *RadarStationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.StationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stationType", runtime.ParamLocationQuery, *params.StationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReportingHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarStationRequest generates requests for RadarStation
func NewRadarStationRequest(server string, stationId string, params *RadarStationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/stations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReportingHost != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Host != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarStationAlarmsRequest generates requests for RadarStationAlarms
func NewRadarStationAlarmsRequest(server string, stationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/stations/%s/alarms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObsStationsRequest generates requests for ObsStations
func NewObsStationsRequest(server string, params *ObsStationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FeatureFlags != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Feature-Flags", headerParam0)
		}

	}

	return req, nil
}

// NewObsStationRequest generates requests for ObsStation
func NewObsStationRequest(server string, stationId ObservationStationId, params *ObsStationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FeatureFlags != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Feature-Flags", headerParam0)
		}

	}

	return req, nil
}

// NewStationObservationListRequest generates requests for StationObservationList
func NewStationObservationListRequest(server string, stationId ObservationStationId, params *StationObservationListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/observations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStationObservationLatestRequest generates requests for StationObservationLatest
func NewStationObservationLatestRequest(server string, stationId ObservationStationId, params *StationObservationLatestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/observations/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequireQc != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "require_qc", runtime.ParamLocationQuery, *params.RequireQc); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStationObservationTimeRequest generates requests for StationObservationTime
func NewStationObservationTimeRequest(server string, stationId ObservationStationId, time time.Time) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "time", runtime.ParamLocationPath, time)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/observations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTafsRequest generates requests for Tafs
func NewTafsRequest(server string, stationId ObservationStationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/tafs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTafRequest generates requests for Taf
func NewTafRequest(server string, stationId ObservationStationId, date Date, time Time) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "time", runtime.ParamLocationPath, time)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/tafs/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSatelliteThumbnailsRequest generates requests for SatelliteThumbnails
func NewSatelliteThumbnailsRequest(server string, area string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "area", runtime.ParamLocationPath, area)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/satellite/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneListRequest generates requests for ZoneList
func NewZoneListRequest(server string, params *ZoneListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Area != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Point != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeGeometry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_geometry", runtime.ParamLocationQuery, *params.IncludeGeometry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Effective != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneObsRequest generates requests for ZoneObs
func NewZoneObsRequest(server string, zoneId NWSZoneId, params *ZoneObsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/forecast/%s/observations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneStationsRequest generates requests for ZoneStations
func NewZoneStationsRequest(server string, zoneId NWSZoneId, params *ZoneStationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/forecast/%s/stations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.FeatureFlags != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Feature-Flags", headerParam0)
		}

	}

	return req, nil
}

// NewZoneListTypeRequest generates requests for ZoneListType
func NewZoneListTypeRequest(server string, pType NWSZoneType, params *ZoneListTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Area != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Point != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeGeometry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_geometry", runtime.ParamLocationQuery, *params.IncludeGeometry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Effective != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneRequest generates requests for Zone
func NewZoneRequest(server string, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Effective != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneForecastRequest generates requests for ZoneForecast
func NewZoneForecastRequest(server string, pType string, zoneId NWSZoneId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/%s/%s/forecast", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AlertsQueryWithResponse request
	AlertsQueryWithResponse(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*AlertsQueryResponse, error)

	// AlertsActiveWithResponse request
	AlertsActiveWithResponse(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*AlertsActiveResponse, error)

	// AlertsActiveAreaWithResponse request
	AlertsActiveAreaWithResponse(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*AlertsActiveAreaResponse, error)

	// AlertsActiveCountWithResponse request
	AlertsActiveCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsActiveCountResponse, error)

	// AlertsActiveRegionWithResponse request
	AlertsActiveRegionWithResponse(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*AlertsActiveRegionResponse, error)

	// AlertsActiveZoneWithResponse request
	AlertsActiveZoneWithResponse(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*AlertsActiveZoneResponse, error)

	// AlertsTypesWithResponse request
	AlertsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsTypesResponse, error)

	// AlertsSingleWithResponse request
	AlertsSingleWithResponse(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*AlertsSingleResponse, error)

	// CwsuWithResponse request
	CwsuWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwsuResponse, error)

	// CwasWithResponse request
	CwasWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwasResponse, error)

	// CwaWithResponse request
	CwaWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*CwaResponse, error)

	// SigmetQueryWithResponse request
	SigmetQueryWithResponse(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*SigmetQueryResponse, error)

	// SigmetsByATSUWithResponse request
	SigmetsByATSUWithResponse(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*SigmetsByATSUResponse, error)

	// SigmetsByATSUByDateWithResponse request
	SigmetsByATSUByDateWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*SigmetsByATSUByDateResponse, error)

	// SigmetWithResponse request
	SigmetWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*SigmetResponse, error)

	// GlossaryWithResponse request
	GlossaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlossaryResponse, error)

	// GridpointWithResponse request
	GridpointWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*GridpointResponse, error)

	// GridpointForecastWithResponse request
	GridpointForecastWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*GridpointForecastResponse, error)

	// GridpointForecastHourlyWithResponse request
	GridpointForecastHourlyWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*GridpointForecastHourlyResponse, error)

	// GridpointStationsWithResponse request
	GridpointStationsWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*GridpointStationsResponse, error)

	// OfficeWithResponse request
	OfficeWithResponse(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*OfficeResponse, error)

	// OfficeHeadlinesWithResponse request
	OfficeHeadlinesWithResponse(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*OfficeHeadlinesResponse, error)

	// OfficeHeadlineWithResponse request
	OfficeHeadlineWithResponse(ctx context.Context, officeId NWSOfficeId, headlineId string, reqEditors ...RequestEditorFn) (*OfficeHeadlineResponse, error)

	// PointWithResponse request
	PointWithResponse(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*PointResponse, error)

	// PointStationsWithResponse request
	PointStationsWithResponse(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*PointStationsResponse, error)

	// ProductsQueryWithResponse request
	ProductsQueryWithResponse(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*ProductsQueryResponse, error)

	// ProductLocationsWithResponse request
	ProductLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductLocationsResponse, error)

	// LocationProductsWithResponse request
	LocationProductsWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*LocationProductsResponse, error)

	// ProductTypesWithResponse request
	ProductTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductTypesResponse, error)

	// ProductsTypeWithResponse request
	ProductsTypeWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeResponse, error)

	// ProductsTypeLocationsWithResponse request
	ProductsTypeLocationsWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationsResponse, error)

	// ProductsTypeLocationWithResponse request
	ProductsTypeLocationWithResponse(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationResponse, error)

	// LatestProductTypeLocationWithResponse request
	LatestProductTypeLocationWithResponse(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*LatestProductTypeLocationResponse, error)

	// ProductWithResponse request
	ProductWithResponse(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*ProductResponse, error)

	// RadarProfilerWithResponse request
	RadarProfilerWithResponse(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*RadarProfilerResponse, error)

	// RadarQueueWithResponse request
	RadarQueueWithResponse(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*RadarQueueResponse, error)

	// RadarServersWithResponse request
	RadarServersWithResponse(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*RadarServersResponse, error)

	// RadarServerWithResponse request
	RadarServerWithResponse(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*RadarServerResponse, error)

	// RadarStationsWithResponse request
	RadarStationsWithResponse(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*RadarStationsResponse, error)

	// RadarStationWithResponse request
	RadarStationWithResponse(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*RadarStationResponse, error)

	// RadarStationAlarmsWithResponse request
	RadarStationAlarmsWithResponse(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*RadarStationAlarmsResponse, error)

	// ObsStationsWithResponse request
	ObsStationsWithResponse(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*ObsStationsResponse, error)

	// ObsStationWithResponse request
	ObsStationWithResponse(ctx context.Context, stationId ObservationStationId, params *ObsStationParams, reqEditors ...RequestEditorFn) (*ObsStationResponse, error)

	// StationObservationListWithResponse request
	StationObservationListWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*StationObservationListResponse, error)

	// StationObservationLatestWithResponse request
	StationObservationLatestWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*StationObservationLatestResponse, error)

	// StationObservationTimeWithResponse request
	StationObservationTimeWithResponse(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*StationObservationTimeResponse, error)

	// TafsWithResponse request
	TafsWithResponse(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*TafsResponse, error)

	// TafWithResponse request
	TafWithResponse(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*TafResponse, error)

	// SatelliteThumbnailsWithResponse request
	SatelliteThumbnailsWithResponse(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*SatelliteThumbnailsResponse, error)

	// ZoneListWithResponse request
	ZoneListWithResponse(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*ZoneListResponse, error)

	// ZoneObsWithResponse request
	ZoneObsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*ZoneObsResponse, error)

	// ZoneStationsWithResponse request
	ZoneStationsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*ZoneStationsResponse, error)

	// ZoneListTypeWithResponse request
	ZoneListTypeWithResponse(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*ZoneListTypeResponse, error)

	// ZoneWithResponse request
	ZoneWithResponse(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*ZoneResponse, error)

	// ZoneForecastWithResponse request
	ZoneForecastWithResponse(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*ZoneForecastResponse, error)
}

type AlertsQueryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *AlertCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *AlertCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *AlertCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *AlertCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsActiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveAreaResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *AlertCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *AlertCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsActiveAreaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveAreaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveCountResponse struct {
	Body                 []byte
	HTTPResponse         *http.Response
	ApplicationldJSON200 *struct {
		// Areas Active alerts by area (state/territory)
		Areas *map[string]int `json:"areas,omitempty"`

		// Land The total number of active alerts affecting land zones
		Land *int `json:"land,omitempty"`

		// Marine The total number of active alerts affecting marine zones
		Marine *int `json:"marine,omitempty"`

		// Regions Active alerts by marine region
		Regions *map[string]int `json:"regions,omitempty"`

		// Total The total number of active alerts
		Total *int `json:"total,omitempty"`

		// Zones Active alerts by NWS public zone or county code
		Zones *map[string]int `json:"zones,omitempty"`
	}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsActiveCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveRegionResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *AlertCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *AlertCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsActiveRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveZoneResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *AlertCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *AlertCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsActiveZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsTypesResponse struct {
	Body                 []byte
	HTTPResponse         *http.Response
	ApplicationldJSON200 *struct {
		// EventTypes A list of recognized event types
		EventTypes *[]string `json:"eventTypes,omitempty"`
	}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsSingleResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *AlertGeoJson
	ApplicationldJSON200          *AlertJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r AlertsSingleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsSingleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CwsuResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *CenterWeatherServiceUnitJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CwsuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CwsuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CwasResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *CenterWeatherAdvisoryCollectionGeoJson
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CwasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CwasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CwaResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *CenterWeatherAdvisoryGeoJson
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r CwaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CwaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetQueryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *SigmetCollectionGeoJson
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SigmetQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetsByATSUResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *SigmetCollectionGeoJson
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SigmetsByATSUResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetsByATSUResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetsByATSUByDateResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *SigmetCollectionGeoJson
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SigmetsByATSUByDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetsByATSUByDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *SigmetGeoJson
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SigmetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlossaryResponse struct {
	Body                 []byte
	HTTPResponse         *http.Response
	ApplicationldJSON200 *struct {
		Context *JsonLdContext `json:"@context,omitempty"`

		// Glossary A list of glossary terms
		Glossary *[]struct {
			// Definition A definition for the term
			Definition *string `json:"definition,omitempty"`

			// Term The term being defined
			Term *string `json:"term,omitempty"`
		} `json:"glossary,omitempty"`
	}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GlossaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlossaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *GridpointGeoJson
	ApplicationldJSON200          *GridpointJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GridpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointForecastResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *Gridpoint12hForecastApplicationGeoPlusJSON
	ApplicationldJSON200          *Gridpoint12hForecastApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GridpointForecastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointForecastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointForecastHourlyResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *GridpointHourlyForecastApplicationGeoPlusJSON
	ApplicationldJSON200          *GridpointHourlyForecastApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GridpointForecastHourlyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointForecastHourlyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointStationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationStationCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *ObservationStationCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r GridpointStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *Office
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r OfficeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficeHeadlinesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *OfficeHeadlineCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r OfficeHeadlinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficeHeadlinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficeHeadlineResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *OfficeHeadline
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r OfficeHeadlineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficeHeadlineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PointResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *PointGeoJson
	ApplicationldJSON200          *PointJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PointStationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r PointStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PointStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsQueryResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductLocationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductLocationCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LocationProductsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductTypeCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r LocationProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LocationProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductTypeCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsTypeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductsTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsTypeLocationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductLocationCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductsTypeLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsTypeLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsTypeLocationResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductsTypeLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsTypeLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LatestProductTypeLocationResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProductCollection
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r LatestProductTypeLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LatestProductTypeLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *TextProduct
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarProfilerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarProfilerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarProfilerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarQueueResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarServersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarServerResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarStationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *interface{}
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarStationResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *interface{}
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarStationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarStationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarStationAlarmsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r RadarStationAlarmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarStationAlarmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObsStationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationStationCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *ObservationStationCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ObsStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObsStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObsStationResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationStationGeoJson
	ApplicationldJSON200          *ObservationStationJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ObsStationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObsStationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StationObservationListResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *ObservationCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StationObservationListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StationObservationListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StationObservationLatestResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationApplicationGeoPlusJSON
	ApplicationldJSON200          *ObservationApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StationObservationLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StationObservationLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StationObservationTimeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationApplicationGeoPlusJSON
	ApplicationldJSON200          *ObservationApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r StationObservationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StationObservationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TafsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationldJSON200          *interface{}
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TafsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TafsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TafResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r TafResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TafResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SatelliteThumbnailsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r SatelliteThumbnailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SatelliteThumbnailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneListResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ZoneCollectionGeoJson
	ApplicationldJSON200          *ZoneCollectionJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ZoneListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneObsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationCollectionGeoJson
	ApplicationldJSON200          *ObservationCollectionJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ZoneObsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneObsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneStationsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ObservationStationCollectionApplicationGeoPlusJSON
	ApplicationldJSON200          *ObservationStationCollectionApplicationLdPlusJSON
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ZoneStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneListTypeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ZoneCollectionGeoJson
	ApplicationldJSON200          *ZoneCollectionJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ZoneListTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneListTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ZoneGeoJson
	ApplicationldJSON200          *ZoneJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneForecastResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationgeoJSON200         *ZoneForecastGeoJson
	ApplicationldJSON200          *ZoneForecastJsonLd
	ApplicationproblemJSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ZoneForecastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneForecastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AlertsQueryWithResponse request returning *AlertsQueryResponse
func (c *ClientWithResponses) AlertsQueryWithResponse(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*AlertsQueryResponse, error) {
	rsp, err := c.AlertsQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsQueryResponse(rsp)
}

// AlertsActiveWithResponse request returning *AlertsActiveResponse
func (c *ClientWithResponses) AlertsActiveWithResponse(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*AlertsActiveResponse, error) {
	rsp, err := c.AlertsActive(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveResponse(rsp)
}

// AlertsActiveAreaWithResponse request returning *AlertsActiveAreaResponse
func (c *ClientWithResponses) AlertsActiveAreaWithResponse(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*AlertsActiveAreaResponse, error) {
	rsp, err := c.AlertsActiveArea(ctx, area, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveAreaResponse(rsp)
}

// AlertsActiveCountWithResponse request returning *AlertsActiveCountResponse
func (c *ClientWithResponses) AlertsActiveCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsActiveCountResponse, error) {
	rsp, err := c.AlertsActiveCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveCountResponse(rsp)
}

// AlertsActiveRegionWithResponse request returning *AlertsActiveRegionResponse
func (c *ClientWithResponses) AlertsActiveRegionWithResponse(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*AlertsActiveRegionResponse, error) {
	rsp, err := c.AlertsActiveRegion(ctx, region, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveRegionResponse(rsp)
}

// AlertsActiveZoneWithResponse request returning *AlertsActiveZoneResponse
func (c *ClientWithResponses) AlertsActiveZoneWithResponse(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*AlertsActiveZoneResponse, error) {
	rsp, err := c.AlertsActiveZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveZoneResponse(rsp)
}

// AlertsTypesWithResponse request returning *AlertsTypesResponse
func (c *ClientWithResponses) AlertsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsTypesResponse, error) {
	rsp, err := c.AlertsTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsTypesResponse(rsp)
}

// AlertsSingleWithResponse request returning *AlertsSingleResponse
func (c *ClientWithResponses) AlertsSingleWithResponse(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*AlertsSingleResponse, error) {
	rsp, err := c.AlertsSingle(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsSingleResponse(rsp)
}

// CwsuWithResponse request returning *CwsuResponse
func (c *ClientWithResponses) CwsuWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwsuResponse, error) {
	rsp, err := c.Cwsu(ctx, cwsuId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCwsuResponse(rsp)
}

// CwasWithResponse request returning *CwasResponse
func (c *ClientWithResponses) CwasWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwasResponse, error) {
	rsp, err := c.Cwas(ctx, cwsuId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCwasResponse(rsp)
}

// CwaWithResponse request returning *CwaResponse
func (c *ClientWithResponses) CwaWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*CwaResponse, error) {
	rsp, err := c.Cwa(ctx, cwsuId, date, sequence, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCwaResponse(rsp)
}

// SigmetQueryWithResponse request returning *SigmetQueryResponse
func (c *ClientWithResponses) SigmetQueryWithResponse(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*SigmetQueryResponse, error) {
	rsp, err := c.SigmetQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetQueryResponse(rsp)
}

// SigmetsByATSUWithResponse request returning *SigmetsByATSUResponse
func (c *ClientWithResponses) SigmetsByATSUWithResponse(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*SigmetsByATSUResponse, error) {
	rsp, err := c.SigmetsByATSU(ctx, atsu, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetsByATSUResponse(rsp)
}

// SigmetsByATSUByDateWithResponse request returning *SigmetsByATSUByDateResponse
func (c *ClientWithResponses) SigmetsByATSUByDateWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*SigmetsByATSUByDateResponse, error) {
	rsp, err := c.SigmetsByATSUByDate(ctx, atsu, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetsByATSUByDateResponse(rsp)
}

// SigmetWithResponse request returning *SigmetResponse
func (c *ClientWithResponses) SigmetWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*SigmetResponse, error) {
	rsp, err := c.Sigmet(ctx, atsu, date, time, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetResponse(rsp)
}

// GlossaryWithResponse request returning *GlossaryResponse
func (c *ClientWithResponses) GlossaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlossaryResponse, error) {
	rsp, err := c.Glossary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlossaryResponse(rsp)
}

// GridpointWithResponse request returning *GridpointResponse
func (c *ClientWithResponses) GridpointWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*GridpointResponse, error) {
	rsp, err := c.Gridpoint(ctx, wfo, x, y, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointResponse(rsp)
}

// GridpointForecastWithResponse request returning *GridpointForecastResponse
func (c *ClientWithResponses) GridpointForecastWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*GridpointForecastResponse, error) {
	rsp, err := c.GridpointForecast(ctx, wfo, x, y, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointForecastResponse(rsp)
}

// GridpointForecastHourlyWithResponse request returning *GridpointForecastHourlyResponse
func (c *ClientWithResponses) GridpointForecastHourlyWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*GridpointForecastHourlyResponse, error) {
	rsp, err := c.GridpointForecastHourly(ctx, wfo, x, y, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointForecastHourlyResponse(rsp)
}

// GridpointStationsWithResponse request returning *GridpointStationsResponse
func (c *ClientWithResponses) GridpointStationsWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*GridpointStationsResponse, error) {
	rsp, err := c.GridpointStations(ctx, wfo, x, y, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointStationsResponse(rsp)
}

// OfficeWithResponse request returning *OfficeResponse
func (c *ClientWithResponses) OfficeWithResponse(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*OfficeResponse, error) {
	rsp, err := c.Office(ctx, officeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficeResponse(rsp)
}

// OfficeHeadlinesWithResponse request returning *OfficeHeadlinesResponse
func (c *ClientWithResponses) OfficeHeadlinesWithResponse(ctx context.Context, officeId NWSOfficeId, reqEditors ...RequestEditorFn) (*OfficeHeadlinesResponse, error) {
	rsp, err := c.OfficeHeadlines(ctx, officeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficeHeadlinesResponse(rsp)
}

// OfficeHeadlineWithResponse request returning *OfficeHeadlineResponse
func (c *ClientWithResponses) OfficeHeadlineWithResponse(ctx context.Context, officeId NWSOfficeId, headlineId string, reqEditors ...RequestEditorFn) (*OfficeHeadlineResponse, error) {
	rsp, err := c.OfficeHeadline(ctx, officeId, headlineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficeHeadlineResponse(rsp)
}

// PointWithResponse request returning *PointResponse
func (c *ClientWithResponses) PointWithResponse(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*PointResponse, error) {
	rsp, err := c.Point(ctx, latitude, longitude, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePointResponse(rsp)
}

// PointStationsWithResponse request returning *PointStationsResponse
func (c *ClientWithResponses) PointStationsWithResponse(ctx context.Context, latitude Latitude, longitude Longitude, reqEditors ...RequestEditorFn) (*PointStationsResponse, error) {
	rsp, err := c.PointStations(ctx, latitude, longitude, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePointStationsResponse(rsp)
}

// ProductsQueryWithResponse request returning *ProductsQueryResponse
func (c *ClientWithResponses) ProductsQueryWithResponse(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*ProductsQueryResponse, error) {
	rsp, err := c.ProductsQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsQueryResponse(rsp)
}

// ProductLocationsWithResponse request returning *ProductLocationsResponse
func (c *ClientWithResponses) ProductLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductLocationsResponse, error) {
	rsp, err := c.ProductLocations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductLocationsResponse(rsp)
}

// LocationProductsWithResponse request returning *LocationProductsResponse
func (c *ClientWithResponses) LocationProductsWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*LocationProductsResponse, error) {
	rsp, err := c.LocationProducts(ctx, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLocationProductsResponse(rsp)
}

// ProductTypesWithResponse request returning *ProductTypesResponse
func (c *ClientWithResponses) ProductTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductTypesResponse, error) {
	rsp, err := c.ProductTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesResponse(rsp)
}

// ProductsTypeWithResponse request returning *ProductsTypeResponse
func (c *ClientWithResponses) ProductsTypeWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeResponse, error) {
	rsp, err := c.ProductsType(ctx, typeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsTypeResponse(rsp)
}

// ProductsTypeLocationsWithResponse request returning *ProductsTypeLocationsResponse
func (c *ClientWithResponses) ProductsTypeLocationsWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationsResponse, error) {
	rsp, err := c.ProductsTypeLocations(ctx, typeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsTypeLocationsResponse(rsp)
}

// ProductsTypeLocationWithResponse request returning *ProductsTypeLocationResponse
func (c *ClientWithResponses) ProductsTypeLocationWithResponse(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationResponse, error) {
	rsp, err := c.ProductsTypeLocation(ctx, typeId, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsTypeLocationResponse(rsp)
}

// LatestProductTypeLocationWithResponse request returning *LatestProductTypeLocationResponse
func (c *ClientWithResponses) LatestProductTypeLocationWithResponse(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*LatestProductTypeLocationResponse, error) {
	rsp, err := c.LatestProductTypeLocation(ctx, typeId, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLatestProductTypeLocationResponse(rsp)
}

// ProductWithResponse request returning *ProductResponse
func (c *ClientWithResponses) ProductWithResponse(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*ProductResponse, error) {
	rsp, err := c.Product(ctx, productId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductResponse(rsp)
}

// RadarProfilerWithResponse request returning *RadarProfilerResponse
func (c *ClientWithResponses) RadarProfilerWithResponse(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*RadarProfilerResponse, error) {
	rsp, err := c.RadarProfiler(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarProfilerResponse(rsp)
}

// RadarQueueWithResponse request returning *RadarQueueResponse
func (c *ClientWithResponses) RadarQueueWithResponse(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*RadarQueueResponse, error) {
	rsp, err := c.RadarQueue(ctx, host, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarQueueResponse(rsp)
}

// RadarServersWithResponse request returning *RadarServersResponse
func (c *ClientWithResponses) RadarServersWithResponse(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*RadarServersResponse, error) {
	rsp, err := c.RadarServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarServersResponse(rsp)
}

// RadarServerWithResponse request returning *RadarServerResponse
func (c *ClientWithResponses) RadarServerWithResponse(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*RadarServerResponse, error) {
	rsp, err := c.RadarServer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarServerResponse(rsp)
}

// RadarStationsWithResponse request returning *RadarStationsResponse
func (c *ClientWithResponses) RadarStationsWithResponse(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*RadarStationsResponse, error) {
	rsp, err := c.RadarStations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarStationsResponse(rsp)
}

// RadarStationWithResponse request returning *RadarStationResponse
func (c *ClientWithResponses) RadarStationWithResponse(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*RadarStationResponse, error) {
	rsp, err := c.RadarStation(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarStationResponse(rsp)
}

// RadarStationAlarmsWithResponse request returning *RadarStationAlarmsResponse
func (c *ClientWithResponses) RadarStationAlarmsWithResponse(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*RadarStationAlarmsResponse, error) {
	rsp, err := c.RadarStationAlarms(ctx, stationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarStationAlarmsResponse(rsp)
}

// ObsStationsWithResponse request returning *ObsStationsResponse
func (c *ClientWithResponses) ObsStationsWithResponse(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*ObsStationsResponse, error) {
	rsp, err := c.ObsStations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObsStationsResponse(rsp)
}

// ObsStationWithResponse request returning *ObsStationResponse
func (c *ClientWithResponses) ObsStationWithResponse(ctx context.Context, stationId ObservationStationId, params *ObsStationParams, reqEditors ...RequestEditorFn) (*ObsStationResponse, error) {
	rsp, err := c.ObsStation(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObsStationResponse(rsp)
}

// StationObservationListWithResponse request returning *StationObservationListResponse
func (c *ClientWithResponses) StationObservationListWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*StationObservationListResponse, error) {
	rsp, err := c.StationObservationList(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStationObservationListResponse(rsp)
}

// StationObservationLatestWithResponse request returning *StationObservationLatestResponse
func (c *ClientWithResponses) StationObservationLatestWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*StationObservationLatestResponse, error) {
	rsp, err := c.StationObservationLatest(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStationObservationLatestResponse(rsp)
}

// StationObservationTimeWithResponse request returning *StationObservationTimeResponse
func (c *ClientWithResponses) StationObservationTimeWithResponse(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*StationObservationTimeResponse, error) {
	rsp, err := c.StationObservationTime(ctx, stationId, time, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStationObservationTimeResponse(rsp)
}

// TafsWithResponse request returning *TafsResponse
func (c *ClientWithResponses) TafsWithResponse(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*TafsResponse, error) {
	rsp, err := c.Tafs(ctx, stationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTafsResponse(rsp)
}

// TafWithResponse request returning *TafResponse
func (c *ClientWithResponses) TafWithResponse(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*TafResponse, error) {
	rsp, err := c.Taf(ctx, stationId, date, time, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTafResponse(rsp)
}

// SatelliteThumbnailsWithResponse request returning *SatelliteThumbnailsResponse
func (c *ClientWithResponses) SatelliteThumbnailsWithResponse(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*SatelliteThumbnailsResponse, error) {
	rsp, err := c.SatelliteThumbnails(ctx, area, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSatelliteThumbnailsResponse(rsp)
}

// ZoneListWithResponse request returning *ZoneListResponse
func (c *ClientWithResponses) ZoneListWithResponse(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*ZoneListResponse, error) {
	rsp, err := c.ZoneList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneListResponse(rsp)
}

// ZoneObsWithResponse request returning *ZoneObsResponse
func (c *ClientWithResponses) ZoneObsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*ZoneObsResponse, error) {
	rsp, err := c.ZoneObs(ctx, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneObsResponse(rsp)
}

// ZoneStationsWithResponse request returning *ZoneStationsResponse
func (c *ClientWithResponses) ZoneStationsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*ZoneStationsResponse, error) {
	rsp, err := c.ZoneStations(ctx, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneStationsResponse(rsp)
}

// ZoneListTypeWithResponse request returning *ZoneListTypeResponse
func (c *ClientWithResponses) ZoneListTypeWithResponse(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*ZoneListTypeResponse, error) {
	rsp, err := c.ZoneListType(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneListTypeResponse(rsp)
}

// ZoneWithResponse request returning *ZoneResponse
func (c *ClientWithResponses) ZoneWithResponse(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*ZoneResponse, error) {
	rsp, err := c.Zone(ctx, pType, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneResponse(rsp)
}

// ZoneForecastWithResponse request returning *ZoneForecastResponse
func (c *ClientWithResponses) ZoneForecastWithResponse(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*ZoneForecastResponse, error) {
	rsp, err := c.ZoneForecast(ctx, pType, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneForecastResponse(rsp)
}

// ParseAlertsQueryResponse parses an HTTP response from a AlertsQueryWithResponse call
func ParseAlertsQueryResponse(rsp *http.Response) (*AlertsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/atom+xml) unsupported

	}

	return response, nil
}

// ParseAlertsActiveResponse parses an HTTP response from a AlertsActiveWithResponse call
func ParseAlertsActiveResponse(rsp *http.Response) (*AlertsActiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/atom+xml) unsupported

	}

	return response, nil
}

// ParseAlertsActiveAreaResponse parses an HTTP response from a AlertsActiveAreaWithResponse call
func ParseAlertsActiveAreaResponse(rsp *http.Response) (*AlertsActiveAreaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveAreaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/atom+xml) unsupported

	}

	return response, nil
}

// ParseAlertsActiveCountResponse parses an HTTP response from a AlertsActiveCountWithResponse call
func ParseAlertsActiveCountResponse(rsp *http.Response) (*AlertsActiveCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Areas Active alerts by area (state/territory)
			Areas *map[string]int `json:"areas,omitempty"`

			// Land The total number of active alerts affecting land zones
			Land *int `json:"land,omitempty"`

			// Marine The total number of active alerts affecting marine zones
			Marine *int `json:"marine,omitempty"`

			// Regions Active alerts by marine region
			Regions *map[string]int `json:"regions,omitempty"`

			// Total The total number of active alerts
			Total *int `json:"total,omitempty"`

			// Zones Active alerts by NWS public zone or county code
			Zones *map[string]int `json:"zones,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsActiveRegionResponse parses an HTTP response from a AlertsActiveRegionWithResponse call
func ParseAlertsActiveRegionResponse(rsp *http.Response) (*AlertsActiveRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/atom+xml) unsupported

	}

	return response, nil
}

// ParseAlertsActiveZoneResponse parses an HTTP response from a AlertsActiveZoneWithResponse call
func ParseAlertsActiveZoneResponse(rsp *http.Response) (*AlertsActiveZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest AlertCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/atom+xml) unsupported

	}

	return response, nil
}

// ParseAlertsTypesResponse parses an HTTP response from a AlertsTypesWithResponse call
func ParseAlertsTypesResponse(rsp *http.Response) (*AlertsTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// EventTypes A list of recognized event types
			EventTypes *[]string `json:"eventTypes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsSingleResponse parses an HTTP response from a AlertsSingleWithResponse call
func ParseAlertsSingleResponse(rsp *http.Response) (*AlertsSingleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsSingleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest AlertGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest AlertJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/cap+xml) unsupported

	}

	return response, nil
}

// ParseCwsuResponse parses an HTTP response from a CwsuWithResponse call
func ParseCwsuResponse(rsp *http.Response) (*CwsuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CwsuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CenterWeatherServiceUnitJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCwasResponse parses an HTTP response from a CwasWithResponse call
func ParseCwasResponse(rsp *http.Response) (*CwasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CwasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CenterWeatherAdvisoryCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseCwaResponse parses an HTTP response from a CwaWithResponse call
func ParseCwaResponse(rsp *http.Response) (*CwaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CwaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CenterWeatherAdvisoryGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.noaa.uswx+xml) unsupported

	}

	return response, nil
}

// ParseSigmetQueryResponse parses an HTTP response from a SigmetQueryWithResponse call
func ParseSigmetQueryResponse(rsp *http.Response) (*SigmetQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SigmetCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetsByATSUResponse parses an HTTP response from a SigmetsByATSUWithResponse call
func ParseSigmetsByATSUResponse(rsp *http.Response) (*SigmetsByATSUResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetsByATSUResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SigmetCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetsByATSUByDateResponse parses an HTTP response from a SigmetsByATSUByDateWithResponse call
func ParseSigmetsByATSUByDateResponse(rsp *http.Response) (*SigmetsByATSUByDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetsByATSUByDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SigmetCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetResponse parses an HTTP response from a SigmetWithResponse call
func ParseSigmetResponse(rsp *http.Response) (*SigmetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SigmetGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.noaa.uswx+xml) unsupported

	}

	return response, nil
}

// ParseGlossaryResponse parses an HTTP response from a GlossaryWithResponse call
func ParseGlossaryResponse(rsp *http.Response) (*GlossaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlossaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Context *JsonLdContext `json:"@context,omitempty"`

			// Glossary A list of glossary terms
			Glossary *[]struct {
				// Definition A definition for the term
				Definition *string `json:"definition,omitempty"`

				// Term The term being defined
				Term *string `json:"term,omitempty"`
			} `json:"glossary,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGridpointResponse parses an HTTP response from a GridpointWithResponse call
func ParseGridpointResponse(rsp *http.Response) (*GridpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest GridpointGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest GridpointJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseGridpointForecastResponse parses an HTTP response from a GridpointForecastWithResponse call
func ParseGridpointForecastResponse(rsp *http.Response) (*GridpointForecastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointForecastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest Gridpoint12hForecastApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest Gridpoint12hForecastApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.noaa.dwml+xml) unsupported

	}

	return response, nil
}

// ParseGridpointForecastHourlyResponse parses an HTTP response from a GridpointForecastHourlyWithResponse call
func ParseGridpointForecastHourlyResponse(rsp *http.Response) (*GridpointForecastHourlyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointForecastHourlyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest GridpointHourlyForecastApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest GridpointHourlyForecastApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.noaa.dwml+xml) unsupported

	}

	return response, nil
}

// ParseGridpointStationsResponse parses an HTTP response from a GridpointStationsWithResponse call
func ParseGridpointStationsResponse(rsp *http.Response) (*GridpointStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationStationCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationStationCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseOfficeResponse parses an HTTP response from a OfficeWithResponse call
func ParseOfficeResponse(rsp *http.Response) (*OfficeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Office
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseOfficeHeadlinesResponse parses an HTTP response from a OfficeHeadlinesWithResponse call
func ParseOfficeHeadlinesResponse(rsp *http.Response) (*OfficeHeadlinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficeHeadlinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OfficeHeadlineCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseOfficeHeadlineResponse parses an HTTP response from a OfficeHeadlineWithResponse call
func ParseOfficeHeadlineResponse(rsp *http.Response) (*OfficeHeadlineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficeHeadlineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OfficeHeadline
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePointResponse parses an HTTP response from a PointWithResponse call
func ParsePointResponse(rsp *http.Response) (*PointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest PointGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest PointJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParsePointStationsResponse parses an HTTP response from a PointStationsWithResponse call
func ParsePointStationsResponse(rsp *http.Response) (*PointStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PointStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductsQueryResponse parses an HTTP response from a ProductsQueryWithResponse call
func ParseProductsQueryResponse(rsp *http.Response) (*ProductsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductLocationsResponse parses an HTTP response from a ProductLocationsWithResponse call
func ParseProductLocationsResponse(rsp *http.Response) (*ProductLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductLocationCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLocationProductsResponse parses an HTTP response from a LocationProductsWithResponse call
func ParseLocationProductsResponse(rsp *http.Response) (*LocationProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LocationProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductTypeCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductTypesResponse parses an HTTP response from a ProductTypesWithResponse call
func ParseProductTypesResponse(rsp *http.Response) (*ProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductTypeCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductsTypeResponse parses an HTTP response from a ProductsTypeWithResponse call
func ParseProductsTypeResponse(rsp *http.Response) (*ProductsTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductsTypeLocationsResponse parses an HTTP response from a ProductsTypeLocationsWithResponse call
func ParseProductsTypeLocationsResponse(rsp *http.Response) (*ProductsTypeLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsTypeLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductLocationCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductsTypeLocationResponse parses an HTTP response from a ProductsTypeLocationWithResponse call
func ParseProductsTypeLocationResponse(rsp *http.Response) (*ProductsTypeLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsTypeLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseLatestProductTypeLocationResponse parses an HTTP response from a LatestProductTypeLocationWithResponse call
func ParseLatestProductTypeLocationResponse(rsp *http.Response) (*LatestProductTypeLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LatestProductTypeLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProductCollection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseProductResponse parses an HTTP response from a ProductWithResponse call
func ParseProductResponse(rsp *http.Response) (*ProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TextProduct
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarProfilerResponse parses an HTTP response from a RadarProfilerWithResponse call
func ParseRadarProfilerResponse(rsp *http.Response) (*RadarProfilerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarProfilerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarQueueResponse parses an HTTP response from a RadarQueueWithResponse call
func ParseRadarQueueResponse(rsp *http.Response) (*RadarQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarServersResponse parses an HTTP response from a RadarServersWithResponse call
func ParseRadarServersResponse(rsp *http.Response) (*RadarServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarServerResponse parses an HTTP response from a RadarServerWithResponse call
func ParseRadarServerResponse(rsp *http.Response) (*RadarServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarStationsResponse parses an HTTP response from a RadarStationsWithResponse call
func ParseRadarStationsResponse(rsp *http.Response) (*RadarStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarStationResponse parses an HTTP response from a RadarStationWithResponse call
func ParseRadarStationResponse(rsp *http.Response) (*RadarStationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarStationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseRadarStationAlarmsResponse parses an HTTP response from a RadarStationAlarmsWithResponse call
func ParseRadarStationAlarmsResponse(rsp *http.Response) (*RadarStationAlarmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarStationAlarmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseObsStationsResponse parses an HTTP response from a ObsStationsWithResponse call
func ParseObsStationsResponse(rsp *http.Response) (*ObsStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObsStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationStationCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationStationCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseObsStationResponse parses an HTTP response from a ObsStationWithResponse call
func ParseObsStationResponse(rsp *http.Response) (*ObsStationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObsStationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationStationGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationStationJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseStationObservationListResponse parses an HTTP response from a StationObservationListWithResponse call
func ParseStationObservationListResponse(rsp *http.Response) (*StationObservationListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StationObservationListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseStationObservationLatestResponse parses an HTTP response from a StationObservationLatestWithResponse call
func ParseStationObservationLatestResponse(rsp *http.Response) (*StationObservationLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StationObservationLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.noaa.uswx+xml) unsupported

	}

	return response, nil
}

// ParseStationObservationTimeResponse parses an HTTP response from a StationObservationTimeWithResponse call
func ParseStationObservationTimeResponse(rsp *http.Response) (*StationObservationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StationObservationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.noaa.uswx+xml) unsupported

	}

	return response, nil
}

// ParseTafsResponse parses an HTTP response from a TafsWithResponse call
func ParseTafsResponse(rsp *http.Response) (*TafsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TafsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseTafResponse parses an HTTP response from a TafWithResponse call
func ParseTafResponse(rsp *http.Response) (*TafResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TafResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseSatelliteThumbnailsResponse parses an HTTP response from a SatelliteThumbnailsWithResponse call
func ParseSatelliteThumbnailsResponse(rsp *http.Response) (*SatelliteThumbnailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SatelliteThumbnailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseZoneListResponse parses an HTTP response from a ZoneListWithResponse call
func ParseZoneListResponse(rsp *http.Response) (*ZoneListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ZoneCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ZoneCollectionJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseZoneObsResponse parses an HTTP response from a ZoneObsWithResponse call
func ParseZoneObsResponse(rsp *http.Response) (*ZoneObsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneObsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationCollectionJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseZoneStationsResponse parses an HTTP response from a ZoneStationsWithResponse call
func ParseZoneStationsResponse(rsp *http.Response) (*ZoneStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ObservationStationCollectionApplicationGeoPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ObservationStationCollectionApplicationLdPlusJSON
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseZoneListTypeResponse parses an HTTP response from a ZoneListTypeWithResponse call
func ParseZoneListTypeResponse(rsp *http.Response) (*ZoneListTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneListTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ZoneCollectionGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ZoneCollectionJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseZoneResponse parses an HTTP response from a ZoneWithResponse call
func ParseZoneResponse(rsp *http.Response) (*ZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ZoneGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ZoneJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}

// ParseZoneForecastResponse parses an HTTP response from a ZoneForecastWithResponse call
func ParseZoneForecastResponse(rsp *http.Response) (*ZoneForecastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneForecastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case rsp.Header.Get("Content-Type") == "application/geo+json" && rsp.StatusCode == 200:
		var dest ZoneForecastGeoJson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationgeoJSON200 = &dest

	case rsp.Header.Get("Content-Type") == "application/ld+json" && rsp.StatusCode == 200:
		var dest ZoneForecastJsonLd
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationldJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSONDefault = &dest

	}

	return response, nil
}
